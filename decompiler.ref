$INCLUDE "LibraryEx";

$ENTRY Go {
  = <Main <ArgList>>;
}

Main {
  (e.ProgName) (e.Input) e._
    = <Decompile <LoadBytes e.Input>>;

  (e.ProgName) = <Prout 'Bad command line'>;
}

Decompile {
  e.Bytes
    = <DecodeStructure e.Bytes>
    : (e.ModuleName)
      (s.BytecodeSize s.EntryCount s.Externs s.Words s.FunctionStarts)
      (e.Entries) (e.Externs) (e.Words) (e.FunctionStarts) e.Bytes^
    = <Disassemble
        (e.Words) (e.FunctionStarts) (e.Entries) s.BytecodeSize e.Bytes
      >
    : (e.FunctionTable) e.Functions
    = <Map &DecompileFunction e.Functions> : e.Functions^
    = <Prout '/* Module: "' e.ModuleName '" */'>
      <Prout>
      <Map
        {
          (e.Function)
            = <Map
                {
                  (e.Command) = <Prout e.Command>;
                }
                e.Function
              >
              <Prout>
        }
        e.Functions
      >
      <Prout>
      <Prout '/* Bytecode size: ' <Symb s.BytecodeSize> ' */'>
      <Prout>

      <Prout '/* Entries: ' <Symb s.EntryCount> ' */'>
      <Map
        {
          (e.Entry s.Offset)
            = <Prout '/* $ENTRY ' e.Entry ';\toffset ' <Symb s.Offset> ' */'>;
        }
        e.Entries
      >
      <Prout>

      <Prout '/* Externs: ' <Symb s.Externs> ' */'>
      <Map
        {
          (e.Extern) = <Prout '$EXTERN ' e.Extern ';'>;
        }
        e.Externs
      >
      <Prout>

      <Prout '/* Words: ' <Symb s.Words> ' */'>
      <Map
        {
          (e.Word) = <Prout '*$EENUM ' e.Word ';'>;
        }
        e.Words
      >
      <Prout>

      <Prout '/* Function starts: ' <Symb s.FunctionStarts> ' ~ ' e.FunctionStarts ' */'>
      <Map
        {
          (s.Offset e.Function) = <Prout '* ' s.Offset ': ' e.Function>;
        }
        e.FunctionTable
      >
}

DecodeStructure {
  e.Bytes
    = <ReadAsciiz e.Bytes> : (e.ModuleName) e.Bytes^
    = <ReadDWord e.Bytes> : s.BytecodeSize e.Bytes^
    = <ReadDWord e.Bytes> : s.EntryCount e.Bytes^
    = <ReadDWord e.Bytes> : s.Externs e.Bytes^
    = <ReadDWord e.Bytes> : s.Words e.Bytes^
    = <ReadDWord e.Bytes> : s.FunctionStarts e.Bytes^
    = <ReadEntries s.EntryCount e.Bytes> : e.Entries (e.Bytes^)
    = <ReadExterns s.Externs e.Bytes> : e.Externs (e.Bytes^)
    = <ReadWords s.Words e.Bytes> : e.Words (e.Bytes^)
    = <ReadEntryPoints s.FunctionStarts e.Bytes> : e.FunctionStarts (e.Bytes^)
    = (e.ModuleName)
      (s.BytecodeSize s.EntryCount s.Externs s.Words s.FunctionStarts)
      (e.Entries) (e.Externs) (e.Words) (e.FunctionStarts) e.Bytes
}

ReadAsciiz {
  e.String 0 e.Tail = (<Chr e.String>) e.Tail;
}

ReadDWord {
  s.1 s.2 s.3 s.4 e.Bytes = <MakeDWord s.1 s.2 s.3 s.4> e.Bytes;
}

MakeDWord {
  s.LastByte = s.LastByte;
  s.LastByte e.Bytes = <+ <* <MakeDWord e.Bytes> 256> s.LastByte>;
}

ReadEntries {
  0 e.Bytes = (e.Bytes);

  s.N e.Name 0 s.1 s.2 s.3 s.4 e.Bytes
    = (<Chr e.Name> <MakeDWord s.1 s.2 s.3 s.4>)
      <ReadEntries <Dec s.N> e.Bytes>;
}

ReadExterns {
  0 e.Bytes = (e.Bytes);
  s.N e.Name 0 e.Bytes = (<Chr e.Name>) <ReadExterns <Dec s.N> e.Bytes>;
}

ReadWords {
  0 e.Bytes = (e.Bytes);
  s.N e.Name 0 e.Bytes = (<Dec s.N> <Chr e.Name>) <ReadWords <Dec s.N> e.Bytes>;
}

ReadEntryPoints {
  0 e.Bytes = (e.Bytes);

  s.N s.1 s.2 s.3 s.4 e.Bytes
    = <MakeDWord s.1 s.2 s.3 s.4> <ReadEntryPoints <Dec s.N> e.Bytes>;
}

Disassemble {
  (e.Words) (e.FunctionStarts) (e.Entries) s.BytecodeSize e.Bytes
    = <DecodeCommands 0 e.Bytes> : e.Code s.BytecodeSize
    = <ResolveWords (e.Words) e.Code> : e.Code^
    = <SplitByFunctions e.Code> : e.Functions
    = <MakeFunctionTable e.Functions> : (e.FunctionTable) e.Functions
    = <CheckupFunctionStarts e.FunctionTable (e.FunctionStarts)> : Ok
    = <CheckupEntries e.FunctionTable (e.Entries)> : Ok
    = <ResolveFunctions e.Functions (e.FunctionTable)> : e.Functions^
    = (e.FunctionTable) e.Functions;
}

ResolveWords {
  (e.Words) e.Commands
    = <MapAccum
        {
          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset MatchLeftWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset MatchLeftWord e.Word);

          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset MatchRightWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset MatchRightWord e.Word);

          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset AllocWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset AllocWord e.Word);

          (e.Words^) t.Other = (e.Words) t.Other;
        }
        (e.Words) e.Commands
      >
    : (e.Words^) e.Commands^
    = e.Commands;
}

SplitByFunctions {
  t.DeclareCommand e.Code
    , <DeclareCommand t.DeclareCommand> : True
    , e.Code
    : {
        e.FuncBody t.NextDeclareCommand e.Code^
          , <DeclareCommand t.NextDeclareCommand> : True
          = (t.DeclareCommand e.FuncBody)
            <SplitByFunctions t.NextDeclareCommand e.Code>;

        e.FuncBody = (t.DeclareCommand e.FuncBody);
      };
}

DeclareCommand {
  (s.Offset EntryFuncName e.Name) = True;
  (s.Offset FuncName e.Name) = True;
  t.Other = False t.Other;
}

MakeFunctionTable {
  e.Code
    = <MapAccum
        {
          (e.Table) (e.FunctionCode)
            = e.FunctionCode
            : (s.NameOffset s.DeclareCommand e.Name)
              (s.CodeOffset e.Command)
              e.Code^
            = s.DeclareCommand
            : {
                FuncName = Local;
                EntryFuncName = Entry;
              }
            : s.Type
            = (e.Table (s.CodeOffset s.Type e.Name))
              (e.FunctionCode)
        }
        () e.Code
      >;
}

CheckupFunctionStarts {
  (s.Offset s.Type e.Name) e.Table (e.Offsets-B s.Offset e.Offsets-E)
    = <CheckupFunctionStarts e.Table (e.Offsets-B e.Offsets-E)>;

  /* пусто */ (/* пусто */) = Ok;

  e.Table (e.Offsets) = Fail;
}

CheckupEntries {
  (s.Offset Entry e.Name) e.Table (e.Entries-B (e.Name s.Offset) e.Entries-E)
    = <CheckupEntries e.Table (e.Entries-B e.Entries-E)>;

  (s.Offset Local e.Name) e.Table (e.Entries)
    = <CheckupEntries e.Table (e.Entries)>;

  /* пусто */ (/* пусто */) = Ok;

  e.Table (e.Entries) = Fail;
}

ResolveFunctions {
  e.Code (e.Table)
    = <MapAccum
        {
          (e.Table^) (e.Function)
            = <ResolveFunctions-Body e.Function (e.Table)>
            : e.Function^ (e.Table^)
            = (e.Table) (e.Function);
        }
        (e.Table) e.Code
      >
    : (e.Table^) e.Code^
    = e.Code;
}

ResolveFunctions-Body {
  e.Code-B (s.Offset MakeCall s.FuncOffset) e.Code-E
  (e.Functions-B (s.FuncOffset s.Type e.Name) e.Functions-E)
    = e.Code-B (s.Offset MakeCall e.Name)
      <ResolveFunctions-Body
        e.Code-E
        (e.Functions-B (s.FuncOffset s.Type e.Name) e.Functions-E)
      >;

  e.Code (e.Functions) = e.Code (e.Functions);
}

DecodeCommands {
  s.Offset 1 e.Name 0 e.Bytes
    = (s.Offset MakeExtern <Chr e.Name>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 2 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MakeCall <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 3 e.Bytes
    = (s.Offset AllocLeftBracket)
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 4 e.Bytes
    = (s.Offset AllocPairBrackets)
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 5 e.Bytes
    = (s.Offset AllocRightBracket)
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 6 e.Bytes
    = (s.Offset ClosedE) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 7 s.Char e.Bytes
    = (s.Offset MatchLeftChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 8 s.Char e.Bytes
    = (s.Offset MatchRightChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 10 e.Bytes
    = (s.Offset MatchEmpty) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 13 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset CopyTEVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 14 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset CopySVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 16 e.Bytes
    = (s.Offset OpenE-Prepare) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 17 e.Bytes
    = (s.Offset OpenE-Prepare-Char) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 18 e.Bytes
    = (s.Offset OpenE-Prepare-Brackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 19 e.Bytes
    = (s.Offset MatchLeftBrackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 20 e.Bytes
    = (s.Offset MatchRightBrackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 23 s.No e.Bytes
    = (s.Offset MatchLeftKnownTEVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 24 s.No e.Bytes
    = (s.Offset MatchRightKnownTEVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 25 s.No e.Bytes
    = (s.Offset MatchLeftKnownSVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 26 s.No e.Bytes
    = (s.Offset MatchRightKnownSVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 27 e.Bytes
    = (s.Offset MatchLeftTVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 28 e.Bytes
    = (s.Offset MatchRightTVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 29 s.Number e.Bytes
    = (s.Offset StartResult s.Number) <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 34 s.L1 s.L2 s.L3 s.L4 s.R1 s.R2 s.R3 s.R4 e.Bytes
    = (
        s.Offset SetB
        <MakeDWord s.L1 s.L2 s.L3 s.L4>
        <MakeDWord s.R1 s.R2 s.R3 s.R4>
      )
      <DecodeCommands <+ s.Offset 9> e.Bytes>;

  s.Offset 35 e.Bytes
    = (s.Offset OpenE-Start) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 36 s.Char e.Bytes
    = (s.Offset OpenE-Start-Char s.Char)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 37 e.Bytes
    = (s.Offset OpenE-Start-Brackets)
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 39 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset MatchLeftChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 40 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset MatchRightChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 41 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset AllocChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 43 s.Char e.Bytes
    = (s.Offset AllocChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 45 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MoveTEVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 46 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MoveSVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 47 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset OnFailGoTo <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 48 e.Bytes
    = (s.Offset MatchLeftSVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 49 e.Bytes
    = (s.Offset MatchRightSVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 50 e.Bytes
    = (s.Offset NextStep) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 51 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset StartCondition-2 <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 52 e.Bytes
    = (s.Offset StartCondition-3) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 53 e.Bytes
    = (s.Offset StartCondition-1) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 54 e.Bytes
    = (s.Offset StartBlock) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 55 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchLeftWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 56 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchRightWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 57 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchLeftNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 58 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchRightNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 59 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset AllocWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 60 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset AllocNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 100 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset BuiltinRegular <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 102 0 e.Name 0 e.Bytes
    = (s.Offset FuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 102 0 e.Name>> e.Bytes>;

  s.Offset 103 0 e.Name 0 e.Bytes
    = (s.Offset EntryFuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 103 0 e.Name>> e.Bytes>;

  s.Offset 104 0 e.Name 0 e.Bytes
    = (s.Offset ConditionFuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 103 0 e.Name>> e.Bytes>;

  s.Offset 105 s.L1 s.L2 s.L3 s.L4 s.R1 s.R2 s.R3 s.R4 e.Bytes
    = (
        s.Offset BuiltinSpecial
        <MakeDWord s.L1 s.L2 s.L3 s.L4>
        <MakeDWord s.R1 s.R2 s.R3 s.R4>
      )
      <DecodeCommands <+ s.Offset 9> e.Bytes>;

  s.Offset /* пусто */ = s.Offset;

  s.Offset e.Bytes = (s.Offset RawBytes e.Bytes);
}

Len {
  e.String = <Lenw e.String> : s.Len e.String^ = s.Len;
}

DEBUG {
  e.Bytes
    = <Prout 'all bytes\n' e.Bytes>
      <Prout <Chr e.Bytes>>
      <Prout 'all strings'>
      <AllString <Chr e.Bytes>>;
}

AllString {
  e.String '\x00' e.Tail
    = <Prout e.String>
      <Prout <Ord e.String> 0>
      <AllString e.Tail>;
  e.String = <Prout e.String> <Prout <Ord e.String>>;
}

DecompileFunction {
  (t.FuncName (s.Offset BuiltinRegular s.No)) = /* пусто */;
  (t.FuncName (s.Offset BuiltinSpecial s.No1 s.No2)) = /* пусто */;

  (t.FuncName e.Commands)
    = (t.FuncName <Decompile-Pattern-Hole 0 3 (1) (2) () e.Commands>);
}

Decompile-Pattern-Hole {
  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftWord e.Word) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L (W e.Word) s.Top) (e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightWord e.Word) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L) (s.Top (W e.Word) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftNumber s.Number) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L (N s.Number) s.Top) (e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightNumber e.Number) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L) (s.Top (N e.Number) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftChar s.Code s.Char) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L (C s.Char) s.Top) (e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightChar s.Code s.Char) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top> (e.Pattern-L) (s.Top (C s.Char) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftChars s.Len e.Chars) e.Commands
    = <+ s.Len s.Top> : s.Top^
    = <- s.Top 1> : s.L^
    = <Decompile-Pattern-Hole
        s.Level s.Top (e.Pattern-L (C e.Chars) s.L) (e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightChars s.Len e.Chars) e.Commands
    = <+ s.Len s.Top> : s.Top^
    = <- s.Top 1> : s.R^
    = <Decompile-Pattern-Hole
        s.Level s.Top (e.Pattern-L) (s.R (C <Rev e.Chars>) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftSVar) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top>
        (e.Pattern-L (s s.Top '=' s.Top) s.Top) (e.Pattern-R)
        (e.Vars (s s.Top '=' s.Top))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightSVar) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top>
        (e.Pattern-L) (s.Top (s s.Top '=' s.Top) e.Pattern-R)
        (e.Vars (s s.Top '=' s.Top))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftTVar) e.Commands
    = s.Top <+ 1 s.Top> : s.VL s.VR
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L (t s.VL s.VR '=' s.VL s.VR) s.VR) (e.Pattern-R)
        (e.Vars (t s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightTVar) e.Commands
    = s.Top <+ 1 s.Top> : s.VL s.VR
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L) (s.VL (t s.VL s.VR '=' s.VL s.VR) e.Pattern-R)
        (e.Vars (t s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)
  (s.Offset OnFailGoTo s.Jump)
  e.Commands-B (s.Jump e.Command) e.Commands-E
    = <Decompile-Pattern-Hole
        s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)
        e.Commands-B
        ('@' Restore-Hole s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars))
        (s.Jump e.Command)
        e.Commands-E
      >;

  s.Level1 s.Top1 (e.Pattern-L1) (e.Pattern-R1) (e.Vars1)
  ('@' Restore-Hole s.Level2 s.Top2 (e.Pattern-L2) (e.Pattern-R2) (e.Vars2))
  e.Commands
    = <Decompile-Pattern-Hole
        s.Level2 s.Top2 (e.Pattern-L2) (e.Pattern-R2) (e.Vars2)
        e.Commands
      >;

  s.Level1 s.Top1 (e.Pattern-L1) (e.Pattern-R1) (e.Vars1)
  ('@' Restore-NoHole s.Level2 s.Top2 (e.Pattern2) (e.Vars2))
  e.Commands
    = <Decompile-Pattern-NoHole
        s.Level2 s.Top2 (e.Pattern2) (e.Vars2) e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftKnownSVar s.VarNo) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top>
        (e.Pattern-L (s s.VarNo '=' s.Top) s.Top) (e.Pattern-R)
        (e.Vars (s s.VarNo '=' s.Top))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightKnownSVar s.VarNo) e.Commands
    = <Decompile-Pattern-Hole
        s.Level <Inc s.Top>
        (e.Pattern-L) (s.Top (s s.VarNo '=' s.Top) e.Pattern-R)
        (e.Vars (s s.VarNo '=' s.Top))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset ClosedE) e.Commands
    = s.Top <+ s.Top 1> : s.VL s.VR
    = <Decompile-Pattern-NoHole
        s.Level <+ s.Top 2>
        (e.Pattern-L (e s.VL s.VR '=' s.VL s.VR) e.Pattern-R)
        (e.Vars (e s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftKnownTEVar s.IdR) e.Commands
    = e.Vars : e.Vars-B (s.Type s.IdL s.IdR '=' s.VarNoL s.VarNoR) e.Vars-E
    = s.Top <+ s.Top 1> : s.VL s.VR
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L (s.Type s.IdL s.IdR '=' s.VL s.VR) s.VR) (e.Pattern-R)
        (e.Vars (s.Type s.IdL s.IdR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightKnownTEVar s.IdR) e.Commands
    = e.Vars : e.Vars-B (s.Type s.IdL s.IdR '=' s.VarNoL s.VarNoR) e.Vars-E
    = s.Top <+ s.Top 1> : s.VL s.VR
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L) (s.VL (s.Type s.IdL s.IdR '=' s.VL s.VR) e.Pattern-R)
        (e.Vars (s.Type s.IdL s.IdR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchLeftBrackets) e.Commands
    = s.Top <+ s.Top 1> : s.LB s.RB
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L (LB) s.LB) (s.RB (RB) (Hole s.RB s.R) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchRightBrackets) e.Commands
    = s.Top <+ s.Top 1> : s.LB s.RB
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L) (s.LB (LB) (Hole s.LB s.RB) (RB) e.Pattern-R)
        (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset SetB s.NewL s.NewR) e.Commands
    = <Decompile-Pattern-NoHole
        s.Level s.Top (e.Pattern-L (Hole s.L s.R) e.Pattern-R) (e.Vars)
        (s.Offset SetB s.NewL s.NewR) e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset MatchEmpty) e.Commands
    = <Decompile-Pattern-NoHole
        s.Level s.Top (e.Pattern-L e.Pattern-R) (e.Vars) e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset1 OpenE-Prepare) (s.Offset2 OpenE-Start) e.Commands
    = s.Top <+ s.Top 1> : s.VL s.VR
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 2>
        (e.Pattern-L (e s.VL s.VR '=' s.VL s.VR) s.VR) (e.Pattern-R)
        (e.Vars (e s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (e.Pattern-R) (e.Vars)
  (s.Offset1 OpenE-Prepare-Char) (s.Offset2 OpenE-Start-Char s.Code) e.Commands
    = s.Top <+ s.Top 1> <+ s.Top 2>: s.VL s.VR s.CharPos
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 3>
        (e.Pattern-L (e s.VL s.VR '=' s.VL s.VR) (C <Chr s.Code>) s.CharPos)
        (e.Pattern-R)
        (e.Vars (e s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
  (s.Offset1 OpenE-Prepare-Brackets) (s.Offset2 OpenE-Start-Brackets) e.Commands
    = s.Top <+ s.Top 1> <+ s.Top 2> <+ s.Top 3> : s.VL s.VR s.LB s.RB
    = <Decompile-Pattern-Hole
        s.Level <+ s.Top 4>
        (e.Pattern-L (e s.VL s.VR '=' s.VL s.VR) (LB) s.LB)
        (s.RB (RB) (Hole s.RB s.R) e.Pattern-R)
        (e.Vars (e s.VL s.VR '=' s.VL s.VR))
        e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)
  (s.Offset StartBlock) e.Commands
    = (StartBlock)
      <Decompile-Pattern-Hole
        <Inc s.Level> s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars) e.Commands
      >;

  s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)
  (s.Offset ConditionFuncName e.BlockName) e.Commands
    = <Decompile-Pattern-Hole
        s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars) e.Commands
      >;

  s.Level s.Top (s.L) (s.R) () /* нет команд */ = (EndOfFunction);

  s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)
  e.Commands
    = ('=A ' s.Level s.Top (e.Pattern-L) (e.Pattern-R) (e.Vars)) e.Commands;
}

Rev {
  s.First e.Middle s.Last = s.Last <Rev e.Middle> s.First;
  e.ZeroOrOne = e.ZeroOrOne;
}

Decompile-Pattern-NoHole {
  s.Level s.Top (e.Pattern-L (Hole s.L s.R) e.Pattern-R) (e.Vars)
  (s.Offset SetB s.L s.R) e.Commands
    = <Decompile-Pattern-Hole
        s.Level s.Top (e.Pattern-L s.L) (s.R e.Pattern-R) (e.Vars)
        e.Commands
      >;

  s.Level s.Top (e.Pattern) (e.Vars)
  (s.Offset StartResult 0) e.Commands
    = (Pattern s.Level e.Pattern)
      <Decompile-Result s.Level s.Top (e.Vars) ('$') e.Commands>;

  s.Level s.Top (e.Pattern) (e.Vars)
  (s.Offset StartCondition-1) e.Commands
    = (Pattern s.Level e.Pattern)
      (StartCondition-1)
      <Decompile-Result s.Level s.Top (e.Vars) ('$') e.Commands>;

  s.Level s.Top (e.Pattern) (e.Vars)
  (s.Offset OnFailGoTo s.Jump)
  e.Commands-B (s.Jump e.Command) e.Commands-E
    = <Decompile-Pattern-NoHole
        s.Level s.Top (e.Pattern) (e.Vars)
        e.Commands-B
        ('@' Restore-NoHole s.Level s.Top (e.Pattern) (e.Vars))
        (s.Jump e.Command)
        e.Commands-E
      >;

  s.Level1 s.Top1 (e.Pattern1) (e.Vars1)
  ('@' Restore-Hole s.Level2 s.Top2 (e.Pattern-L2) (e.Pattern-R2) (e.Vars2))
  e.Commands
    = <Decompile-Pattern-Hole
        s.Level2 s.Top2 (e.Pattern-L2) (e.Pattern-R2) (e.Vars2)
        e.Commands
      >;

  s.Level1 s.Top1 (e.Pattern1) (e.Vars1)
  ('@' Restore-NoHole s.Level2 s.Top2 (e.Pattern2) (e.Vars2))
  e.Commands
    = <Decompile-Pattern-NoHole
        s.Level2 s.Top2 (e.Pattern2) (e.Vars2) e.Commands
      >;

  s.Level s.Top (e.Pattern) (e.Vars)
  (s.Offset ConditionFuncName e.BlockName) e.Commands
    = <Decompile-Pattern-NoHole
        s.Level s.Top (e.Pattern) (e.Vars) e.Commands
      >;

  s.Level s.Top () () /* нет комманд */ = (EndOfFunction);

  s.Level s.Top (e.Pattern) (e.Vars) e.Commands
    = ('=B ' s.Level s.Top (e.Pattern) (e.Vars)) e.Commands;
}

Decompile-Result {
  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset AllocWord e.Word) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (W e.Word)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset AllocNumber s.Number) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (N s.Number)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset AllocChar s.Code s.Char) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (C s.Char)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result)
  (s.Offset AllocChars s.Count e.Chars) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (Cc e.Chars)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset AllocLeftBracket) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) ((t.MB e.Result)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) ((t.MB e.Result) e.Nested)
  (s.Offset AllocRightBracket) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result ('*' e.Nested)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset AllocPairBrackets) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result ('*')) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result ('*' e.Inner))
  (s.Offset MakeCall e.Name) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result ('!' (e.Name) e.Inner)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result ('*' e.Inner))
  (s.Offset MakeExtern e.Name) e.Commands
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result ('!' (e.Name) e.Inner)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset MoveSVar s.Copy) e.Commands
    , e.Vars : e.Vars-B (s s.Id '=' s.Copy) e.Vars-E
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (s s.Id '=' s.Copy)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset MoveTEVar s.CopyR) e.Commands
    , e.Vars
    : e.Vars-B (s.Type s.IdL s.IdR '=' s.CopyL s.CopyR) e.Vars-E
    , t e : e.B s.Type e.E
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (s.Type s.IdL s.IdR '=' s.CopyL s.CopyR))
        e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset CopySVar s.Copy) e.Commands
    , e.Vars : e.Vars-B (s s.Id '=' s.Copy) e.Vars-E
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (s s.Id '=' s.Copy)) e.Commands
      >;

  s.Level
  s.Top (e.Vars) (t.MB e.Result) (s.Offset CopyTEVar s.CopyR) e.Commands
    , e.Vars
    : e.Vars-B (s.Type s.IdL s.IdR '=' s.CopyL s.CopyR) e.Vars-E
    , t e : e.B s.Type e.E
    = <Decompile-Result
        s.Level
        s.Top (e.Vars) (t.MB e.Result (s.Type s.IdL s.IdR '=' s.CopyL s.CopyR))
        e.Commands
      >;

  s.Level
  s.Top (e.Vars) ('$' e.Result)
  (s.Offset1 StartCondition-2 s.Offset3)
  (s.Offset2 ConditionFuncName e.Name)
  (s.Offset3 StartCondition-3)
  e.Commands
    = (Result e.Result)
      (StartCondition-2 e.Name)
      <Decompile-Pattern-Hole
        s.Level <+ s.Top 3> (<+ s.Top 1>) (<+ s.Top 2>) (e.Vars) e.Commands
      >;

  s.Level
  s.Top (e.Vars) ('$' e.Result)
  (s.Offset1 NextStep) (s.Offset2 NextStep) e.Commands
    = (Result e.Result)
      (NextSentence)
      (NextSentence)
      <Decompile-Pattern-NoHole s.Level '*' () () e.Commands>;

  s.Level
  s.Top (e.Vars) ('$' e.Result) (s.Offset NextStep) e.Commands
    = (Result e.Result)
      (NextSentence)
      <Decompile-Pattern-NoHole s.Level '*' () () e.Commands>;

  s.Level s.Top (e.Vars) (t.MB e.Result) e.Commands
    = ('=C ' s.Level s.Top (e.Vars) (t.MB e.Result)) e.Commands;
}
