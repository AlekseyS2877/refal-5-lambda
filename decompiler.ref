$INCLUDE "LibraryEx";

$ENTRY Go {
  = <Main <ArgList>>;
}

Main {
  (e.ProgName) (e.Input) e._
    = <Decompile <LoadBytes e.Input>>;

  (e.ProgName) = <Prout 'Bad command line'>;
}

Decompile {
  e.Bytes
    = <DecodeStructure e.Bytes>
    : (e.ModuleName)
      (s.BytecodeSize s.EntryCount s.Externs s.Words s.FunctionStarts)
      (e.Entries) (e.Externs) (e.Words) (e.FunctionStarts) e.Bytes^
    = <Disassemble (e.Words) (e.FunctionStarts) (e.Entries) e.Bytes>
    : (e.FunctionTable) e.Code
    = <Prout '/* Module: "' e.ModuleName '" */'>
      <Prout>
      <Map
        {
          (e.Function)
            = <Map
                {
                  (s.Offset RawBytes e.Bytes^)
                    = <Lenw e.Bytes> : s.Len e.Bytes^
                    = <Prout s.Offset RawBytes (s.Len bytes)>
                      <DEBUG e.Bytes>;

                  (e.Command) = <Prout e.Command>;
                }
                e.Function
              >
              <Prout>
        }
        e.Code
      >
      <Prout>
      <Prout '/* Bytecode size: ' <Symb s.BytecodeSize> ' */'>
      <Prout>

      <Prout '/* Entries: ' <Symb s.EntryCount> ' */'>
      <Map
        {
          (e.Entry s.Offset)
            = <Prout '/* $ENTRY ' e.Entry ';\toffset ' <Symb s.Offset> ' */'>;
        }
        e.Entries
      >
      <Prout>

      <Prout '/* Externs: ' <Symb s.Externs> ' */'>
      <Map
        {
          (e.Extern) = <Prout '$EXTERN ' e.Extern ';'>;
        }
        e.Externs
      >
      <Prout>

      <Prout '/* Words: ' <Symb s.Words> ' */'>
      <Map
        {
          (e.Word) = <Prout '*$EENUM ' e.Word ';'>;
        }
        e.Words
      >
      <Prout>

      <Prout '/* Function starts: ' <Symb s.FunctionStarts> ' ~ ' e.FunctionStarts ' */'>
      <Map
        {
          (s.Offset e.Function) = <Prout '* ' s.Offset ': ' e.Function>;
        }
        e.FunctionTable
      >
}

DecodeStructure {
  e.Bytes
    = <ReadAsciiz e.Bytes> : (e.ModuleName) e.Bytes^
    = <ReadDWord e.Bytes> : s.BytecodeSize e.Bytes^
    = <ReadDWord e.Bytes> : s.EntryCount e.Bytes^
    = <ReadDWord e.Bytes> : s.Externs e.Bytes^
    = <ReadDWord e.Bytes> : s.Words e.Bytes^
    = <ReadDWord e.Bytes> : s.FunctionStarts e.Bytes^
    = <ReadEntries s.EntryCount e.Bytes> : e.Entries (e.Bytes^)
    = <ReadExterns s.Externs e.Bytes> : e.Externs (e.Bytes^)
    = <ReadWords s.Words e.Bytes> : e.Words (e.Bytes^)
    = <ReadEntryPoints s.FunctionStarts e.Bytes> : e.FunctionStarts (e.Bytes^)
    = (e.ModuleName)
      (s.BytecodeSize s.EntryCount s.Externs s.Words s.FunctionStarts)
      (e.Entries) (e.Externs) (e.Words) (e.FunctionStarts) e.Bytes
}

ReadAsciiz {
  e.String 0 e.Tail = (<Chr e.String>) e.Tail;
}

ReadDWord {
  s.1 s.2 s.3 s.4 e.Bytes = <MakeDWord s.1 s.2 s.3 s.4> e.Bytes;
}

MakeDWord {
  s.LastByte = s.LastByte;
  s.LastByte e.Bytes = <+ <* <MakeDWord e.Bytes> 256> s.LastByte>;
}

ReadEntries {
  0 e.Bytes = (e.Bytes);

  s.N e.Name 0 s.1 s.2 s.3 s.4 e.Bytes
    = (<Chr e.Name> <MakeDWord s.1 s.2 s.3 s.4>)
      <ReadEntries <Dec s.N> e.Bytes>;
}

ReadExterns {
  0 e.Bytes = (e.Bytes);
  s.N e.Name 0 e.Bytes = (<Chr e.Name>) <ReadExterns <Dec s.N> e.Bytes>;
}

ReadWords {
  0 e.Bytes = (e.Bytes);
  s.N e.Name 0 e.Bytes = (<Dec s.N> <Chr e.Name>) <ReadWords <Dec s.N> e.Bytes>;
}

ReadEntryPoints {
  0 e.Bytes = (e.Bytes);

  s.N s.1 s.2 s.3 s.4 e.Bytes
    = <MakeDWord s.1 s.2 s.3 s.4> <ReadEntryPoints <Dec s.N> e.Bytes>;
}

Disassemble {
  (e.Words) (e.FunctionStarts) (e.Entries) e.Bytes
    = <DecodeCommands 0 e.Bytes> : e.Code
    = <ResolveWords (e.Words) e.Code> : e.Code^
    = <SplitByFunctions e.Code> : e.Code^
    = <MakeFunctionTable e.Code> : (e.FunctionTable) e.Code
    = <CheckupFunctionStarts e.FunctionTable (e.FunctionStarts)> : Ok
    = <ResolveFunctions e.Code (e.FunctionTable)> : e.Code^
    = (e.FunctionTable) e.Code;
}

ResolveWords {
  (e.Words) e.Commands
    = <MapAccum
        {
          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset MatchLeftWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset MatchLeftWord e.Word);

          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset MatchRightWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset MatchRightWord e.Word);

          (e.Words-B (s.Id e.Word) e.Words-E)
          (s.Offset AllocWord s.Id)
            = (e.Words-B (s.Id e.Word) e.Words-E)
              (s.Offset AllocWord e.Word);

          (e.Words^) t.Other = (e.Words) t.Other;
        }
        (e.Words) e.Commands
      >
    : (e.Words^) e.Commands^
    = e.Commands;
}

SplitByFunctions {
  t.DeclareCommand e.Code
    , <DeclareCommand t.DeclareCommand> : True
    , e.Code
    : {
        e.FuncBody t.NextDeclareCommand e.Code^
          , <DeclareCommand t.NextDeclareCommand> : True
          = (t.DeclareCommand e.FuncBody)
            <SplitByFunctions t.NextDeclareCommand e.Code>;

        e.FuncBody = (t.DeclareCommand e.FuncBody);
      };
}

DeclareCommand {
  (s.Offset EntryFuncName e.Name) = True;
  (s.Offset FuncName e.Name) = True;
  t.Other = False t.Other;
}

MakeFunctionTable {
  e.Code
    = <MapAccum
        {
          (e.Table) (e.FunctionCode)
            = e.FunctionCode
            : (s.NameOffset s.DeclareCommand e.Name)
              (s.CodeOffset e.Command)
              e.Code^
            = (e.Table (s.CodeOffset e.Name))
              (e.FunctionCode)
        }
        () e.Code
      >;
}

CheckupFunctionStarts {
  (s.Offset e.Name) e.Table (e.Offsets-B s.Offset e.Offsets-E)
    = <CheckupFunctionStarts e.Table (e.Offsets-B e.Offsets-E)>;

  /* пусто */ (/* пусто */) = Ok;

  e.Table (e.Offsets) = Fail;
}

ResolveFunctions {
  e.Code (e.Table)
    = <MapAccum
        {
          (e.Table^) (e.Function)
            = <ResolveFunctions-Body e.Function (e.Table)>
            : e.Function^ (e.Table^)
            = (e.Table) (e.Function);
        }
        (e.Table) e.Code
      >
    : (e.Table^) e.Code^
    = e.Code;
}

ResolveFunctions-Body {
  e.Code-B (s.Offset MakeCall s.FuncOffset) e.Code-E
  (e.Functions-B (s.FuncOffset e.Name) e.Functions-E)
    = e.Code-B (s.Offset MakeCall e.Name)
      <ResolveFunctions-Body
        e.Code-E
        (e.Functions-B (s.FuncOffset e.Name) e.Functions-E)
      >;

  e.Code (e.Functions) = e.Code (e.Functions);
}

DecodeCommands {
  s.Offset 1 e.Name 0 e.Bytes
    = (s.Offset MakeExtern <Chr e.Name>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 2 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MakeCall <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 3 e.Bytes
    = (s.Offset "Alloc '('")
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 4 e.Bytes
    = (s.Offset "Alloc '()'")
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 5 e.Bytes
    = (s.Offset "Alloc ')'")
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 6 e.Bytes
    = (s.Offset ClosedE) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 7 s.Char e.Bytes
    = (s.Offset MatchLeftChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 8 s.Char e.Bytes
    = (s.Offset MatchRightChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 10 e.Bytes
    = (s.Offset MatchEmpty) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 13 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset CopyTEVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 14 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset CopySVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 16 e.Bytes
    = (s.Offset OpenE-Prepare) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 17 e.Bytes
    = (s.Offset OpenE-Prepare-Char) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 18 e.Bytes
    = (s.Offset OpenE-Prepare-Brackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 19 e.Bytes
    = (s.Offset MatchLeftBrackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 20 e.Bytes
    = (s.Offset MatchRightBrackets) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 23 s.No e.Bytes
    = (s.Offset MatchLeftKnownTEVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 24 s.No e.Bytes
    = (s.Offset MatchRightKnownTEVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 25 s.No e.Bytes
    = (s.Offset MatchLeftKnownSVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 26 s.No e.Bytes
    = (s.Offset MatchRightKnownSVar s.No)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 27 e.Bytes
    = (s.Offset MatchLeftTVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 28 e.Bytes
    = (s.Offset MatchRightTVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 29 s.Number e.Bytes
    = (s.Offset StartResult s.Number) <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 34 s.L1 s.L2 s.L3 s.L4 s.R1 s.R2 s.R3 s.R4 e.Bytes
    = (
        s.Offset SetB
        <MakeDWord s.L1 s.L2 s.L3 s.L4>
        <MakeDWord s.R1 s.R2 s.R3 s.R4>
      )
      <DecodeCommands <+ s.Offset 9> e.Bytes>;

  s.Offset 35 e.Bytes
    = (s.Offset OpenE-Start) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 36 s.Char e.Bytes
    = (s.Offset OpenE-Start-Char s.Char)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 37 e.Bytes
    = (s.Offset OpenE-Start-Brackets)
      <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 39 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset MatchLeftChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 40 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset MatchRightChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 41 s.Count e.Bytes
    = <First s.Count e.Bytes> : (e.Chars) e.Bytes^
    = (s.Offset AllocChars s.Count <Chr e.Chars>)
      <DecodeCommands <+ s.Offset <+ 2 s.Count>> e.Bytes>;

  s.Offset 43 s.Char e.Bytes
    = (s.Offset AllocChar s.Char <Chr s.Char>)
      <DecodeCommands <+ s.Offset 2> e.Bytes>;

  s.Offset 45 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MoveTEVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 46 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MoveSVar <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 47 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset OnFailGoTo <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 48 e.Bytes
    = (s.Offset MatchLeftSVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 49 e.Bytes
    = (s.Offset MatchRightSVar) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 50 e.Bytes
    = (s.Offset NextStep) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 51 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset StartCondition-2 <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 52 e.Bytes
    = (s.Offset StartCondition-3) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 53 e.Bytes
    = (s.Offset StartCondition-1) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 54 e.Bytes
    = (s.Offset StartBlock) <DecodeCommands <Inc s.Offset> e.Bytes>;

  s.Offset 55 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchLeftWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 56 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchRightWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 57 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchLeftNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 58 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset MatchRightNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 59 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset AllocWord <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 60 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset AllocNumber <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 100 s.1 s.2 s.3 s.4 e.Bytes
    = (s.Offset BuiltinRegular <MakeDWord s.1 s.2 s.3 s.4>)
      <DecodeCommands <+ s.Offset 5> e.Bytes>;

  s.Offset 102 0 e.Name 0 e.Bytes
    = (s.Offset FuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 102 0 e.Name>> e.Bytes>;

  s.Offset 103 0 e.Name 0 e.Bytes
    = (s.Offset EntryFuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 103 0 e.Name>> e.Bytes>;

  s.Offset 104 0 e.Name 0 e.Bytes
    = (s.Offset ConditionFuncName <Chr e.Name>)
      <DecodeCommands <+ s.Offset <Len 103 0 e.Name>> e.Bytes>;

  s.Offset 105 s.L1 s.L2 s.L3 s.L4 s.R1 s.R2 s.R3 s.R4 e.Bytes
    = (
        s.Offset BuiltinSpecial
        <MakeDWord s.L1 s.L2 s.L3 s.L4>
        <MakeDWord s.R1 s.R2 s.R3 s.R4>
      )
      <DecodeCommands <+ s.Offset 9> e.Bytes>;


  s.Offset e.Bytes = (s.Offset RawBytes e.Bytes);
}

Len {
  e.String = <Lenw e.String> : s.Len e.String^ = s.Len;
}

DEBUG {
  e.Bytes
    = <Prout 'all bytes\n' e.Bytes>
      <Prout <Chr e.Bytes>>
      <Prout 'all strings'>
      <AllString <Chr e.Bytes>>;
}

AllString {
  e.String '\x00' e.Tail
    = <Prout e.String>
      <Prout <Ord e.String> 0>
      <AllString e.Tail>;
  e.String = <Prout e.String> <Prout <Ord e.String>>;
}
