//FROM LibraryEx
$EXTERN Map, Fetch;


/**
  <CreateHardPattern e.Pattern>
    == e.OptPatternHS

  e.OptPatternHS ::= t.OptPatternHS-Term

  t.OptPatternHS-Term ::=
      (#Atom s.Type e.Value)
    | (#Brackets e.OptPatternHS)
    | (#ADT-Brackets (e.Name) e.OptPatternHS)
    | (s.VarMode (e.Index) ((e.OptPatternHS-Nested)))

  s.VarMode ::= #E | #T | #S
  e.OptPatternHS-Nested ::= t.OptPatternHS-Nested-Term

  t.OptPatternHS-Nested-Term ::=
      (#Atom s.Type e.Value)
    | (#Brackets e.OptPatternHS-Nested)
    | (#ADT-Brackets (e.Name) e.OptPatternHS-Nested)
    | (s.VarMode (e.Index) e.VarSubstHS-Nested)

  e.VarSubstHS-Nested ::= empty | ()
*/
$ENTRY CreateHardPattern {
  e.pattern = <CreateHardPattern-Aux <PreparePatternHardSent e.pattern>>;
}

PreparePatternHardSent {
  e.Pattern =
    <Map
      {
        (#TkChar s.char) = (#Atom #TkChar s.char);
        (#TkNumber s.value) = (#Atom #TkNumber s.value);
        (#TkName e.name) = (#Atom #TkName e.name);
        (#TkIdentifier e.ident) = (#Atom #TkIdentifier e.ident);
        (#TkVariable s.Mode e.Index) =
          (<Fetch s.Mode { 'e' = #E; 't' = #T; 's' = #S; }> (e.Index) ());

        (#Brackets e.inBrackets)
          = (#Brackets <PreparePatternHardSent e.inBrackets>);
        (#ADT-Brackets (e.Name) e.inBrackets)
          = (#ADT-Brackets (e.Name) <PreparePatternHardSent e.inBrackets>);
      }
      e.Pattern
    >;
}

CreateHardPattern-Aux {
  // args   t.Token1 ... t.TokenN - Prepared pattern
  // return t.Term1 ... t.TermN - Hard Sentence pattern

  /* предлажение имеет вид [P'] */
  (#ADT-Brackets (e.Name) e.body)
    = (#ADT-Brackets (e.Name) <CreateHardPattern-Aux e.body>);

  /* отщипнуть терм слева или справа */
  (#ADT-Brackets (e.Name) e.body) e.smth
    = (#ADT-Brackets (e.Name) <CreateHardPattern-Aux e.body>)
      <CreateHardPattern-Aux e.smth>;

  /* предлажение имеет вид [Name P'] */
  e.smth (#ADT-Brackets (e.Name) e.body)
    = <CreateHardPattern-Aux e.smth>
      (#ADT-Brackets (e.Name) <CreateHardPattern-Aux e.body>);

  /* предлажение имеет вид (P') */
  (#Brackets e.body)
    = (#Brackets <CreateHardPattern-Aux e.body>);

  /* отщипнуть терм слева или справа */
  (#Brackets e.body) e.smth
    = (#Brackets <CreateHardPattern-Aux e.body>)
      <CreateHardPattern-Aux e.smth>;

  e.smth (#Brackets e.body)
    = <CreateHardPattern-Aux e.smth>
      (#Brackets <CreateHardPattern-Aux e.body>);

  /* переменные */
  (#S (e.name) (e.pattern)) e.smth
    = ( #S ('idx') (( (#S (e.name)) )) )
      <CreateHardPattern-Aux e.smth>;

  e.smth (#S (e.name) (e.pattern))
    = <CreateHardPattern-Aux e.smth>
      ( #S ('idx') (( (#S (e.name)) )) );

  (#T (e.name) (e.pattern)) e.smth
    = ( #T ('idx') (( (#T (e.name)) )) )
      <CreateHardPattern-Aux e.smth>;

  e.smth (#T (e.name) (e.pattern))
    = <CreateHardPattern-Aux e.smth>
      ( #T ('idx') (( (#T (e.name)) )) );

  /* атом */
  (#Atom e.attr) e.smth
    = (#Atom e.attr)
      <CreateHardPattern-Aux e.smth>;

  e.smth (#Atom e.attr)
    = <CreateHardPattern-Aux e.smth>
      (#Atom e.attr);

  /* пусто */ = ;

  /* все остальное */
  e.smth = ( #E ('idx') ((e.smth)) );
}
