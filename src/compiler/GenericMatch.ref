/*
  <GenericMatch (e.Pattern) (e.LPattern)>
    == Clear (e.Val ':' t.Var)*
    == Contracted ((Ct t.Var ':' e.Val)* (As (e.Val ':' t.Var)*))*
    == Failure
    == Undefined

  e.Pattern, e.LPattern ::= t.PatternTerm*
  t.PatternTerm — см. interfaces.md + переменные в e.Pattern могут иметь тип
    'k' — неразменные переменные.

  e.Val ::= t.PatternTerm*
  t.Var ::= (s.VarType e.Index)
  s.VarType ::= 's' | 't' | 'e'
*/
$ENTRY GenericMatch {
  (e.Pattern) (e.LPattern)
    = <GenericMatch-Aux (e.Pattern) (e.LPattern) (/* Substitutions */) >;
}

/*
  Сопоставляем P:H
    P - выражение общего вида
    H - жесткий образец, который имеет вид:
      "t.1 … t.N e.X t.M … t.K″" или "t.1 … t.N"
*/
GenericMatch-Aux {
  (t.Pt e.Pe) (t.Ht e.He) (e.Substs)
    , <IsTerm t.Ht> : True /* H начинается на t */
    , <IsTerm t.Pt> : True /* P начинается на t */
    = <TermMatch t.Pt t.Ht>
    : {
        Clear e.TermSubsts
          = <GenericMatch-Aux (e.Pe) (e.He) (e.Substs e.TermSubsts)>;

        Failure = Failure;
        Undefined = Undefined;
        /* Contracted пока не поддерживаем */
      };

  (e.Pe t.Pt) (e.He t.Ht) (e.Substs)
    , <IsTerm t.Ht> : True /* H заканчивается на t */
    , <IsTerm t.Pt> : True /* P заканчивается на t */
    = <TermMatch t.Pt t.Ht>
    : {
        Clear e.TermSubsts
          = <GenericMatch-Aux (e.Pe) (e.He) (e.Substs e.TermSubsts)>;

        Failure = Failure;
        Undefined = Undefined;
        /* Contracted пока не поддерживаем */
      };

  () () (e.Substs) /* H пустое выражение, тогда P пустое выражение */
    = Clear e.Substs;

  (e.P) ((TkVariable 'e' e.Index)) (e.Substs) /* H состоит из e-переменной */
    = Clear e.Substs (e.P ':' ('e' e.Index));

  e.Else = Undefined;
}

/* Сопоставление термов T:H */
TermMatch {
  (e.T)(TkVariable 't' e.HIndex) /* H является t-переменной */
    = Clear ((e.T)':'('t' e.HIndex));

  (e.T)(TkVariable 's' e.HIndex) /* H является s-переменной */
    = <IsSVarSubset (e.T)>
    : {
        True = Clear ((e.T)':'('s' e.HIndex));
        False = Failure;
      };

  (e.T)(t.HToken e.HBody) /* H является символом */
    , <IsSymbol (t.HToken e.HBody)> : True
    , <IsEqual (e.T)(t.HToken e.HBody)>
    : {
        True = (Clear (e.T)':'(e.HBody));
        False = Failure;
      };

    (e.T)(Brackets e.HBody) /* H является (H′) */
    , e.T
    : {
        Brackets e.TBody   /* тогда T является (T′) */
          = <GenericMatch (e.TBody)(e.HBody)>;

        e.Else = Failure;
      };


  (e.T)(ADT-Brackets t.HName e.HBody) /* H является [H′] */
    , e.T
    : {
        ADT-Brackets t.TName e.TBody  /* тогда T является [T′] */
          , <IsEqual t.TName t.HName> /* И метки H и T совпадают */
          : {
              True = <GenericMatch (e.TBody)(e.HBody)>;
              False = Failure;
            };

        e.Else = Failure;
      };

  /* Далее аналогично рекурсивно */
}

IsSVarSubset {
  t.Symbol, <IsSymbol t.Symbol> : True = True;
  /*(TkChar s.Char) = True;*/
  (TkVariable 's' e.Tindex) = True;
  (Closure e.Body) = True;

  (Brackets e.Expression) = False;
  (ADT-Brackets (e.ADTName) e.Expression) = False;

  /* Нужно ли здесь оставлять этот вариант? */
  t.OtherTerm = False;
}

IsTerm {
  (TkVariable 'e' e.Index) = False;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;

  /* s-, t-переменная, скобки обоих видов, символ */
  t.OtherTerm = True;
}

IsSymbol {
  /* идентификатор, имя функции, число или литера */
  (TkIdentifier e.Name) = True;
  (TkName t.SrcPos e.Name) = True;
  (TkNumber s.Number) = True;
  (TkChar s.HChar) = True;

  t.OtherTerm = False;
}

IsEqual {
  (e.Var)(e.Var) = True;

  e.Else = False;
}