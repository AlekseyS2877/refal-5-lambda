/*
  <GenericMatch (e.Pattern) (e.LPattern)>
    == Clear (e.Val ':' t.Var)*
    == Contracted ((Ct t.Var ':' e.Val)* (As (e.Val ':' t.Var)*))*
    == Failure
    == Undefined

  e.Pattern, e.LPattern ::= t.PatternTerm*
  t.PatternTerm — см. interfaces.md + переменные в e.Pattern могут иметь тип
    'k' — неразменные переменные.

  e.Val ::= t.PatternTerm*
  t.Var ::= (s.VarType e.Index)
  s.VarType ::= 's' | 't' | 'e'
*/
$ENTRY GenericMatch {
  (e.Pattern) (e.LPattern)
    = <GenericMatch-Aux (e.Pattern) (e.LPattern) (/* Substitutions */) >;
}

/*
  Сопоставляем P:H
    P - выражение общего вида
    H - жесткий образец, который имеет вид:
      "t.1 … t.N e.X t.M … t.K″" или "t.1 … t.N"
*/
GenericMatch-Aux {
  (t.Pt e.Pe) (t.Ht e.He) (e.Substs)
    , <IsTerm t.Ht> : True /* H начинается на t */
    , <IsTerm t.Pt> : True /* P начинается на t */
    = <TermMatch t.Pt t.Ht>
    : {
        Clear e.TermSubsts
          = <GenericMatch-Aux (e.Pe) (e.He) (e.Substs e.TermSubsts)>;

        Failure = Failure;
        Undefined = Undefined;
        /* Contracted пока не поддерживаем */
      };

  (e.Pe t.Pt) (e.He t.Ht) (e.Substs)
    , <IsTerm t.Ht> : True /* H заканчивается на t */
    , <IsTerm t.Pt> : True /* P заканчивается на t */
    = <TermMatch t.Pt t.Ht>
    : {
        Clear e.TermSubsts
          = <GenericMatch-Aux (e.Pe) (e.He) (e.Substs e.TermSubsts)>;

        Failure = Failure;
        Undefined = Undefined;
        /* Contracted пока не поддерживаем */
      };

  () () (e.Substs) /* H пустое выражение, тогда P пустое выражение */
    = Clear e.Substs;

  (e.P) (t.H) (e.Substs)
    , <IsEVar t.H> : True /* H состоит из e-переменной */
    = <TermMatch (e.P) t.H>
    : {
        Clear e.TermSubsts
        /* можно сразу "= Clear e.Substs (e.TermSubsts);" */
          = <GenericMatch-Aux () () (e.Substs e.TermSubsts)>;

        Failure = Failure;
        Undefined = Undefined;
        /* Contracted пока не поддерживаем */
      };

  e.Else = Undefined;
}

/* Сопоставление термов T : H */
TermMatch {
  (e.T)(TkVariable 'e' e.HIndex) /* H является e-переменной */
    = Clear (e.T':'('e' e.HIndex));

  (e.T)(TkVariable 't' e.HIndex) /* H является t-переменной */
    = Clear ((e.T)':'('t' e.HIndex));

  (e.T)(TkVariable 's' e.HIndex) /* H является s-переменной */
    = <IsSVarSubset (e.T)>
    : {
        True = Clear ((e.T)':'('s' e.HIndex));
        False = Failure;
      };

  (e.T)(t.HToken e.HBody) /* H является символом */
    , <IsSymbol (t.HToken e.HBody)> : True
    , <IsEqual (e.T)(t.HToken e.HBody)>
    : {
        True = (Clear (e.T)':'(e.HBody));
        False = Failure;
      };

  (t.TToken e.TBody)(t.HToken e.HBody)
    , <IsBrackets (t.HToken e.HBody)> : True /* H является (H′) */
    , <IsBrackets (t.TToken e.TBody)> /* T является (T′) */
    : {
        True = <GenericMatch (e.TBody)(e.HBody)>;
        False = Failure;
      };

  (t.TToken e.TBody)(t.HToken e.HBody)
    , <IsADT-Brackets (t.HToken e.HBody)> : True /* H является [H′] */
    , <IsADT-Brackets (t.TToken e.TBody)> /* T является [T′] */
    : {
        True = <GenericMatch (e.TBody)(e.HBody)>;
        False = Failure;
      };

  /* Далее аналогично рекурсивно */
}

IsSVarSubset {
  t.Symbol, <IsSymbol t.Symbol> : True = True;
  /*(TkChar s.Char) = True;*/
  (TkVariable 's' e.Tindex) = True;
  (Closure e.Body) = True;

  (Brackets e.Expression) = False;
  (ADT-Brackets (e.ADTName) e.Expression) = False;

  /* Нужно ли здесь оставлять этот вариант? */
  t.OtherTerm = False;
}

IsTerm {
  (TkVariable 'e' e.Index) = False;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;

  /* s-, t-переменная, скобки обоих видов, символ */
  t.OtherTerm = True;
}

IsEVar {
  (TkVariable 'e' e.Index) = True;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;

  t.OtherTerm = False;
}

IsSymbol {
  /* идентификатор, имя функции, число или литера */
  (TkIdentifier e.Name) = True;
  (TkName t.SrcPos e.Name) = True;
  (TkNumber s.Number) = True;
  (TkChar s.HChar) = True;

  t.OtherTerm = False;
}

IsADT-Brackets {
  (ADT-Brackets e.Expression) = True;

  t.OtherTerm = False;
}

IsBrackets {
  (Brackets e.Expression) = True;

  t.OtherTerm = False;
}
IsEqual {
  (e.Var)(e.Var) = True;

  e.Else = False;
}