//FROM LibraryEx
$EXTERN Fetch, Map, Inc, Sort, Pipe, Max, Dec;

//FROM Library
$EXTERN Add;

//FROM HighLevelRASL-GenSubst-Save 
$EXTERN GenSubst-Save-Cond;

//FROM HighLevelRASL-Common
$EXTERN Inc2,FoldOpenELoops, PutVariableDebugTable, CollectStrings, 
IncVarOffset, PrintVar;

//FROM HighLevelRASL-GenResult-Simple
$EXTERN DoGenResult, MakeVariableCommentTable;

$ENTRY SentenceTail{

  (s.StartOffsetCond)
  (e.ResultSentence)
  (e.PatternVars)(e.MarkedPatternCur)
  (#Condition (e.CondName) (e.CondResult) (e.CondPattern)) e.ConditionsTail
    
    = <GenResult-Condition
        <Inc2 s.StartOffsetCond> (e.PatternVars) 
	(#TkOpenCallCond s.StartOffsetCond)
        (#TkName e.CondName) e.CondResult
        (#TkCloseCallCond <Inc s.StartOffsetCond>)
      >
      : s.EndOffsetCond-Res e.CondResultCommands        

    = <GenInitSubst-Cond s.StartOffsetCond (e.CondName) e.CondPattern>
      : s.OffsetCond 
        e.CondSubstitutes (e.FirstCondPatternCommands)

    = <GenSubst-Save-Cond
        s.OffsetCond e.CondSubstitutes (e.PatternVars)
        (e.FirstCondPatternCommands)
      >
      : s.StartOffsetCondNext 
        (e.PatternVarsAfterCond) (e.MarkedPatternCond)
        e.CondPatternCommands
    
    = e.MarkedPatternCur (e.MarkedPatternCond) : e.MarkedPatternCur^ 
                 
    = <SentenceTail
       (s.StartOffsetCondNext)
       (e.ResultSentence)
       (e.PatternVarsAfterCond) (e.MarkedPatternCur)
       e.ConditionsTail
      > 
      : s.NestedStackTop e.NestedSentence
       
     = <Max s.EndOffsetCond-Res s.NestedStackTop> : s.StackTop
     
     = (#CmdSentence <FoldOpenELoops
                        e.CondPatternCommands
                        <PutVariableDebugTable e.PatternVars>
                        e.NestedSentence
                     >
        )
        (#CmdSpliceToFreeList-Range
          s.StartOffsetCond
          <Inc s.StartOffsetCond>
        )
        (#CmdFail)
      : e.CmdSentenceCommands
      
    = e.CondResultCommands
      (#CmdPushState)
      (#CmdNextStep)
      (#CmdProfileFunction)
      e.CmdSentenceCommands
      : e.SentenceCommands
      
    = s.StackTop e.SentenceCommands;
           
  (s.ContextOffset)
  (s.FnGenResult e.Result)
  (e.PatternVars)  
  (e.MarkedPatternCur)
  /*пусто*/
  
    = e.MarkedPatternCur : (e.MarkedPattern t.CloseCall)  e.MarkedPatternCur^ 

    = <Map
        {
          (e.MarkedPattern^) = e.MarkedPattern;
        }
        e.MarkedPatternCur
      >
      : e.MarkedPatternCur^
    
    = <s.FnGenResult
        s.ContextOffset (e.PatternVars) 
        (e.MarkedPattern e.MarkedPatternCur t.CloseCall) 
        e.Result
      >
      : s.ContextCount e.ResultCommands

    = s.ContextCount e.ResultCommands;       
  
}

$ENTRY GenInitSubst-Cond {
  s.ContextTop (e.FuncName) e.Pattern
    = s.ContextTop : s.0
    = <Add s.ContextTop 1> : s.1
    = <Add s.ContextTop 2> : s.2
    = <Add s.ContextTop 4> : s.4
    = <Add s.ContextTop 5> : s.5
    = s.5
      (#Junk (#TkOpenCall s.0) (#TkName e.FuncName s.4))
      (#E s.2 e.Pattern)
      (#Junk (#TkCloseCall s.1))
      (
        (#CmdCallSave #AlgLeft s.0 s.2)
      );
}

/**
  <GenResult-Condition
    s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.Result
  >
    == s.ContextOffset^ e.ResultCommands

  e.MarkedPattern — не используется
*/

$ENTRY GenResult-Condition {
    s.ContextOffset (e.PatternVars) e.CondResult
      = <GenResult s.ContextOffset (e.PatternVars) e.CondResult>
      : { 
           s.ContextOffset^ (e.CommonVars) e.ResultCommands
             = s.ContextOffset
               <MakeVariableCommentTable e.CommonVars>
               (#CmdResetAllocator)
               (#CmdSetRes 1)
               e.ResultCommands
               (#CmdUseRes);
        };
}

GenResult{
  s.ContextOffset (e.PatternVars) e.CondResult
    = <Map
        {
          (s.Mode (e.Index) e.Offsets) = (s.Mode (e.Index) (e.Offsets));
        }
        e.PatternVars
      >
    : e.PatternVars^
    
    = <DoGenResult
        (e.PatternVars)
        (/* alloc commands */) (/* other commands */)
        s.ContextOffset // счётчик новых элементов
        <CollectStrings e.CondResult>
      >;
}

DoGenResult {
 (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkOpenCallCond s.Offset) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Offset #ElOpenCall))
      ((#CmdInsertElem s.Offset) e.Commands)
      s.Counter e.Result
    >;
    
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseCallCond s.Offset) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Offset #ElCloseCall))
      (
        (#CmdPushStack s.Offset)
        (#CmdPushStack <Dec s.Offset>)
        (#CmdInsertElem s.Offset)
        e.Commands
      )
      s.Counter e.Result
    >;

  // Создаём литералы
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter (#TkChar s.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElChar s.Value))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter (#TkName e.Name) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElName e.Name))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkNumber s.Number) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElNumber s.Number))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkIdentifier e.Name) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElIdent e.Name))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkString e.Chars) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElString e.Chars))
      ((#CmdInsertRange s.Counter) e.Commands)
      <Add s.Counter 2> e.Result
    >;

  /*
    Обработка открывающих скобок всех трёх типов осуществляется похоже.
  */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#Brackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElOpenBracket))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.InBrackets (#TkCloseBracket s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#CallBrackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElOpenCall))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.InBrackets (#TkCloseCall s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#ADT-Brackets (e.Name) e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElOpenADT))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter>
      (#TkName e.Name) e.InBrackets (#TkCloseADT s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#ClosureBrackets e.InBrackets) e.Result
    = <DoGenResult
        (e.Vars)
        (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElClosureHead))
        ((#CmdInsertElem s.Counter) e.Commands)
        <Inc s.Counter> e.InBrackets (#TkUnwrappedClosure s.Counter) e.Result
      >;

  /*
    Закрывающие скобки надо обрабатывать особым образом.
    Круглые скобки и АТД -- слинковать, угловые -- добавить в стек.
  */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseBracket s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElCloseBracket))
      (
        (#CmdLinkBrackets s.OpenCounter s.Counter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseADT s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElCloseADT))
      (
        (#CmdLinkBrackets s.OpenCounter s.Counter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseCall s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdCreateElem #Allocate s.Counter #ElCloseCall))
      (
        (#CmdPushStack s.Counter)
        (#CmdPushStack s.OpenCounter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkUnwrappedClosure s.HeadCounter) e.Result
    = <DoGenResult
        (e.Vars)
        (
          e.AllocCommands
          (#CmdCreateElem #Allocate s.Counter #ElUnwrappedClosure s.HeadCounter)
        )
        (
          (#CmdInsertElem s.Counter)
          e.Commands
          (#CmdWrapClosure s.Counter)
        )
        <Inc s.Counter> e.Result
      >;

  // Обработка переменных
  (
    e.Vars-B
    (s.Mode (e.Index) (e.ResultVars) s.NextPatternVar e.PatternVars)
    e.Vars-E
  )
  (e.AllocCommands) (e.Commands)
  s.Counter (#TkVariable s.Mode e.Index) e.Result =
    <DoGenResult
      (
        e.Vars-B
        (s.Mode (e.Index) (e.ResultVars s.NextPatternVar) e.PatternVars)
        e.Vars-E
      )
      (e.AllocCommands)
      ((#CmdInsertVar s.Mode s.NextPatternVar) e.Commands)
      s.Counter e.Result
    >;

  (e.Vars-B (s.Mode (e.Index) (e.ResultVars s.Sample)) e.Vars-E)
  (e.AllocCommands) (e.Commands)
  s.Counter (#TkVariable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B (s.Mode (e.Index) (e.ResultVars s.Sample s.Counter)) e.Vars-E)
      (e.AllocCommands (#CmdCopyVar s.Mode s.Counter s.Sample))
      ((#CmdInsertVar s.Mode s.Counter) e.Commands)
      <IncVarOffset s.Counter s.Mode> e.Result
    >;

  // Завершение просмотра
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter =
    s.Counter (e.Vars) e.AllocCommands e.Commands;
}



