//FROM LibraryEx
$EXTERN Fetch, Seq, Map, MapReduce, Inc, DelAccumulator, Reduce, Sort;

//FROM Desugaring-UnCondition
$EXTERN Pass-UnCondition;


$ENTRY Desugar {
  s.MarkupContext e.AST =
    <Fetch
      e.AST
      <Seq
        Pass-RemovePos
        Pass-EnumerateVariables
        Pass-NameNestedFuncs
        Pass-RemoveBlocksAndAssigns
        (Pass-FlatNestedFuncs s.MarkupContext)
        (Pass-UnCondition s.MarkupContext)
        Pass-CreatePredeclarations
      >
    >;
}

Pass-RemovePos {
  e.AST =
    <Map
      {
        (#Function t.SrcPos s.ScopeClass (e.Name) e.Body) =
          (#Function s.ScopeClass (e.Name) <RemovePos-Body e.Body>);

        (#Ident t.SrcPos e.Name) =
          (#Ident e.Name);

        (#NativeBlock t.SrcPos e.Code) =
          (#NativeBlock t.SrcPos e.Code);

        (s.EnumSwapDeclaration t.SrcPos s.ScopeClass e.Name) =
          (s.EnumSwapDeclaration s.ScopeClass e.Name);
      }
      e.AST
    >;
}

RemovePos-Body {
  #Sentences e.Sentences =
    #Sentences
    <Map
      {
        ((e.Pattern) e.Assigns (e.Result) (e.Blocks)) =
          (
            (<RemovePos-Expr e.Pattern>)
            <Map
              {
                (s.ChainType (e.Result^) (e.Blocks^) (e.Pattern^))
                  = <AssignOrCondition s.ChainType> : /* пусто */
                  = (s.ChainType
                      (<RemovePos-Expr e.Result>)
                      (<RemovePos-Blocks e.Blocks>)
                      (<RemovePos-Expr e.Pattern>)
                    );
              }
              e.Assigns
            >
            (<RemovePos-Expr e.Result>)
            (<RemovePos-Blocks e.Blocks>)
          );
      }
      e.Sentences
    >;

  #NativeBody t.SrcPos e.Code = #NativeBody t.SrcPos e.Code;
}

AssignOrCondition {
  #Assign = ; #Condition = ;
}

RemovePos-Blocks {
  e.Blocks
    = <Map
        {
          (e.Body) = (<RemovePos-Body e.Body>);
        }
        e.Blocks
      >;
}

RemovePos-Expr {
  e.Expr =
    <Map
      {
        (#TkVariable t.SrcPos s.Mode e.Index) =
          (#TkVariable s.Mode e.Index);

        (#TkNewVariable t.SrcPos s.Mode e.Index) =
          (#TkNewVariable s.Mode e.Index);

        (#TkName t.SrcPos e.Name) = (#TkName e.Name);

        (#Brackets e.InBrackets) =
          (#Brackets <RemovePos-Expr e.InBrackets>);

        (#ADT-Brackets t.SrcPos (e.Name) e.InBrackets) =
          (#ADT-Brackets (e.Name) <RemovePos-Expr e.InBrackets>);

        (#CallBrackets e.InBrackets) =
          (#CallBrackets <RemovePos-Expr e.InBrackets>);

        (#Closure e.Sentences) =
          (#Closure <RemovePos-Body e.Sentences>);

        t.OtherTerm = t.OtherTerm;
      }
      e.Expr
    >;
}

Pass-EnumerateVariables {
  e.AST =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Body) =
          (#Function
            s.ScopeClass (e.Name)
            <EnumerateVars-Body 1 (/* переменные */) e.Body>
          );

        t.OtherProgramElement = t.OtherProgramElement;
      }
      e.AST
    >;
}

EnumerateVars-Body {
  s.Depth (e.ScopeVars) #Sentences e.Sentences =
    #Sentences
    <Map
      {
        ((e.Pattern) e.Assigns (e.Result) (e.Blocks))
          = <EnumerateVars-Expr s.Depth (e.ScopeVars) e.Pattern>
          : (e.ScopeVars^) e.Pattern^
          = <EnumerateVars-Assignments () s.Depth (e.ScopeVars) e.Assigns>
          : (e.ScopeVars^) s.Depth^ e.Assigns^
          = <EnumerateVars-Expr s.Depth (e.ScopeVars) e.Result>
          : (e.ScopeVars^) e.Result^
          = <EnumerateVars-Blocks <Inc s.Depth> (e.ScopeVars) e.Blocks>
          : e.Blocks^
          = ((e.Pattern) e.Assigns (e.Result) (e.Blocks));
      }
      e.Sentences
    >;

  s.Depth (e.ScopeVars) #NativeBody t.SrcPos e.Code =
    #NativeBody t.SrcPos e.Code;
}

EnumerateVars-Blocks {
  s.Depth (e.ScopeVars) e.Blocks
    = <Map
        {
          (e.Body) = (<EnumerateVars-Body s.Depth (e.ScopeVars) e.Body>);
        }
        e.Blocks
      >;
}

EnumerateVars-Assignments {
  (e.RAssignments) s.Depth (e.ScopeVars) /* пусто */ =
     (e.ScopeVars) s.Depth e.RAssignments;

  (e.RAssignments) s.Depth (e.ScopeVars)
  (s.ChainType (e.Result) (e.Blocks) (e.Pattern)) e.Assignments
    = <AssignOrCondition s.ChainType> : /* пусто */
    = <EnumerateVars-Expr s.Depth (e.ScopeVars) e.Result>
    : (e.ScopeVars^) e.Result^
    = <Inc s.Depth> : s.Depth^
    = <EnumerateVars-Blocks s.Depth (e.ScopeVars) e.Blocks> : e.Blocks^
    = <EnumerateVars-Expr s.Depth (e.ScopeVars) e.Pattern>
    : (e.ScopeVars^) e.Pattern^
    = <EnumerateVars-Assignments
        (e.RAssignments (s.ChainType (e.Result) (e.Blocks) (e.Pattern)))
        s.Depth (e.ScopeVars) e.Assignments
      >;
}

EnumerateVars-Expr {
  s.Depth (e.OriginScopeVars) e.Expr =
    <MapReduce
      {
        (e.ScopeVars-B (s.Mode e.Index s.Depth^) e.ScopeVars-E)
        (#TkVariable s.Mode e.Index) =
          (e.ScopeVars-B (s.Mode e.Index s.Depth) e.ScopeVars-E)
          (#TkVariable s.Mode e.Index s.Depth);

        (e.ScopeVars) (#TkVariable s.Mode e.Index) =
          ((s.Mode e.Index s.Depth) e.ScopeVars)
          (#TkVariable s.Mode e.Index s.Depth);

        (e.ScopeVars) (#TkNewVariable s.Mode e.Index) =
          ((s.Mode e.Index s.Depth) e.ScopeVars)
          (#TkVariable s.Mode e.Index s.Depth);

        (e.ScopeVars) (#Brackets e.InBrackets) =
          <Fetch
            <EnumerateVars-Expr s.Depth (e.ScopeVars) e.InBrackets>
            {
              (e.ScopeVars^) e.InBrackets^ =
                (e.ScopeVars) (#Brackets e.InBrackets);
            }
          >;

        (e.ScopeVars) (#ADT-Brackets (e.Name) e.InBrackets) =
          <Fetch
            <EnumerateVars-Expr s.Depth (e.ScopeVars) e.InBrackets>
            {
              (e.ScopeVars^) e.InBrackets^ =
                (e.ScopeVars) (#ADT-Brackets (e.Name) e.InBrackets);
            }
          >;

        (e.ScopeVars) (#CallBrackets e.InBrackets) =
          <Fetch
            <EnumerateVars-Expr s.Depth (e.ScopeVars) e.InBrackets>
            {
              (e.ScopeVars^) e.InBrackets^ =
                (e.ScopeVars) (#CallBrackets e.InBrackets);
            }
          >;

        (e.ScopeVars) (#Closure e.Sentences) =
          <Fetch
            <EnumerateVars-Body <Inc s.Depth> (e.ScopeVars) e.Sentences>
            {
              e.Sentences^ =
                (e.ScopeVars) (#Closure e.Sentences);
            }
          >;

        (e.ScopeVars) t.OtherTerm = (e.ScopeVars) t.OtherTerm;
      }
      (e.OriginScopeVars) e.Expr
    >;
}

Pass-NameNestedFuncs {
  e.AST =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Body) =
          (#Function
            s.ScopeClass (e.Name)
            <NameNestedBody (e.Name #SUF) e.Body>
          );

        t.OtherProgramElement = t.OtherProgramElement;
      }
      e.AST
    >;
}

NameNestedBody {
  (e.MainName) #Sentences ((e.Pattern) e.Assigns (e.Result) (e.Blocks))
     = #Sentences
        (
          (e.Pattern)
          <NameNestedAssigns (e.MainName) e.Assigns>
          (<NameNestedResult (e.MainName) e.Result>)
          (<NameNestedBlocks (e.MainName) e.Blocks>)
        );

  (e.MainName) #Sentences e.Sentences
    = #Sentences
      <DelAccumulator
        <MapReduce
          {
            s.SentenceNumber ((e.Pattern) e.Assigns (e.Result) (e.Blocks^))
              = e.MainName '$' s.SentenceNumber: e.MainName^
              = <Inc s.SentenceNumber>
                (
                  (e.Pattern)
                  <NameNestedAssigns (e.MainName) e.Assigns>
                  (<NameNestedResult (e.MainName) e.Result>)
                  (<NameNestedBlocks (e.MainName) e.Blocks>)
                );
          }
          1 e.Sentences
        >
      >;

  (e.MainName) #NativeBody t.SrcPos e.Code
    = #NativeBody t.SrcPos e.Code;
}

NameNestedBlocks {
  (e.MainName) e.Blocks
    = <MapReduce
        {
          s.BlockNumber (e.Body)
            = e.MainName ':' s.BlockNumber : e.MainName^
            = <Inc s.BlockNumber>
              ((e.MainName) <NameNestedBody (e.MainName) e.Body>);
        }
        1 e.Blocks
      >
    : s.BlockNumber e.Blocks^
    = e.Blocks;
}

NameNestedAssigns {
  (e.MainName) e.Assigns
    = <DelAccumulator
        <MapReduce
          {
            s.AssignId (s.ChainType (e.Result) (e.Blocks) (e.Pattern))
              = <ChainTypeMarker s.ChainType> : s.Marker
              = e.MainName s.Marker s.AssignId : e.MainName^
              = <Inc s.AssignId>
                (s.ChainType
                  (e.MainName)
                  (<NameNestedResult (e.MainName) e.Result>)
                  (<NameNestedBlocks (e.MainName) e.Blocks>)
                  (e.Pattern)
                );
          }
          1
          e.Assigns
        >
      >;
}

ChainTypeMarker {
  #Assign = '=';
  #Condition = '?';
}

NameNestedResult {
  (e.MainName) e.Result =
    <DelAccumulator <NameNestedResultRec 1 (e.MainName) e.Result>>;
}

NameNestedResultRec {
  s.StartNumber (e.MainName) e.Result =
    <MapReduce
      {
        s.NextNumber (#Brackets e.InBrackets) =
          <Fetch
            <NameNestedResultRec s.NextNumber (e.MainName) e.InBrackets>
            {
              s.NextNumber^ e.InBrackets^ =
                s.NextNumber (#Brackets e.InBrackets);
            }
          >;

        s.NextNumber (#ADT-Brackets (e.Name) e.InBrackets) =
          <Fetch
            <NameNestedResultRec s.NextNumber (e.MainName) e.InBrackets>
            {
              s.NextNumber^ e.InBrackets^ =
                s.NextNumber (#ADT-Brackets (e.Name) e.InBrackets);
            }
          >;

        s.NextNumber (#CallBrackets e.InBrackets) =
          <Fetch
            <NameNestedResultRec s.NextNumber (e.MainName) e.InBrackets>
            {
              s.NextNumber^ e.InBrackets^ =
                s.NextNumber (#CallBrackets e.InBrackets);
            }
          >;

        s.NextNumber (#Closure e.Sentences) =
          <Inc s.NextNumber>
          (#Closure
            (e.MainName '\\' s.NextNumber)
            <NameNestedBody (e.MainName '\\' s.NextNumber) e.Sentences>
          );

        s.NextNumber t.OtherTerm = s.NextNumber t.OtherTerm;
      }
      s.StartNumber e.Result
    >;
}

Pass-RemoveBlocksAndAssigns {
  e.AST =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Body) =
          (#Function
            s.ScopeClass (e.Name)
            <RemoveAssigns-Sentences e.Body>
          );

        t.OtherProgramElement = t.OtherProgramElement;
      }
      e.AST
    >;
}

RemoveAssigns-Sentences {
  #Sentences e.Sentences =
    #Sentences
    <Map
      RemoveAssigns-Sentence
      e.Sentences
    >;

  #NativeBody t.SrcPos e.Code =
    #NativeBody t.SrcPos e.Code;
}

RemoveAssigns-Sentence {
  /*
    Присваивание есть синтаксический сахар — выражается через блок:
    … = R : { B }… P …  --->  … = R : { B }… : { P … }
  */
  (
    (e.Pattern) e.Conditions
    (#Assign (e.AssignName) (e.AssignResult) (e.Blocks) (e.AssignPattern))
    e.SentenceTail
  )
    = <RemoveAssigns-Sentence
        (
          (e.Pattern) e.Conditions
          (e.AssignResult)
          (
            e.Blocks
            ((e.AssignName) #Sentences ((e.AssignPattern) e.SentenceTail))
          )
        )
      >;

  /*
    Блоки, в свою очередь — тоже синтаксический сахар, являются замыканиями,
    которые по очереди применяются к результату
  */
  ((e.Pattern) e.Conditions (e.Result) (e.Blocks))
    = <RemoveAssigns-Conditions e.Conditions> : e.Conditions^
    = <RemoveAssigns-WindBlocks (e.Result) e.Blocks> : (e.Result^)
    = <RemoveAssigns-Result e.Result> : e.Result^
    = ((e.Pattern) e.Conditions (e.Result));
}

RemoveAssigns-Conditions {
  e.Conditions
    = <Map
        {
          (#Condition
            (e.ConditionName) (e.Result) (e.Blocks) (e.Pattern)
          )
            = <RemoveAssigns-WindBlocks (e.Result) e.Blocks> : (e.Result^)
            = (#Condition
                (e.ConditionName)
                (<RemoveAssigns-Result e.Result>)
                (e.Pattern)
              );
        }
        e.Conditions
      >;
}

RemoveAssigns-WindBlocks {
  (e.Result) e.Blocks
    = <Reduce
        {
          (e.Result^) ((e.BlockName) e.Body)
            = ((#CallBrackets (#Closure (e.BlockName) e.Body) e.Result));
        }
        (e.Result) e.Blocks
      >;
}

RemoveAssigns-Result {
  e.Expr
    = <Map
        {
          (#Brackets e.InBrackets)
            = (#Brackets <RemoveAssigns-Result e.InBrackets>);

          (#ADT-Brackets (e.Name) e.InBrackets)
            = (#ADT-Brackets (e.Name) <RemoveAssigns-Result e.InBrackets>);

          (#CallBrackets e.InBrackets)
            = (#CallBrackets <RemoveAssigns-Result e.InBrackets>);

          (#Closure (e.ClosureName) e.Sentences)
            = (#Closure (e.ClosureName) <RemoveAssigns-Sentences e.Sentences>);

          t.OtherTerm = t.OtherTerm;
        }
        e.Expr
    >;
}

Pass-FlatNestedFuncs {
  s.MarkupContext e.AST =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Body)
          = <ExtractNested s.MarkupContext e.Body>
          : (e.NestedFuncs) e.Body^
          = e.NestedFuncs
            (#Function s.ScopeClass (e.Name) e.Body);

        t.OtherProgramElement = t.OtherProgramElement;
      }
      e.AST
    >;
}

ExtractNested {
  s.MarkupContext e.Sentences
    = <ExtractNestedRec
        s.MarkupContext (/* внешних переменных нет */) e.Sentences
      >
    : (/* заимстовованных переменных нет */) (e.NestedFuncs) e.Sentences^
    = (e.NestedFuncs) e.Sentences;
}

ExtractNestedRec {
  s.MarkupContext (e.ScopeVars) #Sentences e.Sentences
    = <MapReduce
        (ExtractNested-Sentence s.MarkupContext e.ScopeVars)
        ((/* вложенные функции */) (/* заимствованные переменные */))
        e.Sentences
      >
    : ((e.NestedFuncs) (e.BorrowedVars)) e.Sentences^
    = (e.BorrowedVars) (e.NestedFuncs) #Sentences e.Sentences;

  s.MarkupContext (e.ScopeVars) #NativeBody t.SrcPos e.Code =
    (/* нет заимстовованных переменных */) (/* нет вложенных функций */)
    #NativeBody t.SrcPos e.Code;
}

ExtractNested-Sentence {
  s.MarkupContext e.ScopeVars ((e.NestedFuncs) (e.BorrowedVars))
  ((e.Pattern) e.Conditions (e.Result))

    = <ExtractNested-Pattern (e.ScopeVars) (e.BorrowedVars) e.Pattern>
    : (e.BorrowedVars^) e.LocalVars

    = <ExtractNested-Conditions
        s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars)
        e.Conditions
      >
    : (e.ConditionsNestedFuncs) (e.BorrowedVars^) (e.LocalVars^)
      e.Conditions^

    = <ExtractNested-Result
        s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) e.Result
      >
    : (e.ResultNestedFuncs) (e.BorrowedVars^) e.Result^

    = (
        (e.NestedFuncs e.ConditionsNestedFuncs e.ResultNestedFuncs)
        (e.BorrowedVars)
      )
      ((e.Pattern) e.Conditions (e.Result));
}

ExtractNested-Conditions {
  s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars)
  (#Condition (e.ConditionName) (e.Result) (e.Pattern)) e.Conditions

    = <ExtractNested-Result
        s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) e.Result
      >
    : (e.ResultNestedFuncs) (e.BorrowedVars^) e.Result^

    = <ExtractNested-Pattern (e.ScopeVars) (e.BorrowedVars) e.Pattern>
    : (e.BorrowedVars^) e.PatternLocalVars

    = <Uniq e.LocalVars e.PatternLocalVars> : e.LocalVars^

    = <ExtractNested-Conditions
        s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars)
        e.Conditions
      >
    : (e.ConditionsNestedFuncs) (e.BorrowedVars^) (e.LocalVars^)
      e.Conditions^

    = (e.ResultNestedFuncs e.ConditionsNestedFuncs) (e.BorrowedVars)
      (e.LocalVars)
      (#Condition (e.ConditionName) (e.Result) (e.Pattern)) e.Conditions;

  s.MarkupContext (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) /* пусто */
    = (/* нет вложенных функций */) (e.BorrowedVars) (e.LocalVars) /* пусто */;
}

ExtractNested-Pattern {
  (e.ScopeVars) (e.BorrowedVars) e.Pattern =
    <MapReduce
      (UpdateBorrowedVars e.ScopeVars)
      (e.BorrowedVars)
      <Uniq
        <ExtractAllVars e.Pattern>
      >
    >;
}

ExtractAllVars {
  (#TkVariable s.Mode e.Index) e.Tail =
    (s.Mode e.Index) <ExtractAllVars e.Tail>;

  (#Brackets e.Inner) e.Tail = <ExtractAllVars e.Inner e.Tail>;
  (#ADT-Brackets e.Inner) e.Tail = <ExtractAllVars e.Inner e.Tail>;

  t.OtherTerm e.Tail = <ExtractAllVars e.Tail>;

  /* пусто */ = /* пусто */;
}

Uniq {
  e.Uniqs t.Repeated e.NotScanned-M t.Repeated e.NotScanned-E =
    e.Uniqs <Uniq e.NotScanned-M t.Repeated e.NotScanned-E>;

  e.Uniqs = e.Uniqs;
}

UpdateBorrowedVars {
  e.ScopeVars
  (e.BorrowedVars-B (s.Mode e.Index) e.BorrowedVars-E)
  (s.Mode e.Index) =
    (e.BorrowedVars-B (s.Mode e.Index) e.BorrowedVars-E);

  e.ScopeVars-B (s.Mode e.Index) e.ScopeVars-E
  (e.BorrowedVars) (s.Mode e.Index) =
    (e.BorrowedVars (s.Mode e.Index));

  e.ScopeVars
  (e.BorrowedVars) (s.Mode e.Index) =
    (e.BorrowedVars) (s.Mode e.Index);
}

ExtractNested-Result {
  s.MarkupContext
  (e.OriginBorrowedVars) (e.ScopeVars) (e.LocalVars) e.OriginResult
    = <MapReduce
        (ExtractNested-Result-Term s.MarkupContext (e.ScopeVars) (e.LocalVars))
        ((/* nested funcs */) (e.OriginBorrowedVars)) e.OriginResult
      >
    : ((e.NestedFuncs) (e.BorrowedVars)) e.Result
    = (e.NestedFuncs) (e.BorrowedVars) e.Result;
}

ExtractNested-Result-Term {
  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars)) (#TkVariable s.Mode e.Index) =
    (
      (e.NestedFuncs)
      <CheckBorrowed (e.ScopeVars) (e.BorrowedVars) (s.Mode e.Index)>
    )
    (#TkVariable s.Mode e.Index);

  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars)) (#Brackets e.InBrackets)
    = <ExtractNested-Result
        s.MarkupContext
        (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) e.InBrackets
      >
    : (e.InBracketsNestedFuncs) (e.BorrowedVars^) e.InBrackets^
    = ((e.NestedFuncs e.InBracketsNestedFuncs) (e.BorrowedVars))
      (#Brackets e.InBrackets);

  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars))
  (#ADT-Brackets (e.Name) e.InBrackets)
    = <ExtractNested-Result
        s.MarkupContext
        (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) e.InBrackets
      >
    : (e.InBracketsNestedFuncs) (e.BorrowedVars^) e.InBrackets^
    = ((e.NestedFuncs e.InBracketsNestedFuncs) (e.BorrowedVars))
      (#ADT-Brackets (e.Name) e.InBrackets);

  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars))
  (#CallBrackets e.InBrackets)
    = <ExtractNested-Result
        s.MarkupContext
        (e.BorrowedVars) (e.ScopeVars) (e.LocalVars) e.InBrackets
      >
    : (e.InBracketsNestedFuncs) (e.BorrowedVars^) e.InBrackets^
    = ((e.NestedFuncs e.InBracketsNestedFuncs) (e.BorrowedVars))
      (#CallBrackets e.InBrackets);

  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars))
  (#Closure (e.ClosureName) e.Body)
     = <ExtractNestedRec s.MarkupContext (e.ScopeVars e.LocalVars) e.Body>
     : (e.NestedBorrowedVars) (e.NestedNestedFuncs) e.Body^
     = <Fetch
        (e.NestedBorrowedVars) e.Body
        {
          // Случай функции без контекста, нативной функции в том числе
          (/* нет захваченных переменных */) e.Body^
            = (#Function #GN-Local (e.ClosureName) e.Body)
              (e.BorrowedVars)
              (#TkName e.ClosureName);

          // Случай функции с контекстом
          (e.NestedBorrowedVars) #Sentences e.Sentences
            = <CreateContext s.MarkupContext e.NestedBorrowedVars> : e.Context
            = (#Function
                #GN-Local (e.ClosureName)
                #Sentences
                <Map
                  {
                    ((e.Pattern) e.Conditions (e.Result))
                      = ((e.Context e.Pattern) e.Conditions (e.Result));
                  }
                  e.Sentences
                >
              )
              <Reduce
                (CheckBorrowed (e.ScopeVars))
                (e.BorrowedVars) e.NestedBorrowedVars
              >
              (#ClosureBrackets (#TkName e.ClosureName) e.Context);
        }
      >
    : t.Function (e.BorrowedVars^) t.ClosureTerm
    = ((e.NestedFuncs e.NestedNestedFuncs t.Function) (e.BorrowedVars))
      t.ClosureTerm;

  s.MarkupContext (e.ScopeVars) (e.LocalVars)
  ((e.NestedFuncs) (e.BorrowedVars)) t.OtherTerm =
    ((e.NestedFuncs) (e.BorrowedVars)) t.OtherTerm;
}

CheckBorrowed {
  (e.ScopeVars) (e.BorrowedVars-B (s.Mode e.Index) e.BorrowedVars-E)
  (s.Mode e.Index) =
    (e.BorrowedVars-B (s.Mode e.Index) e.BorrowedVars-E);

  (e.ScopeVars-B (s.Mode e.Index) e.ScopeVars-E) (e.BorrowedVars)
  (s.Mode e.Index) =
    (e.BorrowedVars (s.Mode e.Index));

  (e.ScopeVars) (e.BorrowedVars) (s.Mode e.Index) =
    (e.BorrowedVars);
}

CreateContext {
  #MarkupContext e.Context =
    <Map
      {
        ('e' e.Index) =
          (#TkIdentifier #VAR 'e' e.Index)
          (#Brackets (#TkVariable 'e' e.Index));

        (s.Mode e.Index) =
          (#TkIdentifier #VAR s.Mode e.Index)
          (#TkVariable s.Mode e.Index);
      }
      e.Context
    >;

  #NoMarkupContext e.Context =
    <Map
      {
        ('e' e.Index) = (#Brackets (#TkVariable 'e' e.Index));
        (s.Mode e.Index) = (#TkVariable s.Mode e.Index);
      }
      e.Context
    >;
}

Pass-CreatePredeclarations {
  e.AST =
    /*
      Функция принимает абстрактное синтаксическое дерево
      и формирует новое с устранением избыточных элементов
      и созданием необходимых.
    */
    <Fetch
      e.AST
      <Seq
        RemoveRedudandElements
        FoldEnums
        (MapReduce
          {
            (e.Idents)
            (#Function s.ScopeClass (e.Name) e.Body) =
              <Fetch
                <ExtractIdents e.Body>
                {
                  (e.FuncIdents) e.Body^ =
                    (e.Idents e.FuncIdents)
                    (#Function s.ScopeClass (e.Name) e.Body);
                }
              >;

            (e.Idents) (#Swap s.ScopeClass e.Name) =
              (e.Idents) (#Swap s.ScopeClass e.Name);

            (e.Idents) (#Enum s.ScopeClass e.Name) =
              (e.Idents) (#Enum s.ScopeClass e.Name);

            (e.Idents) (#Declaration s.ScopeClass e.Name) =
              (e.Idents) (#Declaration s.ScopeClass e.Name);

            (e.Idents) (#Ident e.Name) =
              (e.Idents (#Ident e.Name))
              /* пусто */;

            (e.Idents) (#NativeBlock t.SrcPos e.Code) =
              (e.Idents) (#NativeBlock t.SrcPos e.Code);
          }
          (/* идентификаторы */)
        )
        {
          (e.Idents) e.Functions =
            <UniqSorted <Sort e.Idents>>
            e.Functions;
        }
      >
    >;
}

RemoveRedudandElements {
  e.AST =
    <Fetch
      e.AST
      <Seq
        /*
          Подчищаем $EXTERN’ы и $IDENT’ы только при отсутствии нативных вставок
        */
        {
          e.AST-B (#NativeBlock t.SrcPos e.Code) e.AST-E =
            SelectiveSaver-Save
            e.AST-B (#NativeBlock t.SrcPos e.Code) e.AST-E;

          e.AST-B
          (#Function s.ScopeClass (e.Name) #NativeBody e.Code)
          e.AST-E =
            SelectiveSaver-Save
            e.AST-B
            (#Function s.ScopeClass (e.Name) #NativeBody e.Code)
            e.AST-E;

          e.AST^ = SelectiveSaver-Skip e.AST;
        }
        {
          s.FnSelectiveSaver e.AST^ =
            <Map
              {
                (#Ident e.Name) = <s.FnSelectiveSaver #Ident e.Name>;

                (#Declaration s.ScopeClass e.Name)
                  = <s.FnSelectiveSaver #Declaration s.ScopeClass e.Name>;

                t.OtherItem = t.OtherItem;
              }
              e.AST
            >;
        }
      >
    >;
}

FoldEnums {
  e.AST =
    <Map
      {
        (#Function s.ScopeClass (e.Name) #Sentences /* пусто */) =
          (#Enum s.ScopeClass e.Name);

        t.Other = t.Other;
      }
      e.AST
    >;
}

ExtractIdents {
  #Sentences e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        (MapReduce
          {
            (e.Idents) ((e.Pattern) (e.Result)) =
              <Fetch
                (<ExtractIdent-Expr e.Pattern>)
                (<ExtractIdent-Expr e.Result>)
                {
                  ((e.PatternIdents) e.Pattern^) ((e.ResultIdents) e.Result^) =
                    (e.Idents e.PatternIdents e.ResultIdents)
                    ((e.Pattern) (e.Result));
                }
              >;
          }
          (/* idents */)
        )
        {
          (e.Idents) e.Sentences =
            (e.Idents) #Sentences e.Sentences;
        }
      >
    >;

  #NativeBody t.SrcPos e.Code =
    (/* нет идентификаторов */) #NativeBody t.SrcPos e.Code;
}

ExtractIdent-Expr {
  e.Expr =
    <MapReduce
      {
        (e.Idents) (#TkIdentifier e.Name) =
          (e.Idents (#Ident e.Name)) (#TkIdentifier e.Name);

        (e.Idents) (#Brackets e.SubExpr) =
          <Fetch
            <ExtractIdent-Expr e.SubExpr>
            {
              (e.SubIdents) e.SubExpr^ =
                (e.Idents e.SubIdents) (#Brackets e.SubExpr);
            }
          >;

        (e.Idents) (#ADT-Brackets (e.Name) e.SubExpr) =
          <Fetch
            <ExtractIdent-Expr e.SubExpr>
            {
              (e.SubIdents) e.SubExpr^ =
                (e.Idents e.SubIdents) (#ADT-Brackets (e.Name) e.SubExpr);
            }
          >;

        (e.Idents) (#CallBrackets e.SubExpr) =
          <Fetch
            <ExtractIdent-Expr e.SubExpr>
            {
              (e.SubIdents) e.SubExpr^ =
                (e.Idents e.SubIdents) (#CallBrackets e.SubExpr);
            }
          >;

        (e.Idents) t.OtherTerm = (e.Idents) t.OtherTerm;
      }
      (/* idents */)
      e.Expr
    >;
}

UniqSorted {
  e.Uniqs t.Repeated t.Repeated e.NotScanned =
    e.Uniqs <UniqSorted t.Repeated e.NotScanned>;

  e.Uniqs = e.Uniqs;
}

SelectiveSaver-Save {
  #Ident e.Name = (#Ident e.Name);
  #Declaration s.ScopeClass e.Name = (#Declaration s.ScopeClass e.Name);
}

SelectiveSaver-Skip {
  #Ident e.Name = /* skip */;
  #Declaration s.ScopeClass e.Name = /* skip */;
}
