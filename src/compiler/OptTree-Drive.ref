$INCLUDE "LibraryEx";


*FROM Desugaring-UnCondition
$EXTERN ExtractVariables;

*FROM GenericMatch
$EXTERN Solve;

/**
  <OptTree-Drive-ExtractOptInfo s.OptDrive e.AST>
    == (e.DriveInfo) e.AST

  s.OptDrive ::= OptDrive | OptInline | NoOpt
  e.DriveInfo ::= (e.DriveFuncNames) e.DriveInfo-Specific
  e.DriveFuncNames ::= (e.FuncName)*
*/
$ENTRY OptTree-Drive-ExtractOptInfo {
  s.OptDrive e.AST
    = <GetDrivenFunctions e.AST>
    : ((e.Names) e.Info) e.AST^
    = s.OptDrive
    : {
        NoOpt = ((/* нет имён */) /* нет инфы */) e.AST;

        s.OptDrive^ = ((e.Names) e.Info) e.AST;
      }
}

/**
  <OptTree-Drive s.OptDrive (e.DriveInfo) e.AST> == (e.DriveInfo^) e.AST^
*/
$ENTRY OptTree-Drive {
  NoOpt (e.DriveInfo) e.AST = (e.DriveInfo) e.AST ;
  s.Opt (e.DriveInfo) e.AST
    = <DriveInlineOptimizerTick (e.DriveInfo) e.AST s.Opt>;
}

/**
  <OptTree-Drive-Finalize s.OptDrive (e.DriveInfo) e.AST> == e.AST^
*/
$ENTRY OptTree-Drive-Finalize {
  s.OptDrive ((e.Names) e.Info) e.AST = e.AST;
}

/* Функция генерирует имена остаточных прогоняемых функций */

GenRemainderFuncNames {
    (e.Name) (e.Sentences) =
      <MapAccum
       {
          ((e.NewName SUF e.Suffix) (e.Names) s.N) t.A =
            ((e.Name) (e.Names (e.Name '*' s.N)) <Add s.N 1>);

          ((e.NewName) (e.Names) s.N) t.A =
            ((e.Name)(e.Names (e.Name SUF '*' s.N)) <Add s.N 1>);
       }
       ((e.Name) () 1)
       e.Sentences
      > : ((e.Name^) (e.Names) t.N)
       = e.Names
}

GetDrivenFunctions {
  e.AST

    /* Выносим все Drive и Inline из дерева */
    = <MapAccum
        {
          (e.Optimizable) (Drive e.Name) = (e.Optimizable (Drive e.Name));
          (e.Optimizable) (Inline e.Name) = (e.Optimizable (Inline e.Name));
          (e.Optimizable) t.Other = (e.Optimizable) t.Other;
        }
        () e.AST
      >
    : (e.OptNames) e.AST^

    /*
      Выделяем тела оптимизируемых функций,
      копировать несколько имён в e.OptimizableNames не страшно

      Используем MapAccum не смотря на то, что достаточно Map:
      избегаем копирования дерева
    */
    = <MapAccum
        {
          ((e.OptFunctions) (e.RemNames))
          (Function s.ScopeClass (e.Name) e.Body)
            , e.OptNames : e.B (s.Label e.Name) e.E
            , e.Body : Sentences e.Sentences
            = ((e.OptFunctions (s.Label s.ScopeClass (e.Name) { = e.Body}))
              (e.RemNames <GenRemainderFuncNames (e.Name) (e.Sentences)>))
              (Function s.ScopeClass (e.Name) e.Body);

          (e.OptInfo) t.Other
            = (e.OptInfo) t.Other;
        }
        (() ()) e.AST
      >
    : ((e.OptFunctions) (e.RemNames)) e.AST^

    = ((<Map { (s.Label e.Name ) = (e.Name) } e.OptNames> e.RemNames)
       e.OptFunctions)
       e.AST;
}

OptSwitch {
  OptDrive = &DriveSentence;
  OptInline = &InlineSentence
}

/* Осуществляет прогонку или оптимизацию в зависимости от ключа */

DriveInlineOptimizerTick {
  ((e.OptNames) e.OptFunctions) e.AST s.Opt
    = <OptSwitch s.Opt> : s.OptF
    = ((e.OptNames) e.OptFunctions)
      <Map
        {
          (Function s.ScopeClass (e.Name) e.Body)
            = <OptimizeF
                (Function s.ScopeClass (e.Name) e.Body)
                ((e.OptNames) e.OptFunctions)
                s.OptF
              >;

          e.Other = e.Other
        }
        e.AST
      >: e.AST^
    = <DistinctFuncs e.AST>
}

DistinctFuncs {
  e.B
  (Function s.ScopeClass (e.Name) e.Body1)
  e.M
  (Function s.ScopeClass (e.Name) e.Body2)
  e.E
  = <DistinctFuncs
      e.B (Function s.ScopeClass (e.Name) e.Body1) e.M e.E
    >;

  e.Other = e.Other
}

IsPassiveCall {
  e.Expr
    = <Reduce
        {
           True t.Term = <IsPassiveCall-Aux t.Term>;
           False t.Term = False;
        }
        True
        e.Expr
      >

}

IsPassiveCall-Aux {
  (Brackets e.Expr) = <IsPassiveCall e.Expr>;
  (ADT-Brackets e.Expr) = <IsPassiveCall e.Expr>;

  (CallBrackets e.Expr) = False;
  (ColdCallBrackets e.Expr) = False;

  t.Other = True;
}

IsLexpr {
  e.Expr
    , <IsLexpr-Aux e.Expr>
    : {
        e.Res-B OpenE e.Res-E = False;
        e.Res-B (s.Mode e.Index) e.Res-M (s.Mode e.Index) e.Res-E = False;
        e.Other = True;
      }
}

/*
  <IsLexpr-Aux e.Expr> == t.IsLexpr-Aux-Item*

  t.IsLexpr-Aux-Item ::= OpenE | ('e' e.Index) | ('t' e.Index)
*/
IsLexpr-Aux {
  e.Expr-B (TkVariable 'e' e.Index1) e.Expr-M (TkVariable 'e' e.Index2) e.Expr-E
    = OpenE;

  e.Expr
    = <Map
        {
          (TkVariable 'e' e.Index) = ('e' e.Index);
          (TkVariable 't' e.Index) = ('t' e.Index);

          (Brackets e.InBrackets) = <IsLexpr-Aux e.InBrackets>;
          (ADT-Brackets (e.Name) e.InBrackets) = <IsLexpr-Aux e.InBrackets>;

          t.Other = /* пропускаем */;
        }
        e.Expr
      >;
}

/*
  Осуществляет попытку прогонки или встраивания в функции
  <OptimizeF t.Function (t.DriveInfo) s.OptSentence> == t.Function*

  Возвращает модифицированную функцию
  и порожденные из прогонки или встраивания
*/

OptimizeF {
  (Function s.ScopeClass (e.Name) Sentences e.Sentences)
  ((e.OptNames) e.OptFunctions) s.OptSentence
    = <Reduce
        {
          ((e.SntAcc) (e.FunAcc)) t.Sentence
            = <s.OptSentence
                t.Sentence
                ((e.OptNames) e.OptFunctions)
              >
            : (e.NewFunctions) e.NewSentences
            = ((e.SntAcc e.NewSentences) (e.FunAcc e.NewFunctions));
        }
        ((/*sentences*/) (/*functions*/))
        e.Sentences
      > : ((e.Sentences^) (e.Functions))
    = (Function s.ScopeClass (e.Name) Sentences e.Sentences) e.Functions;

  e.Other = e.Other;
}

/*
   Осуществляет попытку встраивания отдельного предложения
   <InlineSentence t.Sentence (t.InlineInfo)>
   == (t.Func?) t.Sentence*
*/

InlineSentence {
  ((e.Left) (e.Right)) t.InlineInfo
     , <FindInlineCall t.InlineInfo e.Right> : t.Res e.Expr
     , <OneOf t.Res None>: False
     = <InlineSentence-Aux ((e.Left) (e.Right)) t.Res e.Expr t.InlineInfo>;

  t.Sentence ((e.OptNames) e.Left) = () t.Sentence
}

/* Осуществляет попытку прогонки отдельного предложения вида pattern = expr
   <DriveSentence t.Sentence (t.DriveInfo)>
    == (t.Func?) t.Sentence*
*/

DriveSentence {
  ((e.Left) (e.Right)) t.DriveInfo
     , <FindDriveCall t.DriveInfo e.Right> : t.Res e.Expr
     , <OneOf t.Res None>: False
     = <DriveSentence-Aux ((e.Left) (e.Right)) t.Res e.Expr t.DriveInfo>;

  ((e.Left) (e.Right)) t.InlineInfo
     , <FindInlineCall t.InlineInfo e.Right> : t.Res e.Expr
     , <OneOf t.Res None>: False
     = <InlineSentence-Aux ((e.Left) (e.Right)) t.Res e.Expr t.InlineInfo>;

  t.Sentence ((e.OptNames) e.Left) = () t.Sentence
}

/*
  <InlineSentence-Aux ((e.Left) (e.Right)) t.Call e.Expr t.InlineInfo>
    = (t.Func?) t.Sentence
*/

InlineSentence-Aux {
  /* Встраивание */
  ((e.Left) (e.Right)) t.Res e.Expr t.DriveInfo
    = <OptSentence-Aux Inline ((e.Left) (e.Right)) t.Res e.Expr t.DriveInfo>;
}

/*
  <DriveSentence-Aux ((e.Left) (e.Right)) t.Call e.Expr t.DriveInfo>
    = (t.Func?) t.Sentence*
*/

DriveSentence-Aux {
  /* Прогонка */
  ((e.Left) (e.Right)) t.Res e.Expr t.DriveInfo
    = <OptSentence-Aux Drive ((e.Left) (e.Right)) t.Res e.Expr t.DriveInfo>;
}

OptSentence-Aux {
  s.Mode
  ((e.Left) (e.Right))
  (CallBrackets (Symbol Name e.Name) e.Args) e.Expr
  t.DriveInfo

    /* Поиск информации для прогонки */
    , <FindOptInfo s.Mode t.DriveInfo e.Name>
    : Success (s.Mode s.ScopeClass (e.Name) Sentences ((e.LS) (e.RS)) e.Rest)

    /* Попытка оптимизации, только если вызов пассивный */
    , <IsPassiveCall e.Args> : True
    = <Solve
        (<ExtractVariables ((e.Left e.Right) ())>)
        ((e.Args) ':' (e.LS))
      >
    : e.Solution
    = <OptSentence-MakeSubstitutions
        (e.RS) s.Mode (e.Left) s.ScopeClass (e.Name) (e.Rest) (e.Args)
        e.Solution
      >
    : e.SolutionPacks
    = <MapAccum
        {
          (e.NewFunctions) ((e.RS^) e.Solutions^ (e.NewFunction))
            = (e.NewFunctions e.NewFunction)
              <ApplySolutions ((e.Left) (e.Expr)) (e.RS) e.Solutions>;
        }
        (/* new functions */)
        e.SolutionPacks
      >;

  s.Mode
  ((e.Left) (e.Right)) e.Other = () ((e.Left) (e.Right))
}

OptSentence-MakeSubstitutions {
  /*
    В случае решения без сужений просто применяем замены
  */
  (e.RS) s.Mode (e.Left) s.ScopeClass (e.Name) (e.Rest) (e.Args)
  Success (() (e.Assigns))
    = ((e.RS) (() (e.Assigns)) (/* нет новых функций */));

  /*
     В случае "грязного" решения добавляем вызов остаточной
     прогоняемой функции (Только при L-выражении)
  */
  (e.RS) s.Mode (e.Left) s.ScopeClass (e.Name) (e.Rest) (e.Args)
  Success e.M
    , s.Mode : Drive
    /* Проверка, является ли левая часть L-выражением*/
    , <IsLexpr e.Left> : True
    = <CreateRemainderDrivenFunc
        s.ScopeClass (e.Name) e.Rest
      >
    : t.newFunc
    , t.newFunc : (Function s.Sc1 (e.NewName) e.Body)
    = ((e.RS) e.M (/* нет новых функций */))
      (
        ((CallBrackets (Symbol Name e.NewName) e.Args))
        ((/* нет присваиваний */) (/* нет сужений */))
        (t.newFunc)
      );

  /*
    В случае неудачи нужно заменить прогоняемый вызов
    на вызов остаточной функции
  */
  (e.RS) s.Mode (e.Left) s.ScopeClass (e.Name) (e.Rest) (e.Args)
  Failure
    = <CreateRemainderDrivenFunc
        s.ScopeClass (e.Name) e.Rest
      >
    : t.newFunc
    , t.newFunc : (Function s.Sc1 (e.NewName) e.Body)
    = (
        ((CallBrackets (Symbol Name e.NewName) e.Args))
        ((/* нет присваиваний */) (/* нет сужений */))
        (t.newFunc)
      );

  /*
    Замена вызова на холодный

    Undefined или левая часть не-L-выражение
  */
  (e.RS) s.Mode (e.Left) s.ScopeClass (e.Name) (e.Rest) (e.Args)
  e.Other
    = (
        ((ColdCallBrackets (Symbol Name e.Name) e.Args))
        ((/* нет присваиваний */) (/* нет сужений */))
        (/* нет новых функций */)
      );
}

DropLeft {
  e.List 0 =  e.List;
  t.Head e.Tail s.N = <DropLeft e.Tail <Sub s.N 1>>
}

/*
  <FindInlineInfo t.InlineInfo e.Name == Success t.InlineInfo | Failure
  t.InlineInfo := (Inline s.ScopeClass (e.Name) e.Body
*/

FindInlineInfo {
  t.InlineInfo e.Name = <FindOptInfo Inline t.InlineInfo e.Name>;
}

/*
  <FindDrivenInfo t.DriveInfo e.Name> == Success t.DriveInfo | Failure
  t.DriveInfo := (Drive s.ScopeClass (e.Name) e.Body)
*/

FindDriveInfo {
  t.DriveInfo e.Name = <FindOptInfo Drive t.DriveInfo e.Name>
}

FindOptInfo {
  s.Mode
  t.DriveInfo e.Name
    , e.Name : e.Prefix '*' s.N
    , <CutSUF e.Prefix> : e.Prefix^
    , t.DriveInfo
    : (
        (e.B1 (e.Prefix) e.E1)
        e.B2 (s.Mode s.ScopeClass (e.Prefix) s.Body) e.E2
      )
    = <s.Body> : Sentences e.Sentences
    = Success
      (s.Mode s.ScopeClass (e.Name) Sentences <DropLeft e.Sentences s.N>);

  s.Mode
  t.DriveInfo e.Name
    , t.DriveInfo
    : (
        (e.B1 (e.Name) e.E1)
        e.B2 (s.Mode s.ScopeClass (e.Name) s.Body) e.E2
      )
    = Success (s.Mode s.ScopeClass (e.Name) <s.Body>);

  s.Mode
  t.DriveInfo e.Name = Failure;
}

$DRIVE CutSUF;

CutSUF {
  e.Prefix SUF = e.Prefix;
  e.Prefix = e.Prefix;
}


/*
  <FindDriveCall t.DriveInfo e.Expr> == t.Found e.Expr

  t.Found ::= None | (CallBrackets e.Arg)
*/

FindDriveCall {
  t.DriveInfo e.Expr
    = <FindOptimizedCall &FindDriveInfo t.DriveInfo e.Expr>
    : (t.DriveInfo^ t.Found) e.Expr^
    = t.Found e.Expr
}

/*
  <FindInlineCall t.InlineInfo e.Expr> == t.Found e.Expr

  t.Found ::= None | (CallBrackets e.Arg)
*/

FindInlineCall {
  t.InlineInfo e.Expr
    = <FindOptimizedCall &FindInlineInfo t.InlineInfo e.Expr>
    : (t.InlineInfo^ t.Found) e.Expr^
    = t.Found e.Expr
}

FindOptimizedCall {
  s.Filter t.DriveInfo e.Expr
    = <MapAccum (&FindOptimizedCall-Term s.Filter) (t.DriveInfo None) e.Expr>;
}

FindOptimizedCall-Term {
  s.Filter (t.DriveInfo None) (Brackets e.Expr)
    = <FindOptimizedCall s.Filter t.DriveInfo e.Expr>
    : (t.DriveInfo^ t.Found) e.Expr^
    = (t.DriveInfo t.Found) (Brackets e.Expr);

  s.Filter (t.DriveInfo None) (ADT-Brackets (e.Name) e.Expr)
    = <FindOptimizedCall s.Filter t.DriveInfo e.Expr>
    : (t.DriveInfo^ t.Found) e.Expr^
    = (t.DriveInfo t.Found)
      (ADT-Brackets (e.Name) e.Expr);

  s.Filter (t.DriveInfo None) (CallBrackets (Symbol Name e.Name) e.Expr)
    , <IsPassiveCall e.Expr> : True
    , <s.Filter t.DriveInfo e.Name> : Success t.Info
    = (t.DriveInfo (CallBrackets (Symbol Name e.Name) e.Expr))
      (TkVariable 'e' DRIVEN 0);

* TODO: раскомментировать код ниже, когда будет реализовываться поддрежка
* TODO: активных аргументов функций
/*
  s.Filter (t.DriveInfo None) (CallBrackets (Symbol Name e.Name) e.Expr)
    , <s.Filter t.DriveInfo e.Name> : Success t.Info
    = <FindOptimizedCall s.Filter t.DriveInfo e.Expr>
    : {
        (t.DriveInfo^ None) e.Expr^
          = (t.DriveInfo (CallBrackets (Symbol Name e.Name) e.Expr))
            (TkVariable 'e' DRIVEN 0);

        (t.DriveInfo t.Found) e.Expr^
          = (t.DriveInfo t.Found) (CallBrackets (Symbol Name e.Name) e.Expr);
      };
*/

  s.Filter (t.DriveInfo None) (CallBrackets t.F e.Expr)
    = <FindOptimizedCall s.Filter t.DriveInfo e.Expr>
    : (t.DriveInfo^ t.Found) e.Expr^
    = (t.DriveInfo t.Found) (CallBrackets t.F e.Expr);

  s.Filter (t.DriveInfo t.Found) t.AnyTerm
    = (t.DriveInfo t.Found) t.AnyTerm;
}

/*
  <ApplySolutions
    ((e.Left) (e.Right)) (e.LS) (e.Solutions)
  > == t.Sentence* t.FunctionInfo
*/

ApplySolutions {

  ((e.Left) (e.Right)) (e.RS) e.Solutions

  = <Map
      {
        t.S
          = <ApplySolution
             ((e.Left) (e.Right)) (e.RS) t.S
            >
      }
      e.Solutions
    >
}

/*
  <ApplySolution
    ((e.Left) (e.Right)) (e.LS) (e.Contrs) (e.Assigns)
  > == t.Sentence
*/

ApplySolution {
  ((e.Left) (e.Right)) (e.RS) ((e.Contrs) (e.Assigns))
    = <ApplyAssigns e.RS (e.Assigns)>: e.CallReplacer
    = e.Contrs ((TkVariable 'e' DRIVEN 0) ':' e.CallReplacer): e.Contrs^
    = ((<ApplyContractions e.Left (e.Contrs)>)
       (<ApplyContractions e.Right (e.Contrs)>));
}

/*
  <ApplyAssigns (e.Expr) (e.Assigns)> == e.Expr^
*/

ApplyAssigns {
  e.Expr (e.Assigns)
    = <Map
        {
          t.T = <ApplyAssigns-Term t.T (e.Assigns)>
        }
        e.Expr
      >
}

ApplyAssigns-Term {
  (Brackets e.Expr) (e.Assigns) = (Brackets <ApplyAssigns e.Expr (e.Assigns)>);

  (CallBrackets e.Args) (e.Assigns)
    = (CallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ColdCallBrackets e.Args) (e.Assigns)
    = (ColdCallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ClosureBrackets e.Args) (e.Assigns)
    = (ClosureBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ADT-Brackets (e.Name) e.Expr) (e.Assigns)
    = (ADT-Brackets (e.Name) <ApplyAssigns e.Expr (e.Assigns)>);

  t.T (e.B (e.Asgn ':' t.T) e.E)
    =  e.Asgn;

  t.T (e.Assigns) = t.T;
}

/*
  <ApplyContractions (e.Expr) (e.Contrs) == e.Expr^
*/
ApplyContractions {
  e.Expr (e.Contrs)
    = <Map
        {
          t.T = <ApplyContractions-Term t.T (e.Contrs)>
        }
        e.Expr
      >;
}

ApplyContractions-Term {
  (Brackets e.Expr) (e.Contrs) = (Brackets <ApplyContractions e.Expr (e.Contrs)>);

  (CallBrackets e.Args) (e.Contrs)
    = (CallBrackets <ApplyContractions e.Args (e.Contrs)>);

  (ColdCallBrackets e.OriginArgs) (e.Contrs)
    = <ApplyContractions e.OriginArgs (e.Contrs)>
    : {
*        Содержимое холодных скобок не изменилось, оставляем их холодными
        e.OriginArgs = (ColdCallBrackets e.OriginArgs);

*       Содержимое обновилось, оттаиваем скобки
        e.ChangedArgs = (CallBrackets e.ChangedArgs);
      };

  (ClosureBrackets e.Args) (e.Contrs)
    = (ClosureBrackets <ApplyContractions e.Args (e.Contrs)>);

  (ADT-Brackets (e.Name) e.Expr) (e.Contrs)
    = (ADT-Brackets (e.Name) <ApplyContractions e.Expr (e.Contrs)>);

  t.Term (e.B (t.Term ':' e.Contr) e.E)
    = <ApplyContractions e.Contr (e.B (t.Term ':' e.Contr) e.E)>;

  t.T (e.Contrs) = t.T
}

/*
  <CreateRemainderDrivenFunc s.ScopeClass (e.Name) e.Sentences>
    == t.Function
*/

CreateRemainderDrivenFunc {
  s.ScopeClass (e.Name SUF e.Suffixes '*' s.N) e.Sentences =
    (Function s.ScopeClass (e.Name SUF e.Suffixes '*' <Add s.N 1>) Sentences e.Sentences);

  s.ScopeClass (e.Name SUF e.Suffixes) e.Sentences =
    (Function s.ScopeClass (e.Name SUF e.Suffixes '*' 1) Sentences e.Sentences);

  s.ScopeClass (e.Name) e.Sentences =
    (Function s.ScopeClass (e.Name SUF '*' 1) Sentences e.Sentences)
}

