$INCLUDE "LibraryEx";

*$FROM HighLevelRASL-Common
$EXTERN GenPattern, MakeSavers, GenResult;

*$FROM GlobalGen-Ref
$EXTERN GlobalGen, BuildImage, Generalization, Collapse,
  BuildImage-Term, Generalization-Term, Collapse-Term;

*$FROM GenericMatch
$EXTERN GenericMatch;


$ENTRY HighLevelRASL-Function-ConjointExt {
  s.FnGenSubst s.FnGenResult s.ScopeClass (e.Name) e.Sentences

    /* Получаем из предложений образцы */
    = <Map
        { ((e.Pattern) e.Conditions (e.Result)) = (e.Pattern); }
        e.Sentences
      >
    : e.Patterns

    /* Для жестких образцов строим Глобальное сложнейшее обобщение (ГСО) */
    = <GlobalGen e.Patterns> : e.GlobalGenNoIdents

    /* Добавляем к ГСО уникальные идентификаторы */
    = <EnumerateVarsRec 0 e.GlobalGenNoIdents> : s.BaseNum e.GlobalGen

    /* Сопоставляем образец каждого предложения с ГСО */
    = <Map
        {
          ((e.Pattern) e.Conditions (e.Result))

            /* Строим подстановки, переводящие ГСО в образец */
            = <GenericMatch (e.Pattern)(e.GlobalGen)> : Clear e.Substs

            /* Заменяем образцы на подстановки */
            = ((e.Substs) e.Conditions (e.Result));
        }
        e.Sentences
      >
    : e.SentencesWithSubst

    /* Собираем подстановки из всех предложений */
    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Substs) e.Conditions (e.Result))

            = (e.PatternSubsts (e.Substs))
              ((e.Substs) e.Conditions (e.Result));
        }
        (/* подстановки для каждого предложения */)
        e.SentencesWithSubst
      >
    : (e.SubstsForSentences) e.SentencesWithSubst^

    /* GenPattern для ГСО. Получаем общий набор команд */
    = <GenPattern s.FnGenSubst (e.Name) e.GlobalGen>
    : s.ContextSize (e.Vars) (e.MarkedPattern) e.CommonMatchCommands

    /* Рекурсивно вычисляем команды для предложений, формируя группы */
    = <GenerateCommandsOfGroups
        (e.GlobalGen)
        s.FnGenSubst s.FnGenResult
        (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns) s.ContextSize
        s.BaseNum
      >
    : s.MaxContextSize e.ResultCommands

    = e.ResultCommands
    : {
        e.Commands (CmdOpenELoop e.OpenELoop) =
          e.Commands (CmdOpenELoop e.OpenELoop) (CmdFail);
        e.Commands = e.Commands;
      }
    : e.ResultCommands^

    /* Добавляем найденные команды в блок функции */
    = (Function
        s.ScopeClass (e.Name)
        (CmdIssueMemory s.MaxContextSize)
        (CmdComment 'GLOBAL GEN:' /*<PatternComment e.GlobalGen>*/)
        e.CommonMatchCommands
        e.ResultCommands
      );
}

/* Формируем группы предложений и рекурсивно находим для них команды */
GenerateCommandsOfGroups {
  (e.GlobalGen)
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) ((e.SentenceWithSubst)) ((e.Pattern)) s.ContextSize s.BaseNum
    = <GenerateOneSentence
        s.FnGenSubst s.FnGenResult
        (e.MarkedPattern) (e.SentenceWithSubst) s.ContextSize
      >;

  (e.GlobalGen)
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns) s.ContextSize s.BaseNum

    /* Ищем разбиение предложений на 2 группы */
    = <FindDivision e.SentencesWithSubst>
    : {
        ForGroup (e.NewGCG-Subst) (e.FirstGroup) e.SecondGroup
          = <GenerateForSplit
              (e.GlobalGen)
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.Patterns) s.ContextSize s.BaseNum
              (e.FirstGroup) e.SecondGroup
            >;

        ForAllSentences (e.NewGCG-Subst) e.SentencesWithSubst^

          = <EnumerateVars-Subst s.BaseNum e.NewGCG-Subst>
          : s.BaseNum^ e.NewGCG-Subst^

          = <ComposeVars (e.MarkedPattern) (e.NewGCG-Subst)> : e.SubstsAndJunks

          = <MakeSavers s.ContextSize e.SubstsAndJunks>
          : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

          = <s.FnGenSubst
              s.ContextSize e.SubstsAndJunks
              (/* no known variables */) (e.CmdSaves)
            >
          : s.ContextSize^ (e.Vars) (e.MarkedPattern^) e.GCG-Commands

          = <NarrowSentenceSubstitutions (e.NewGCG-Subst) e.SentencesWithSubst>
          : e.SentencesWithSubst^

          = <Substitute (e.NewGCG-Subst) e.GlobalGen>
          : (/* пусто */) e.GlobalGen^

          = <GenerateCommandsOfGroups
              (e.GlobalGen)
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern)
              (e.SentencesWithSubst)
              (e.Patterns)
              s.ContextSize s.BaseNum
            >
          : s.ContextSize^ e.Commands

          = s.ContextSize e.GCG-Commands e.Commands;
      }
}

GenerateOneSentence {
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.SentenceWithSubst) s.ContextSize

    = e.SentenceWithSubst : (e.Substitute) e.Conditions (e.Result)

    = <ComposeVars (e.MarkedPattern) (e.Substitute)> : e.SubstsAndJunks

    = <s.FnGenSubst
        s.ContextSize e.SubstsAndJunks
        (/* no new vars */) (/* no prefix commands */)
      >
    : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

    = <GenResult
        s.FnGenResult (e.Conditions) (e.Result)
        s.ContextSize (e.Vars) (e.MarkedPattern) e.PatternCommands
      >
    : (CmdIssueMemory s.Memory) e.Commands

    = s.Memory e.Commands;
}

GenerateForSplit {
  (e.GlobalGen)
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.Patterns) s.ContextSize s.BaseNum
  (e.FirstGroup) e.SecondGroup

    = <Lenw e.FirstGroup> : s.Num1 e.SentencesWithSubst1
    = <Lenw e.SecondGroup> : s.Num2 e.SentencesWithSubst2

    = <First s.Num1 e.Patterns> : (e.Patterns1) e.Patterns2

    /* Генерация команд для первой группы */
    = s.Num1
    : {
        1 = <ReturnCommandsOfLastSentences
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.SentencesWithSubst1) s.ContextSize
            >
          : s.FirstSentenceContext e.FirstSentenceCommands
          = s.FirstSentenceContext (CmdSentence e.FirstSentenceCommands);

        s.Num1^
          = <GenerateCommands
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.SentencesWithSubst1) (e.Patterns1)
              (e.GlobalGen)
              s.ContextSize s.BaseNum
            >
          : s.FirstGroupContext e.FirstGroupCommands
          = s.FirstGroupContext (CmdSentence e.FirstGroupCommands);
      }
    : s.FirstPartContext e.FirstPartCommands

    /* Генерация команд для второй группы */
    = s.Num2
    : {
        1 = <ReturnCommandsOfLastSentences
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.SentencesWithSubst2) s.ContextSize
            >
          : s.SecondSentenceContext e.SecondSentenceCommands
          = s.SecondSentenceContext e.SecondSentenceCommands;

        s.Num2^
          = <GenerateCommandsOfGroups
              (e.GlobalGen)
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.SentencesWithSubst2) (e.Patterns2)
              s.ContextSize s.BaseNum
            >
          : s.SecondGroupContext e.SecondGroupCommands
          = s.SecondGroupContext e.SecondGroupCommands;
      }
    : s.SecondPartContext e.SecondPartCommands

    = <Max s.FirstPartContext s.SecondPartContext> : s.ContextSize^

    = s.ContextSize e.FirstPartCommands e.SecondPartCommands;
}

/* Рекурсивно вычисляем команды для предложений */
GenerateCommands {
  s.FnGenSubst s.FnGenResult (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns)
  (e.GlobalGenOld)
  s.ContextSize s.BaseNum

    /* Вычисляем ГСО подстановок и подстановки в e.MarkedPattern */
    = <GlobalGenOfSubsts s.BaseNum (e.GlobalGenOld) e.SentencesWithSubst>
    : s.BaseNum^ (e.GlobalGen) e.NewSubsts

    /* Находим новый e.MarkedPattern */
    = <ComposeVars (e.MarkedPattern) (e.NewSubsts)> : e.SubstsAndJunks

    = <MakeSavers s.ContextSize e.SubstsAndJunks>
      : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

    = <s.FnGenSubst
        s.ContextSize e.SubstsAndJunks (/* no new vars */) (e.CmdSaves)
      >
    : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

    /* Строим подстановки, переводящие новое ГСО в образец */
    = <Map
        {
          (e.Pattern)
            = <GenericMatch (e.Pattern) (e.GlobalGen)> : Clear e.Substs
            = (e.Substs);
        }
        e.Patterns
      >
    : e.SubstsForSentences

    /* Заменяем старые подстановки на найденные */
    = <ReplacePatternToNewSubst (e.SentencesWithSubst) (e.SubstsForSentences)>
    : e.SentencesWithSubst^

    /* Ищем разбиение на группы и формируем команды для новых предложений */
    = <GenerateCommandsOfGroups
        (e.GlobalGen)
        s.FnGenSubst s.FnGenResult
        (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns)
        s.ContextSize s.BaseNum
      >
    : s.MaxMemory e.ResultCommands

    = s.MaxMemory e.PatternCommands e.ResultCommands;
}

/* Итоговый набор команд для предложений, которые нельзя разделить на группы */
ReturnCommandsOfLastSentences {
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.SentencesWithSubst) s.ContextSize

    = <MapReduce
        {
          s.MaxMemory ((e.Substitute) e.Conditions (e.Result))

            = <ComposeVars (e.MarkedPattern) (e.Substitute)> : e.SubstsAndJunks

            = <MakeSavers s.ContextSize e.SubstsAndJunks>
            : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

            = <s.FnGenSubst
                s.ContextSize e.SubstsAndJunks (/* no new vars */) (e.CmdSaves)
              >
            : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

            = <GenResult
                s.FnGenResult (e.Conditions) (e.Result)
                s.ContextSize (e.Vars) (e.MarkedPattern) e.PatternCommands
              >
            : (CmdIssueMemory s.Memory) e.Commands

            = <Max s.MaxMemory s.Memory>
              (CmdSentence
                /* (CmdComment e.HardGenComment) */
                e.Commands
              );
        }
        s.ContextSize e.SentencesWithSubst
      >
    : s.MaxMemory e.ResultSentences (CmdSentence e.LastSentence)

    = s.MaxMemory e.ResultSentences e.LastSentence;
}

/* Заменяет образец на заданный терм */
ReplacePatternToNewSubst {
  () () = ;

  (t.FirstSentence e.Sentences) (t.FirstTerm e.Terms)
    = t.FirstSentence
    : ((e.Pattern) e.Conditions (e.Result))

    = (t.FirstTerm e.Conditions (e.Result))
      <ReplacePatternToNewSubst (e.Sentences) (e.Terms)>;
}


/* Перебирает переменные в обобщении и заменяет на значения подстановок */
ComposeVars {
  (e.MarkedPattern-B (TkVariable s.Mode e.Name s.Offset) e.MarkedPattern-E)
  (e.Substitute-B ( e.Subst ':' (s.Mode e.Name) ) e.Substitute-E)
    = s.Mode : { 's' = S; 't' = T; 'e' = E; } : s.Mode^
    = (Junk e.MarkedPattern-B) (s.Mode s.Offset e.Subst)
      <ComposeVars
        (e.MarkedPattern-E)
        (e.Substitute-B e.Substitute-E)
      >;

  (e.MarkedPattern) () = (Junk e.MarkedPattern);
}

/* Добавляет уникальные индексы */
EnumerateVarsRec {
  s.NextNumber e.Expr
    = <MapReduce
        {
          s.Next (TkVariable s.Type)
            = <Inc s.Next> (TkVariable s.Type 'new' s.Next);

          s.Next (Brackets e.Nested)
            = <EnumerateVarsRec s.Next e.Nested> : s.Next^ e.Nested^
            = s.Next (Brackets e.Nested);

          s.Next (ADT-Brackets (e.Name) e.Nested)
            = <EnumerateVarsRec s.Next e.Nested> : s.Next^ e.Nested^
            = s.Next (ADT-Brackets (e.Name) e.Nested);

          s.Next t.OtherTerm = s.Next t.OtherTerm;
        }
        s.NextNumber e.Expr
      >;
}

EnumerateVars-Subst {
  s.StartNumber e.Substitute
    = <MapReduce
        {
          s.NextNumber (e.Value ':' (e.Var))
            = <EnumerateVarsRec s.NextNumber e.Value> : s.NextNumber^ e.Value^
            = s.NextNumber (e.Value ':' (e.Var))
        }
        s.StartNumber e.Substitute
      >;
}


/*
  <FindDivision e.SentencesWithSubst>
    == ForGroup (e.NewGCG-Subst) (e.FirstGroup) e.SecondGroup
    == ForAllSentences (e.NewGCG-Subst) e.SentencesWithSubst^

  Функция пытается найти префикс из предложений с нетривиальным ГСО.
  Если префикс охватывает все предложения (суффикс пустой), то она просто
  возвращает подстановку нетривиального ГСО.
*/
FindDivision {
  (e.FirstSentence) e.Sentences
    , e.FirstSentence : (e.FirstSubst) e.FirstConditions (e.FirstResult)
    = <ImagedSentence e.FirstSentence> : (e.FirstImage) e.FirstSentence^
    = <MakeTrivialSubstImage e.FirstImage> : e.TrivialGCG
    = <DoFindDivision
        (e.TrivialGCG) (e.FirstImage) ((e.FirstSentence)) e.Sentences
      >;
}

ImagedSentence {
  (e.Subst) e.Conditions (e.Result)
    = <Subst-BuildImage e.Subst> : e.SubstImage
    = (e.SubstImage) (e.Subst) e.Conditions (e.Result);
}

MakeTrivialSubstImage {
  e.SubstImage
    = <Map
        {
          (t.Image ':' ('e' e.Index))
            = ((MN ':' 0 ',' () ',' ()) ':' ('e' e.Index));

          (t.Image ':' (s.ST e.Index)) = ((TkVariable s.ST) ':' (s.ST e.Index));
        }
        e.SubstImage
      >;
}

/*
  <DoFindDivision (e.TrivialGCG) t.Image (e.FirstGroup) e.RestSentences>

  Функция накапливает в e.FirstGroup подстановки до тех пор, пока их ГСО
  будет отличаться от тривиального.
*/
DoFindDivision {
  (e.TrivialGCG) (e.Image) (e.FirstGroup) (e.NextSentence) e.Sentences
    = <ImagedSentence e.NextSentence> : (e.NextImage) e.NextSentence
    = <Subst-Generalization (e.Image) (e.NextImage)> : e.NewImage
    = e.NewImage
    : {
        e.TrivialGCG
          = ForGroup
            (<Subst-Collapse e.Image>)
            (e.FirstGroup) (e.NextSentence) e.Sentences;

        e.OtherGCG
          = <DoFindDivision
              (e.TrivialGCG) (e.NewImage) (e.FirstGroup (e.NextSentence))
              e.Sentences
            >;
      };

  (e.TrivialGCG) (e.Image) (e.FirstGroup)
    = ForAllSentences (<Subst-Collapse e.Image>) e.FirstGroup
}


/* Собирает значения подстановок по одной переменной и находит их ГСО */
GlobalGenOfSubsts {
  s.BaseNum (e.GlobalGenOld) e.SentencesWithSubst

    /* Получаем подстановки из предложений */
    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Substs) e.Conditions (e.Result))

            = (e.PatternSubsts (e.Substs));
        }
        (/* подстановки для каждого предложения */)
        e.SentencesWithSubst
      >
    : (e.SubstsSet)

    /* Собираем значения подстановок по одной переменной */
    = <CollectSubsts e.SubstsSet> : e.CollectedSubsts

    /* Находим жесткие значения подстановок и затем их ГСО */
    = <MapReduce
        {
          s.Index (e.SubstsVals ':' (e.Var))

            /* Считаем ГСО по жестким значениям для одной подстановки */
            = <GlobalGen e.SubstsVals> : e.GlobalGenNoIdents

            /* Добавляем к ГСО уникальные идентификаторы */
            = <EnumerateVarsRec s.Index e.GlobalGenNoIdents>
            : s.Index^ e.GlobalGen

            = s.Index (e.GlobalGen ':' (e.Var));
        }
        s.BaseNum e.CollectedSubsts
      >
    : s.Index e.GlobalGenSubsts

    /* Заменяем переменные в исходном ГСО на их уточненные значения */
    = <Substitute (e.GlobalGenSubsts) e.GlobalGenOld>
    : (/* должно стать пусто */) e.ResultGlobalGen

    = s.Index (e.ResultGlobalGen) e.GlobalGenSubsts;
}

Substitute {
  (e.Substs) e.Expr
    = <MapReduce
        {
          (/* no substs */) t.AnyTerm = (/* no substs */) t.AnyTerm;

          (e.Substs-B (e.Value ':' (s.Type e.Index)) e.Substs-E)
          (TkVariable s.Type e.Index)
            = (e.Substs-B e.Substs-E) e.Value;

          (e.Substs^) (Brackets e.Nested)
            = <Substitute (e.Substs) e.Nested> : (e.Substs^) e.Nested^
            = (e.Substs) (Brackets e.Nested);

          (e.Substs^) (ADT-Brackets (e.Name) e.Nested)
            = <Substitute (e.Substs) e.Nested> : (e.Substs^) e.Nested^
            = (e.Substs) (ADT-Brackets (e.Name) e.Nested);

          (e.Substs^) t.OtherTerm = (e.Substs) t.OtherTerm;
        }
        (e.Substs) e.Expr
      >;
}

NarrowSentenceSubstitutions {
  (e.NewGCG-Subst) e.Sentences
    = <Map
        {
          ((e.Substs) e.Conditions (e.Result))
            = (
                (<NarrowSubst (e.NewGCG-Subst) (e.Substs)>)
                e.Conditions
                (e.Result)
              );
        }
        e.Sentences
      >;
}

NarrowSubst {
  (e.GCG-Substs-B (e.GCG ':' (e.Var)) e.GCG-Substs-E)
  ((e.Pattern ':' (e.Var)) e.SentenceSubsts)
    = <GenericMatch (e.Pattern) (e.GCG)> : Clear e.NarrowSubsts
    = e.NarrowSubsts
      <NarrowSubst (e.GCG-Substs-B e.GCG-Substs-E) (e.SentenceSubsts)>;

  () () = /* пусто */;
}

/* Объединяет наборы подстановок по обобщению (по t.Var справа от ':') */
CollectSubsts {
  e.Before (/* подстановки закончились */) e.Other = /* пусто */;

  e.SubstsSet
    = <MapReduce
        {
          (e.PrevVals ':' e.PrevVar) ((e.Val ':' t.Var) e.OtherSubsts)
            = (e.PrevVals (e.Val) ':' t.Var) (e.OtherSubsts);
        }
        (/* Значения подстановок */ ':' /* Их обобщение */)
        e.SubstsSet
      >
    : (e.SubstsVals ':' t.Var) e.SubstsSet^
    = (e.SubstsVals ':' t.Var) <CollectSubsts e.SubstsSet>;
}


Subst-BuildImage {
  e.Substitution
    = <Map
        {
          (e.Value ':' ('e' e.Index))
            = (<BuildImage e.Value> ':' ('e' e.Index));
          (t.Value ':' (s.ST e.Index))
            = (<BuildImage-Term t.Value> ':' (s.ST e.Index));
        }
        e.Substitution
      >;
}

Subst-Generalization {
  ((t.Image1 ':' ('e' e.Index)) e.Images1)
  ((t.Image2 ':' ('e' e.Index)) e.Images2)
    = (<Generalization t.Image1 t.Image2> ':' ('e' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  ((t.Image1 ':' ('t' e.Index)) e.Images1)
  ((t.Image2 ':' ('t' e.Index)) e.Images2)
    = (<Generalization-Term t.Image1 t.Image2> ':' ('t' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  /* Они оба — или одинаковый символ, или безымянная s-переменная */
  ((t.Image ':' ('s' e.Index)) e.Images1)
  ((t.Image ':' ('s' e.Index)) e.Images2)
    = (t.Image ':' ('s' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  /* Разные символы или символ vs s-переменная — обобщаем */
  ((t.Image1 ':' ('s' e.Index)) e.Images1)
  ((t.Image2 ':' ('s' e.Index)) e.Images2)
    = ((TkVariable 's') ':' ('s' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  (/* пусто */) (/* пусто */) = /* пусто */;
}

Subst-Collapse {
  e.Substitution
    = <Map
        {
          (t.Image ':' ('e' e.Index)) = (<Collapse t.Image> ':' ('e' e.Index));
          (t.Image ':' ('t' e.Index)) = (<Collapse-Term t.Image> ':' ('t' e.Index));
          (t.Image ':' ('s' e.Index)) = (t.Image ':' ('s' e.Index));
        }
        e.Substitution
      >;
}
