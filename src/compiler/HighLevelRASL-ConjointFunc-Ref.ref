$INCLUDE "LibraryEx";

*$FROM HighLevelRASL-Common
$EXTERN GenPattern, MakeSavers, GenResult;

*$FROM HardSent-Ref
$EXTERN HardSentence;

*$FROM GlobalGen-Ref
$EXTERN GlobalGen, Len;

*$FROM GenericMatch
$EXTERN GenericMatch;

$ENTRY HighLevelRASL-Function-ConjointExt {
  s.FnGenSubst s.FnGenResult s.ScopeClass (e.Name) e.Sentences

    /* Получаем из предложений образцы и преобразуем в жесткие образцы */
    = <Map
        { ((e.Pattern) e.Conditions (e.Result)) = (<HardSentence e.Pattern>); }
        e.Sentences
      >
    : e.HardPatterns

    /* Для жестких образцов строим Глобальное сложнейшее обобщение (ГСО) */
    = <GlobalGen e.HardPatterns> : e.GlobalGenNoIdents

    /* Добавляем к ГСО уникальные идентификаторы */
    = <EnumerateVars e.GlobalGenNoIdents> : e.GlobalGen

    /* Сопоставляем образец каждого предложения с ГСО */
    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Pattern) e.Conditions (e.Result))

            /* Строим подстановки, переводящие ГСО в образец */
            = <GenericMatch (e.Pattern)(e.GlobalGen)> : Clear e.Substs

            /* Сохраняем подстановки для группировки.
               Заменяем образцы на подстановки */
            = (e.PatternSubsts (e.Substs))
              ((e.Substs)(/* e.HardGenComment */) e.Conditions (e.Result));
        }
        (/* подстановки для каждого предложения */)
        e.Sentences
      >
    : t.Substs e.SentencesWithSubst

    /* GenPattern для ГСО */
    = <GenPattern s.FnGenSubst (e.Name) e.GlobalGen>
    : s.ContextSize (e.Vars) (e.MarkedPattern) e.CommonMatchCommands

    /* Строим подстановки, переводящие ГСО в образец */
    = <MapReduce
        {
          s.MaxMemory ((e.Substitute) (e.HardGenComment) e.Conditions (e.Result))

            /* Помечаем Junk все кроме переменных. Им ставим изначальное имя */
            = <ComposeVars (e.MarkedPattern) (e.Substitute)> : e.SubstsAndJunks

            /* Для е-переменных, сохраняем позицию и контекст в e.CmdSaves
               Затем заменяем ее позицию на контекст, увеличиваем смещение */
            = <MakeSavers s.ContextSize e.SubstsAndJunks>
            : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

            = <s.FnGenSubst
                s.ContextSize e.SubstsAndJunks (/* no new vars */) (e.CmdSaves)
              >
            : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

            = <GenResult
                s.FnGenResult (e.Conditions) (e.Result)
                s.ContextSize (e.Vars) (e.MarkedPattern) e.PatternCommands
              >
            : (CmdIssueMemory s.Memory) e.Commands

            = <Max s.MaxMemory s.Memory>
              (CmdSentence
                (CmdComment e.HardGenComment)
                e.Commands
              );
        }
        s.ContextSize e.SentencesWithSubst
      >
    : s.MaxMemory e.ResultSentences (CmdSentence e.LastSentence)

    /* Блок группировки. Не влияет на результат */

    = <FindDivision t.Substs (e.GlobalGenNoIdents)> : s.DivisionNum

    = <First s.DivisionNum e.Sentences> : (e.FirstGroup) e.Rest

    = <Map
        { ((e.Pattern) e.Conditions (e.Result)) = (<HardSentence e.Pattern>); }
        e.FirstGroup
      >
    : e.HardPatterns^

    = <GlobalGen e.HardPatterns> : e.GlobalGenNoIdents^

    = <EnumerateVars e.GlobalGenNoIdents> : e.GlobalGen^

    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Pattern) e.Conditions (e.Result))

            = <GenericMatch (e.Pattern)(e.GlobalGen)> : Clear e.Substs^

            = (e.PatternSubsts (e.Substs))
              ((e.Substs)() e.Conditions (e.Result));
        }
        ()
        e.FirstGroup
      >
    : t.Substs^ e.SentencesWithSubst^

    /* Конец блока группировки */

    = (Function
        s.ScopeClass (e.Name)
        (CmdIssueMemory s.MaxMemory)
        (CmdComment 'GLOBAL GEN:' /*<PatternComment e.GlobalGen>*/)
        e.CommonMatchCommands
        e.ResultSentences
        <Fetch
          e.LastSentence
          {
            e.Commands (CmdOpenELoop e.OpenELoop) =
              e.Commands (CmdOpenELoop e.OpenELoop) (CmdFail);
            e.LastSentence^ = e.LastSentence;
          }
        >
      );
}

/* Перебирает переменные в обобщении и заменяет на значения подстановок */
ComposeVars {
  (e.MarkedPattern-B (TkVariable s.Mode e.Name s.Offset) e.MarkedPattern-E)
  (e.Substitute-B ( e.Subst ':' (s.Mode e.Name) ) e.Substitute-E)
    = s.Mode : { 's' = S; 't' = T; 'e' = E; } : s.Mode^
    = (Junk e.MarkedPattern-B) (s.Mode s.Offset e.Subst)
      <ComposeVars
        (e.MarkedPattern-E)
        (e.Substitute-B e.Substitute-E)
      >;

  (e.MarkedPattern) () = (Junk e.MarkedPattern);
}

/* Добавляет уникальные индексы */
$ENTRY EnumerateVars {
  e.Expr
    = <EnumerateVarsRec 0 e.Expr> : s.NextNum e.Expr^
    = e.Expr;
}

EnumerateVarsRec {
  s.NextNumber e.Expr
    = <MapReduce
        {
          s.Next (TkVariable s.Type)
            = <Inc s.Next> (TkVariable s.Type 'new' s.Next);

          s.Next (Brackets e.Nested)
            = <EnumerateVarsRec s.Next e.Nested> : s.Next^ e.Nested^
            = s.Next (Brackets e.Nested);

          s.Next (ADT-Brackets (e.Name) e.Nested)
            = <EnumerateVarsRec s.Next e.Nested> : s.Next^ e.Nested^
            = s.Next (ADT-Brackets (e.Name) e.Nested);

          s.Next t.OtherTerm = s.Next t.OtherTerm;
        }
        s.NextNumber e.Expr
      >;
}


/*
  ГСО должно быть без индексов, т.е. неразмеченное

  Возвращает длину первой группы
*/
FindDivision {
  /* Если осталось одно предложение, можно сразу вернуть 1 (группа из 1 предложения) */

  (e.FirstSentences t.LastSentence) (e.GlobalGen)
    = <CompareSubsts e.FirstSentences (e.GlobalGen)>
    : {
        Stop = <Len e.FirstSentences>;
        Continue = <FindDivision (e.FirstSentences) (e.GlobalGen)>;
      };
}

CompareSubsts {
  e.Sentences (/* GlobalGen */) = Continue;

  e.Sentences (t.GlobalGenFirst e.GlobalGen)

    /* Отделяем по одной подстановке слева и берем только её значение */
    = <MapReduce
        {
          (e.PrevVal) ((e.Val ':' t.Var) e.OtherSubsts)
            = (e.PrevVal (e.Val)) (e.OtherSubsts)
        }
        (/* Значения подстановок */)
        e.Sentences
      >
    : (e.SubstsVals) e.Sentences^

    /* Получаем из значений подстановок жесткие подстановки */
    = <Map
        { (e.SubstsVal) = (<HardSentence e.SubstsVal>); }
        e.SubstsVals
      >
    : e.HardSubsts

    /* Строим ГСО для подстановок */
    = <GlobalGen e.HardSubsts> : e.GlobalGenOfSubsts

    /* Сравним ГСО для подстановок группы и для всех предложений */
    = e.GlobalGenOfSubsts
    : {
        /* Если ГСО точнее не стало, рассмотрим остальные подстановки */
        t.GlobalGenFirst = <CompareSubsts e.Sentences (e.GlobalGen)>;

        /* Иначе, разбиение на группы найдено */
        e.Else = Stop;
      };
}