$INCLUDE "LibraryEx";

*$FROM HighLevelRASL-Common
$EXTERN GenPattern, MakeSavers, GenResult;

*$FROM GlobalGen-Ref
$EXTERN GlobalGen, BuildImage, Generalization, Collapse,
  BuildImage-Term, Generalization-Term, Collapse-Term;

*$FROM GenericMatch
$EXTERN GenericMatch;


$ENTRY HighLevelRASL-Function-ConjointExt {
  s.FnGenSubst s.FnGenResult s.ScopeClass (e.Name) e.Sentences

    /* Получаем из предложений образцы */
    = <Map
        { ((e.Pattern) e.Conditions (e.Result)) = (e.Pattern); }
        e.Sentences
      >
    : e.Patterns

    /* Для жестких образцов строим Глобальное сложнейшее обобщение (ГСО) */
    = <GlobalGen e.Patterns> : e.GlobalGenNoIdents

    /* Добавляем к ГСО уникальные идентификаторы */
    = <EnumerateVars 0 e.GlobalGenNoIdents> : e.GlobalGen

    /* Сопоставляем образец каждого предложения с ГСО */
    = <Map
        {
          ((e.Pattern) e.Conditions (e.Result))

            /* Строим подстановки, переводящие ГСО в образец */
            = <GenericMatch (e.Pattern)(e.GlobalGen)> : Clear e.Substs

            /* Заменяем образцы на подстановки */
            = ((e.Substs) e.Conditions (e.Result));
        }
        e.Sentences
      >
    : e.SentencesWithSubst

    /* Собираем подстановки из всех предложений */
    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Substs) e.Conditions (e.Result))

            = (e.PatternSubsts (e.Substs))
              ((e.Substs) e.Conditions (e.Result));
        }
        (/* подстановки для каждого предложения */)
        e.SentencesWithSubst
      >
    : (e.SubstsForSentences) e.SentencesWithSubst^

    /* GenPattern для ГСО. Получаем общий набор команд */
    = <GenPattern s.FnGenSubst (e.Name) e.GlobalGen>
    : s.ContextSize (e.Vars) (e.MarkedPattern) e.CommonMatchCommands

    /* Рекурсивно вычисляем команды для предложений, формируя группы */
    = <GenerateCommandsOfGroups
        (e.GlobalGen)
        s.FnGenSubst s.FnGenResult
        (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns) s.ContextSize 0
      >
    : s.MaxContextSize e.ResultCommands

    /* Добавляем найденные команды в блок функции */
    = (Function
        s.ScopeClass (e.Name)
        (CmdIssueMemory s.MaxContextSize)
        (CmdComment 'GLOBAL GEN:' /*<PatternComment e.GlobalGen>*/)
        e.CommonMatchCommands
        e.ResultCommands
      );
}

/* Формируем группы предложений и рекурсивно находим для них команды */
GenerateCommandsOfGroups {
  (e.GlobalGen)
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns) s.ContextSize s.BaseNum

    /* Ищем разбиение предложений на 2 группы */
    = <FindDivision (e.SentencesWithSubst)> : (e.FirstGroup) e.SecondGroup

    = <Lenw e.FirstGroup> : s.Num1 e.SentencesWithSubst1
    = <Lenw e.SecondGroup> : s.Num2 e.SentencesWithSubst2
    = s.Num1 s.Num2
    : {
        /* Дальнейшее разбиение невозможно. Формируем команды для предложений */
        0 s.Num2 =
            <ReturnCommandsOfLastSentences
              s.FnGenSubst s.FnGenResult
              (e.MarkedPattern) (e.SentencesWithSubst) s.ContextSize
            >;

        s.Num1 s.Num2
          = <First s.Num1 e.Patterns> : (e.Patterns1) e.Patterns2

          /* Генерация команд для первой группы */
          = s.Num1
          : {
              1 = <ReturnCommandsOfLastSentences
                    s.FnGenSubst s.FnGenResult
                    (e.MarkedPattern) (e.SentencesWithSubst1) s.ContextSize
                  >
                : s.FirstSentenceContext e.FirstSentenceCommands
                = s.FirstSentenceContext (CmdSentence e.FirstSentenceCommands);

              s.Num1^
                = <GenerateCommands
                    s.FnGenSubst s.FnGenResult
                    (e.MarkedPattern) (e.SentencesWithSubst1) (e.Patterns1)
                    (e.GlobalGen)
                    s.ContextSize <Inc s.BaseNum>
                  >
                : s.FirstGroupContext e.FirstGroupCommands
                = s.FirstGroupContext (CmdSentence e.FirstGroupCommands);
            }
          : s.FirstPartContext e.FirstPartCommands

          /* Генерация команд для второй группы */
          = s.Num2
          : {
              1 = <ReturnCommandsOfLastSentences
                    s.FnGenSubst s.FnGenResult
                    (e.MarkedPattern) (e.SentencesWithSubst2) s.ContextSize
                  >
                : s.SecondSentenceContext e.SecondSentenceCommands
                = s.SecondSentenceContext e.SecondSentenceCommands;

              s.Num2^
                = <GenerateCommandsOfGroups
                    (e.GlobalGen)
                    s.FnGenSubst s.FnGenResult
                    (e.MarkedPattern) (e.SentencesWithSubst2) (e.Patterns2)
                    s.ContextSize s.BaseNum
                  >
                : s.SecondGroupContext e.SecondGroupCommands
                = s.SecondGroupContext e.SecondGroupCommands;
            }
          : s.SecondPartContext e.SecondPartCommands

          = <Max s.FirstPartContext s.SecondPartContext> : s.ContextSize^

          = s.ContextSize e.FirstPartCommands e.SecondPartCommands;
      }
    : s.MaxMemory e.ResultCommands

    = s.MaxMemory e.ResultCommands;
}

/* Рекурсивно вычисляем команды для предложений */
GenerateCommands {
  s.FnGenSubst s.FnGenResult (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns)
  (e.GlobalGenOld)
  s.ContextSize s.BaseNum

    /* Вычисляем ГСО подстановок и подстановки в e.MarkedPattern */
    = <GlobalGenOfSubsts s.BaseNum (e.GlobalGenOld) e.SentencesWithSubst>
    : (e.GlobalGen) e.NewSubsts

    /* Находим новый e.MarkedPattern */
    = <ComposeVars (e.MarkedPattern) (e.NewSubsts)> : e.SubstsAndJunks

    = <MakeSavers s.ContextSize e.SubstsAndJunks>
      : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

    = <s.FnGenSubst
        s.ContextSize e.SubstsAndJunks (/* no new vars */) (e.CmdSaves)
      >
    : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

    /* Строим подстановки, переводящие новое ГСО в образец */
    = <Map
        {
          (e.Pattern)
            = <GenericMatch (e.Pattern) (e.GlobalGen)> : Clear e.Substs
            = (e.Substs);
        }
        e.Patterns
      >
    : e.SubstsForSentences

    /* Заменяем старые подстановки на найденные */
    = <ReplacePatternToNewSubst (e.SentencesWithSubst) (e.SubstsForSentences)>
    : e.SentencesWithSubst^

    /* Ищем разбиение на группы и формируем команды для новых предложений */
    = <GenerateCommandsOfGroups
        (e.GlobalGen)
        s.FnGenSubst s.FnGenResult
        (e.MarkedPattern) (e.SentencesWithSubst) (e.Patterns)
        s.ContextSize s.BaseNum
      >
    : s.MaxMemory e.ResultCommands

    = s.MaxMemory e.PatternCommands e.ResultCommands;
}

/* Итоговый набор команд для предложений, которые нельзя разделить на группы */
ReturnCommandsOfLastSentences {
  s.FnGenSubst s.FnGenResult
  (e.MarkedPattern) (e.SentencesWithSubst) s.ContextSize

    = <MapReduce
        {
          s.MaxMemory ((e.Substitute) e.Conditions (e.Result))

            = <ComposeVars (e.MarkedPattern) (e.Substitute)> : e.SubstsAndJunks

            = <MakeSavers s.ContextSize e.SubstsAndJunks>
            : s.ContextSize^ (e.CmdSaves) e.SubstsAndJunks^

            = <s.FnGenSubst
                s.ContextSize e.SubstsAndJunks (/* no new vars */) (e.CmdSaves)
              >
            : s.ContextSize^ (e.Vars^) (e.MarkedPattern^) e.PatternCommands

            = <GenResult
                s.FnGenResult (e.Conditions) (e.Result)
                s.ContextSize (e.Vars) (e.MarkedPattern) e.PatternCommands
              >
            : (CmdIssueMemory s.Memory) e.Commands

            = <Max s.MaxMemory s.Memory>
              (CmdSentence
                /* (CmdComment e.HardGenComment) */
                e.Commands
              );
        }
        s.ContextSize e.SentencesWithSubst
      >
    : s.MaxMemory e.ResultSentences (CmdSentence e.LastSentence)

    = <Fetch
        e.LastSentence
        {
          e.Commands (CmdOpenELoop e.OpenELoop) =
            e.Commands (CmdOpenELoop e.OpenELoop) (CmdFail);
          e.LastSentence^ = e.LastSentence;
        }
      >
    : e.LastSentence^

    = s.MaxMemory e.ResultSentences e.LastSentence;
}

/* Заменяет образец на заданный терм */
ReplacePatternToNewSubst {
  () () = ;

  (t.FirstSentence e.Sentences) (t.FirstTerm e.Terms)
    = t.FirstSentence
    : ((e.Pattern) e.Conditions (e.Result))

    = (t.FirstTerm e.Conditions (e.Result))
      <ReplacePatternToNewSubst (e.Sentences) (e.Terms)>;
}


/* Перебирает переменные в обобщении и заменяет на значения подстановок */
ComposeVars {
  (e.MarkedPattern-B (TkVariable s.Mode e.Name s.Offset) e.MarkedPattern-E)
  (e.Substitute-B ( e.Subst ':' (s.Mode e.Name) ) e.Substitute-E)
    = s.Mode : { 's' = S; 't' = T; 'e' = E; } : s.Mode^
    = (Junk e.MarkedPattern-B) (s.Mode s.Offset e.Subst)
      <ComposeVars
        (e.MarkedPattern-E)
        (e.Substitute-B e.Substitute-E)
      >;

  (e.MarkedPattern) () = (Junk e.MarkedPattern);
}

/* Добавляет уникальные индексы */
$ENTRY EnumerateVars {
  s.BaseNum e.Expr
    = <EnumerateVarsRec 0 s.BaseNum e.Expr> : s.NextNum e.Expr^
    = e.Expr;
}

EnumerateVarsRec {
  s.NextNumber s.BaseNum e.Expr
    = <MapReduce
        {
          s.Next (TkVariable s.Type)
            = <Inc s.Next> (TkVariable s.Type 'new' s.BaseNum s.Next);

          s.Next (Brackets e.Nested)
            = <EnumerateVarsRec s.Next s.BaseNum e.Nested> : s.Next^ e.Nested^
            = s.Next (Brackets e.Nested);

          s.Next (ADT-Brackets (e.Name) e.Nested)
            = <EnumerateVarsRec s.Next s.BaseNum e.Nested> : s.Next^ e.Nested^
            = s.Next (ADT-Brackets (e.Name) e.Nested);

          s.Next t.OtherTerm = s.Next t.OtherTerm;
        }
        s.NextNumber e.Expr
      >;
}


/*
  Ищет разбиение предложений на 2 группы, сравнивая ГСО и ГСО подстановок
  ГСО должно быть без индексов, т.е. неразмеченное

  Возвращает предложения первой группы
*/
FindDivision {
  () = /* пусто */;

  /* Если осталось одно предложение, можно его сразу вернуть */
  (t.Sentence) = (/* пусто */) t.Sentence;

  /*
    Предполагается, что во всех подстановках переменные перечислены
    в одном порядке.
  */
  ((e.FirstSentence) e.Sentences)
    , e.FirstSentence : (e.FirstSubst) e.FirstConditions (e.FirstResult)
    = <ImagedSentence e.FirstSentence> : (e.FirstImage) e.FirstSentence^
    = <MakeTrivialSubstImage e.FirstImage> : e.TrivialGCG
    = <DoFindDivision
        (e.TrivialGCG) (e.FirstImage) ((e.FirstSentence)) e.Sentences
      >;
}

ImagedSentence {
  (e.Subst) e.Conditions (e.Result)
    = <Subst-BuildImage e.Subst> : e.SubstImage
    = (e.SubstImage) (e.Subst) e.Conditions (e.Result);
}

MakeTrivialSubstImage {
  e.SubstImage
    = <Map
        {
          (t.Image ':' ('e' e.Index))
            = ((MN ':' 0 ',' () ',' ()) ':' ('e' e.Index));

          (t.Image ':' (s.ST e.Index)) = ((TkVariable s.ST) ':' (s.ST e.Index));
        }
        e.SubstImage
      >;
}

/*
  <DoFindDivision (e.TrivialGCG) t.Image (e.FirstGroup) e.RestSentences>
    == e.FirstGroup

  Функция накапливает в e.FirstGroup подстановки до тех пор, пока их ГСО
  будет отличаться от тривиального.
*/
DoFindDivision {
  (e.TrivialGCG) (e.Image) (e.FirstGroup) (e.NextSentence) e.Sentences
    = <ImagedSentence e.NextSentence> : (e.NextImage) e.NextSentence
    = <Subst-Generalization (e.Image) (e.NextImage)> : e.Image^
    = e.Image
    : {
        e.TrivialGCG = (e.FirstGroup) (e.NextSentence) e.Sentences;

        e.OtherGCG
          = <DoFindDivision
              (e.TrivialGCG) (e.Image) (e.FirstGroup (e.NextSentence))
              e.Sentences
            >;
      };

  /*
    TODO: грязный хак.
    На вход функции DoFindDivision падают подстановки, которые сами могут иметь
    нетривиальный ГСО. При этом вызывающий код ожидает, что возвращаемое
    значение долно быть короче, чем аргумент функции.
  */
  (e.TrivialGCG) (e.Image) (e.FirstGroup t.LastSentence)
    = (e.FirstGroup) t.LastSentence;
}


/* Собирает значения подстановок по одной переменной и находит их ГСО */
GlobalGenOfSubsts {
  s.BaseNum (e.GlobalGenOld) e.SentencesWithSubst

    /* Получаем подстановки из предложений */
    = <MapReduce
        {
          (e.PatternSubsts)
          ((e.Substs) e.Conditions (e.Result))

            = (e.PatternSubsts (e.Substs));
        }
        (/* подстановки для каждого предложения */)
        e.SentencesWithSubst
      >
    : (e.SubstsSet)

    /* Собираем значения подстановок по одной переменной */
    = <CollectSubsts e.SubstsSet> : e.CollectedSubsts

    /* Находим жесткие значения подстановок и затем их ГСО */
    = <MapReduce
        {
          s.Index (e.SubstsVals ':' (e.Var))

            /* Считаем ГСО по жестким значениям для одной подстановки */
            = <GlobalGen e.SubstsVals> : e.GlobalGenNoIdents

            /* Добавляем к ГСО уникальные идентификаторы */
            = <EnumerateVarsRec s.Index s.BaseNum e.GlobalGenNoIdents>
            : s.Index^ e.GlobalGen

            = s.Index (e.GlobalGen ':' (e.Var));
        }
        0 e.CollectedSubsts
      >
    : s.Index e.GlobalGenSubsts

    /* Заменяем переменные в исходном ГСО на их уточненные значения */
    = <Substitute (e.GlobalGenSubsts) e.GlobalGenOld>
    : (/* должно стать пусто */) e.ResultGlobalGen

    = (e.ResultGlobalGen) e.GlobalGenSubsts;
}

Substitute {
  (e.Substs) e.Expr
    = <MapReduce
        {
          (/* no substs */) t.AnyTerm = (/* no substs */) t.AnyTerm;

          (e.Substs-B (e.Value ':' (s.Type e.Index)) e.Substs-E)
          (TkVariable s.Type e.Index)
            = (e.Substs-B e.Substs-E) e.Value;

          (e.Substs^) (Brackets e.Nested)
            = <Substitute (e.Substs) e.Nested> : (e.Substs^) e.Nested^
            = (e.Substs) (Brackets e.Nested);

          (e.Substs^) (ADT-Brackets (e.Name) e.Nested)
            = <Substitute (e.Substs) e.Nested> : (e.Substs^) e.Nested^
            = (e.Substs) (ADT-Brackets (e.Name) e.Nested);

          (e.Substs^) t.OtherTerm = (e.Substs) t.OtherTerm;
        }
        (e.Substs) e.Expr
      >;
}

/* Объединяет наборы подстановок по обобщению (по t.Var справа от ':') */
CollectSubsts {
  e.Before (/* подстановки закончились */) e.Other = /* пусто */;

  e.SubstsSet
    = <MapReduce
        {
          (e.PrevVals ':' e.PrevVar) ((e.Val ':' t.Var) e.OtherSubsts)
            = (e.PrevVals (e.Val) ':' t.Var) (e.OtherSubsts);
        }
        (/* Значения подстановок */ ':' /* Их обобщение */)
        e.SubstsSet
      >
    : (e.SubstsVals ':' t.Var) e.SubstsSet^
    = (e.SubstsVals ':' t.Var) <CollectSubsts e.SubstsSet>;
}


Subst-BuildImage {
  e.Substitution
    = <Map
        {
          (e.Value ':' ('e' e.Index))
            = (<BuildImage e.Value> ':' ('e' e.Index));
          (t.Value ':' (s.ST e.Index))
            = (<BuildImage-Term t.Value> ':' (s.ST e.Index));
        }
        e.Substitution
      >;
}

Subst-Generalization {
  ((t.Image1 ':' ('e' e.Index)) e.Images1)
  ((t.Image2 ':' ('e' e.Index)) e.Images2)
    = (<Generalization t.Image1 t.Image2> ':' ('e' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  ((t.Image1 ':' ('t' e.Index)) e.Images1)
  ((t.Image2 ':' ('t' e.Index)) e.Images2)
    = (<Generalization-Term t.Image1 t.Image2> ':' ('t' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  /* Они оба — или одинаковый символ, или безымянная s-переменная */
  ((t.Image ':' ('s' e.Index)) e.Images1)
  ((t.Image ':' ('s' e.Index)) e.Images2)
    = (t.Image ':' ('s' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  /* Разные символы или символ vs s-переменная — обобщаем */
  ((t.Image1 ':' ('s' e.Index)) e.Images1)
  ((t.Image2 ':' ('s' e.Index)) e.Images2)
    = ((TkVariable 's') ':' ('s' e.Index))
      <Subst-Generalization (e.Images1) (e.Images2)>;

  (/* пусто */) (/* пусто */) = /* пусто */;
}

Subst-Collapse {
  e.Substitution
    = <Map
        {
          (t.Image ':' ('e' e.Index)) = (<Collapse t.Image> ':' ('e' e.Index));
          (t.Image ':' ('t' e.Index)) = (<Collapse-Term t.Image> ':' ('t' e.Index));
          (t.Image ':' ('s' e.Index)) = (t.Image ':' ('s' e.Index));
        }
        e.Substitution
      >;
}
