//FROM LibraryEx
$EXTERN Map, MapReduce, Max, Fetch;

//FROM HighLevelRASL-Common
$EXTERN FoldOpenELoops, PutVariableDebugTable, GenResult;

//FROM HighLevelRASL-GenSubst-Save
$EXTERN GenInitSubst-Save, GenSubst-Save;


$ENTRY HighLevelRASL-Function-Disjoint {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ScopeClass (e.Name) e.Sentences

    = <Map
        {
          ((e.Pattern) (e.Result))

            // Построение начальной подстановки <F e.0>:
            // * подстановка на вход для s.FnGenSubst,
            // * последовательность команд для инициализации этой
            //   начальной подстановки.
            = <s.FnGenInitSubst 0 (e.Name) e.Pattern>
            : s.ContextTop e.Substitutes (e.FirstPatternCommands)

            // Преобразование подстановки e.0 → Pattern в последовательность
            // команд сопоставления и «размеченный образец», используемый
            // при построении результата (в общем случае).
            = <s.FnGenSubst
                s.ContextTop e.Substitutes (e.FirstPatternCommands)
              >
            : s.ContextOffset (e.PatternVars) (e.MarkedPattern)
              e.PatternCommands

            // Генерация команд построения результатного выражения
            = <s.FnGenResult
                s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.Result
              >
            : s.ContextCount e.ResultCommands

            // Если в образце есть команды-заголовки циклов удлинения
            // открытых переменных, группируем команды за ними в циклы.
            = <FoldOpenELoops
                (#CmdIssueMemory s.ContextCount)
                e.PatternCommands
                <PutVariableDebugTable e.PatternVars>
                e.ResultCommands
              >
            : e.Commands

            // Каждое предложение превращается в отдельную цепочку команд.
            // (Поэтому и disjoint.)
            = (e.Commands);

          ((e.Pattern) e.Conditions (e.Result))

            = <GenInitSubst-Save 0 (e.Name) e.Pattern>
            : s.ContextTop e.Substitutes (e.FirstPatternCommands)

            = (
                <GenResult
                  s.FnGenResult (e.Conditions) (e.Result)
                  <s.FnGenSubst
                    s.ContextTop e.Substitutes (e.FirstPatternCommands)
                  >
                >
              );
        }
        e.Sentences
      >
    : e.Sentences^ ((#CmdIssueMemory s.LastMemory) e.LastSentence)

    = <MapReduce
        {
          s.MaxMemory ((#CmdIssueMemory s.Memory) e.Sentence) =
            <Max s.MaxMemory s.Memory>
            (#CmdSentence e.Sentence);
        }
        s.LastMemory
        e.Sentences
      >
    : s.MaxMemory e.Sentences^

    = (#Function
        s.ScopeClass (e.Name)
        (#CmdIssueMemory s.MaxMemory)
        e.Sentences
        <Fetch
          e.LastSentence
          {
            e.Commands (#CmdOpenELoop e.OpenELoop) =
              e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);

            e.LastSentence^ = e.LastSentence;
          }
        >
      );
}
