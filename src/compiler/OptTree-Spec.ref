
*$FROM LibraryEx
$EXTERN MapAccum, Fetch, Pipe, Map, Inc;

*$FROM Desugaring-UnCondition
$EXTERN ExtractVariables, ExtractVariables-Expr, NewVarName;

*$FROM GenericMatch
$EXTERN GenericMatch;

/**
  <OptTree-Spec-ExtractOptInfo s.OptSpec e.AST>
    == (e.SpecInfo) e.AST^

  s.OptSpec ::= OptSpec | NoOpt
  e.SpecInfo ::= (e.SpecFuncNames) e.SpecInfo-Specific
  e.SpecFuncNames ::= (e.FuncName)*
  e.SpecInfo-Specific ::= t.FunctionInfo*
  t.FunctionInfo ::= ((e.Name) (e.Pattern) (e.Body) s.NextCounter)
*/
$ENTRY OptTree-Spec-ExtractOptInfo {
  s.OptSpec e.AST
    = <Fetch
        ((/* no names */) /* no info */) e.AST
        <Pipe
          (&MapAccum
            {
              ((e.Names) e.Info) (Spec t.Name e.Pattern)
                = ((e.Names t.Name) e.Info (t.Name (e.Pattern)));

              ((e.Names) e.Info) t.Other = ((e.Names) e.Info) t.Other;
            }
          )
          (&MapAccum
            {
              ((e.Names) e.Info-B (t.Name (e.Pattern)) e.Info-E)
              (Function s.ScopeClass t.Name Sentences e.Body)
                = ((e.Names) e.Info-B (t.Name (e.Pattern) (e.Body) 1) e.Info-E)
                  (Function s.ScopeClass t.Name Sentences e.Body);

               ((e.Names) e.Info) t.Other = ((e.Names) e.Info) t.Other;
            }
          )
        >
      >;
}

/**
  <OptTree-Spec s.OptSpec (e.SpecInfo) e.AST>
    == (e.SpecInfo^) e.AST^

  s.OptSpec ::= OptSpec | NoOpt
  e.SpecInfo ::= (e.SpecFuncNames) e.SpecInfo-Specific
  e.SpecFuncNames ::= (e.FuncName)*
  e.SpecInfo-Specific ::= t.FunctionInfo*
  t.FunctionInfo ::= ((e.Name) (e.Pattern) (e.Body) s.NextCounter t.Signature*)
  t.Signature ::= ((e.Name SUF '@' e.SpecFuncName) t.StaticVarVals*)
  t.StaticVarVals ::= (e.Expression)
*/
$ENTRY OptTree-Spec {
  NoOpt (e.SpecInfo) e.AST = (e.SpecInfo) e.AST;

  OptSpec ((/* no names */) /* no info */) e.AST
    = ((/* no names */) /* no info */) e.AST;

  OptSpec ((e.Names) e.SpecInfo) e.AST
    = <MapAccum &SpecUnit (e.SpecInfo (/* new functions */)) e.AST>
    : (e.SpecInfo^ (e.NewFunctions)) e.AST^
    = ((e.Names) e.SpecInfo) e.AST e.NewFunctions;
}

SpecUnit {
  (e.SpecInfo (e.NewFunctions))
  (Function s.ScopeClass t.Name Sentences e.Sentences)
    = <MapAccum
        &SpecSentence
        (e.SpecInfo (e.NewFunctions))
        e.Sentences
      >
    : (e.SpecInfo^ (e.NewFunctions^)) e.Sentences^
    = (e.SpecInfo (e.NewFunctions))
      (Function s.ScopeClass t.Name Sentences e.Sentences);

  (e.SpecInfo (e.NewFunctions)) t.Other = (e.SpecInfo (e.NewFunctions)) t.Other;
}

/**
  <SpecSentence (e.SpecInfo (e.NewFunctions)) t.Sentence
    == (e.SpecInfo^ (e.NewFunctions^) t.Sentence^

  t.Sentence ::= ((e.Pattern) e.Conditions (e.Result))

  Функция ищет в правой части предложения вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecSentence {
  (e.SpecInfo (e.NewFunctions))
  ((e.Pattern) e.Conditions (e.Result))
    = <MapAccum
        {
          (e.SpecInfo (e.NewFunctions))
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
            = <SpecResult (e.SpecInfo (e.NewFunctions)) e.ConditionResult>
            : (e.SpecInfo^ (e.NewFunctions^)) e.ConditionResult^
            = (e.SpecInfo (e.NewFunctions))
              (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern));
        }
        (e.SpecInfo (e.NewFunctions))
        e.Conditions
      >
    : (e.SpecInfo^ (e.NewFunctions^)) e.Conditions^
    = <SpecResult (e.SpecInfo (e.NewFunctions)) e.Result>
    : (e.SpecInfo^ (e.NewFunctions^)) e.Result^
    = (e.SpecInfo (e.NewFunctions)) ((e.Pattern) e.Conditions (e.Result));
}


/**
  <SpecResult (e.SpecInfo (e.NewFunctions)) e.Results>
    == (e.SpecInfo^ (e.NewFunctions^)) e.Result^

  Функция разбирает результирующее выражение, ищет в нем вызовы специализируемых
  функций и пытается выполнить специализацию для него
*/
SpecResult {
  (e.SpecInfo (e.NewFunctions)) /* empty */
    = (e.SpecInfo (e.NewFunctions)) /* empty */ ;

  (e.SpecInfo (e.NewFunctions)) e.Result
    = <MapAccum
        {
          (e.Info (e.NewFuncs)) t.Result-T
            = <SpecTerm (e.Info (e.NewFuncs)) t.Result-T>;
        }
        (e.SpecInfo (e.NewFunctions))
        e.Result
      >;
}

/**
  <SpecTerm (e.SpecInfo (e.NewFunctions)) t.Term>
    == (e.SpecInfo^ (e.NewFunctions^)) t.Term^

  Функция ищет в терме вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecTerm {
  (e.SpecInfo-B ((e.Name) e.Info) e.SpecInfo-E (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    , <IsColdArg e.Expression> : True
    = <SpecCall (e.Name) e.Info (e.Expression)>
    : (e.Info^) t.NewCall e.NewFunction
    = (e.SpecInfo-B ((e.Name) e.Info) e.SpecInfo-E (e.NewFunctions e.NewFunction))
      t.NewCall;

  (e.SpecInfo (e.NewFunctions)) (CallBrackets (Symbol Name e.Name) e.Expression)
    = <SpecResult (e.SpecInfo (e.NewFunctions)) e.Expression>
    : (e.SpecInfo^ (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.NewFunctions)) (CallBrackets (Symbol Name e.Name) e.Expression);

  (e.SpecInfo (e.NewFunctions)) (ClosureBrackects e.ClosureContent)
    = <SpecResult (e.SpecInfo (e.NewFunctions)) e.ClosureContent>
    : (e.SpecInfo^ (e.NewFunctions^)) e.ClosureContent^
    = (e.SpecInfo (e.NewFunctions)) (ClosureBrackets e.ClosureContent);

  (e.SpecInfo (e.NewFunctions)) (Brackets e.Expression)
    = <SpecResult (e.SpecInfo (e.NewFunctions)) e.Expression>
    : (e.SpecInfo^ (e.NewFunctions^)) e.Expresssion^
    = (e.SpecInfo (e.NewFunctions)) (Brackets e.Expression);

  (e.SpecInfo (e.NewFunctions)) (ADT-Brackets (e.Name) e.Expression)
    = <SpecResult (e.SpecInfo (e.NewFunctions)) e.Expression>
    : (e.SpecInfo^ (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.NewFunctions)) (ADT-Brackets (e.Name) e.Expression);

  (e.SpecInfo (e.NewFunctions)) t.Other
   = (e.SpecInfo (e.NewFunctions)) t.Other;
}

/**
  <SpecCall (e.Name) (e.SpecPattern) (e.Body)
    s.CurrentNumber e.Signatures (e.Argument)
  >
    == ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures t.NewSignature)
        t.NewCall t.NewFunction

  Функция пытается выполнить специализацию для заданного вызова:
  # ищет среди сигнатур готовых специализированных функций похожую
    * если сигнатура найдена, заменяем исходный вызов на вызов найденной функции
    * если сигнатура не найдена выполняем специализацию для аргументов вызова
      # формируем новый вызов
      # формируем определение новой специализированной функции
  # возвращает e.Info с новой сигнатурой,
    новый вызов
    определение новой специализированной функции
*/
SpecCall {
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures (e.Argument)
    = <GenericMatch (e.Argument) (e.SpecPattern)>
    : {
        Clear e.GenericMatches
          = <Spec-PrepareSignature e.GenericMatches>
          : e.Signature

          = <Spec-IsTrivialSignature e.Signature>
          : {
              True
                = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
                  (ColdCallBrackets (Symbol Name e.Name) e.Argument)
                  /* no new functions */;

              False
                = <Spec-PrepareNewCall (e.SpecPattern) e.GenericMatches>
                : (e.SpecializedFuncArgument)

                = <Spec-FindInSignatures (e.Signature) e.Signatures>
                : {
                    Found e.SpecSuffix
                      = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
                        (
                          ColdCallBrackets (Symbol Name e.Name SUF e.SpecSuffix)
                          e.SpecializedFuncArgument
                        )
                        /* no new functions */;

                    NotFound
                      = <Spec-RenameGenericMatch
                          (e.SpecPattern) (e.GenericMatches) s.NextNumber
                          (<ExtractVariables e.Body>)
                        >
                      : (e.RenamedGenericMatches)

                      = <Spec-PrepareSpecializedFuncBody
                          (e.SpecPattern) (e.RenamedGenericMatches) e.Body
                        >
                      : (e.SpecializedFuncBody)

                      = (
                          (e.SpecPattern) (e.Body) <Inc s.NextNumber>
                          e.Signatures ((e.Name SUF '@' s.NextNumber) e.Signature)
                        )
                        (
                          ColdCallBrackets (Symbol Name e.Name SUF '@' s.NextNumber)
                          e.SpecializedFuncArgument
                        )
                        (
                          Function GN-Local (e.Name SUF '@' s.NextNumber)
                          Sentences e.SpecializedFuncBody
                        );
                  };
            };

        s.OtherResult e.ResultInfo
          = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
            (ColdCallBrackets (Symbol Name e.Name) e.Argument)
            /* no new functions */;
      }
}

Spec-PrepareSignature {
  e.GenericSpecFactMatches
    = <Spec-RenameSignatureVars
        <MapAccum
          {
            (e.Signature) (e.Val ':' t.Var)
              = <IsSpecStaticVar t.Var>
              : {
                  True = (e.Signature (e.Val));

                  False = (e.Signature);
                };
          }
          (/* empty signature */)
          e.GenericSpecFactMatches
        >
      >;
}

Spec-RenameSignatureVars {
  (e.Signature)
    = <Map
        {
          (e.SignaturePart) = <ExtractVariables-Expr e.SignaturePart>;
        }
        e.Signature
      >
    : e.VarsFromSignature
    = <MapAccum
        {
          (
            (e.Renames-B (e.Index ':' e.NewIndex) e.Renames-E)
            (e.UsedVars) e.NSignature
          )
          (e.Index)
            = (
                (e.Renames-B (e.Index ':' e.NewIndex) e.Renames-E) (e.UsedVars)
                <FindReplace-ExprList
                  (e.NSignature) ((TkVariable e.Index)) (TkVariable e.NewIndex)
                >
              );

          ((e.Renames) (e.UsedVars) e.NSignature) ('s' e.Index s.Depth)
            = <NewVarName (e.UsedVars) 'sS' s.Depth (/* empty suffix */)>
            : (e.UsedVars^) e.NewIndex
            = (
                (e.Renames ('s' e.Index s.Depth ':' e.NewIndex)) (e.UsedVars)
                <FindReplace-ExprList
                  (e.NSignature) ((TkVariable 's' e.Index s.Depth))
                  (TkVariable e.NewIndex)
                >
              );

          ((e.Renames) (e.UsedVars) e.NSignature) ('t' e.Index s.Depth)
            = <NewVarName (e.UsedVars) 'tT' s.Depth (/* empty suffix */)>
            : (e.UsedVars^) e.NewIndex
            = (
                (e.Renames ('t' e.Index s.Depth ':' e.NewIndex)) (e.UsedVars)
                <FindReplace-ExprList
                  (e.NSignature) ((TkVariable 't' e.Index s.Depth))
                  (TkVariable e.NewIndex)
                >
              );

          ((e.Renames) (e.UsedVars) e.NSignature) ('e' e.Index s.Depth)
            = <NewVarName (e.UsedVars) 'eE' s.Depth (/* empty suffix */)>
            : (e.UsedVars^) e.NewIndex
            = (
                (e.Renames ('e' e.Index s.Depth ':' e.NewIndex)) (e.UsedVars)
                <FindReplace-ExprList
                  (e.NSignature) ((TkVariable 'e' e.Index s.Depth))
                  (TkVariable e.NewIndex)
                >
              );
        }
        ((/* renames pair */) (e.VarsFromSignature) e.Signature)
        e.VarsFromSignature
      >
    : (t.Renames t.UsedVars e.NnSignature)
    = e.NnSignature;
}

Spec-FindInSignatures {
  (e.Signature)
  e.Signatures-B ((e.Name SUF e.SpecSuffix) e.Signature) e.Signatures-E
    = Found e.SpecSuffix;

  (e.Signature) e.Signatures
    = NotFound;
}

/**
  <Spec-IsTrivialSignature e.Signature>

  e.Signature ::= (e.Expression)*
*/
Spec-IsTrivialSignature {
  e.Signature
    = <MapAccum
        {
          False t.Any = False;

          True ((TkVariable e.VarName)) = True;

          True t.OtherExpression = False;
        }
        True
        e.Signature
      >;
}

Spec-PrepareNewCall {
  (e.SpecPattern) e.GenericArgSpecMatches
    = <MapAccum
        {
          t.Pattern (e.Val ':' (e.Var))
          = <IsSpecStaticVar (e.Var)>
          : {
              True
                = (
                    <FindReplace-Expr
                      t.Pattern ((TkVariable e.Var))
                      <WrapEVar
                        <FindAndFormatVarTerm <ExtractVariables-Expr e.Val>>
                      >
                    >
                  );

              False
                = (<FindReplace-Expr t.Pattern ((TkVariable e.Var)) e.Val>);
            };
        }
        (e.SpecPattern)
        e.GenericArgSpecMatches
      >;
}

Spec-RenameGenericMatch {
  (e.SpecPattern) (e.GenericArgSpecMatches) s.NextNumber (e.VarsFromBody)
    = <MapAccum
        {
          (e.VarsFromMatch) (e.Val ':' t.Var)
            = <IsSpecStaticVar t.Var>
            : {
                True = (e.VarsFromMatch <ExtractVariables-Expr e.Val>);

                False = (e.VarsFromMatch);
              };
        }
        ()
        e.GenericArgSpecMatches
      >
    : (e.VarsFromMatch)

    = <MapAccum
        {
          (e.GenericMatches)
          (e.OldVarName)
            = <NewVarName (e.VarsFromBody) e.OldVarName (/* empty suffix */)>
            : (e.Vars) e.NewVarName
            = (
                <Map
                  {
                    (e.Val ':' t.Var)
                      = <IsSpecStaticVar t.Var>
                      : {
                          True
                            = (
                                <FindReplace-Expr
                                  (e.Val) ((TkVariable e.OldVarName))
                                  (TkVariable e.NewVarName)
                                >
                                ':' t.Var
                              );

                          False = (e.Val ':' t.Var);
                        };
                  }
                  e.GenericMatches
                >
              );
        }
        (e.GenericArgSpecMatches)
        e.VarsFromMatch
      >;
}

Spec-PrepareSpecializedFuncBody {
  (e.SpecPattern) (e.RenamedGenericSpecFactMatches) e.Body
    = <MapAccum
        {
          (e.PreparedBody) ((e.SentencePattern) e.Conditions (e.SentenceResult))
            = <GenericMatch (e.SentencePattern) (e.SpecPattern)>
            : Clear e.GenericSpecSentenceMatches
            = <MapGenericMatches
                (e.RenamedGenericSpecFactMatches) (e.GenericSpecSentenceMatches)
              >
            : e.Substitutions
            = (
                e.PreparedBody
                (
                  (<Spec-PreparePattern (e.Substitutions) e.SentencePattern>)
                  <Spec-PrepareConditions (e.Substitutions) e.Conditions>
                  (<Spec-PrepareResult (e.Substitutions) e.SentenceResult>)
                )
              );
        }
        (/* for result */)
        e.Body
      >;
}

Spec-PreparePattern {
  (e.Substitutions) e.Pattern
    = <MapAccum
        {
          (e.Pattern) (e.ReplaceToVal ':' t.ReplaceVar)
            = (
                <FindReplace-Expr
                  (e.Pattern) (t.ReplaceVar)
                  <WrapEVar <ExtractVariables-Expr e.ReplaceToVal>>
                >
              );
        }
        (e.Pattern)
        e.Substitutions
      >
    : (e.Pattern^)
    = <FindAndFormatVarTerm e.Pattern>;
}

Spec-PrepareConditions {
  (e.Substitutions) e.Conditions
    = <MapAccum
        {
          (e.Substitutions)
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
            = (
                Condition (e.Name)
                (<Spec-PrepareResult (e.Substitutions) e.ConditionResult>)
                (<Spec-PreparePattern (e.Substitutions) e.ConditionPattern>)
              );
        }
        (e.Substitutions)
        e.Conditions
      >
    : (e.Substitutions) e.Conditions^
    = e.Conditions;
}

Spec-PrepareResult {
  (e.Substitutions) e.Result
    = <MapAccum
        {
          (e.Result) (e.Val ':' e.Val) = (e.Result);

          (e.Result) (e.ReplaceToVal ':' t.ReplaceVar)
            = (<FindReplace-Expr (e.Result) (t.ReplaceVar) e.ReplaceToVal>);
        }
        (e.Result)
        e.Substitutions
      >
    : (e.Result^)
    = e.Result;
}

/**
  <OptTree-Spec-Finalize s.OptSpec (e.SpecInfo) e.AST> == e.AST^
*/
$ENTRY OptTree-Spec-Finalize {
  s.OptSpec (e.SpecInfo) e.AST
    = e.AST;
}

/*
  Вспомогательные функции модуля
*/

SVarIsInSet {
  (e.Set-B s.Var e.Set-E) s.Var = True;

  (e.Set) s.Var = False;
}

IsSpecStaticVar {
  (s.Mode s.FirstSymbol e.Index s.Depth)
    = <SVarIsInSet ('ABCDEFGHIJKLMNOPQRSTUVWXYZ') s.FirstSymbol>;
}

WrapEVar {
  (TkVariable 'e' e.Index) e.Tail
    = (Brackets (TkVariable 'e' e.Index)) <WrapEVar e.Tail>;

  ('e' e.Index) e.Tail  = (Brackets ('e' e.Index)) <WrapEVar e.Tail>;

  t.Other e.Tail = t.Other <WrapEVar e.Tail>;

  /* empty */ = /* empty */;
}

IsColdArg {
  e.Argument
   = <MapAccum
       {
         False t.Any = False;

         True (CallBrackets e.Expression) = False;

         True (ClosureBrackects e.ClosureContent) = <IsColdArg e.ClosureContent>;

         True (Brackets e.Expression) = <IsColdArg e.Expression>;

         True (ADT-Brackets (e.Name) e.Expression) = <IsColdArg e.Expression>;

         True t.Other = True;

       }
       True
       e.Argument
     >;
}

FindAndFormatVarTerm {
  e.Expr = <Map &FindAndFormatVarTerm-Aux e.Expr>;
}

FindAndFormatVarTerm-Aux {
  (TkVariable e.Index) = (TkVariable e.Index);

  ('e' e.Index) = (TkVariable 'e' e.Index);

  ('s' e.Index) = (TkVariable 's' e.Index);

  ('t' e.Index) = (TkVariable 't' e.Index);

  (Symbol e.SymInfo) = (Symbol e.SymInfo);

  (Brackets e.Expression) = (Brackets <FindAndFormatVarTerm e.Expression>);

  (ADT-Brackets (e.Name) e.Expression)
    = (ADT-Brackets (e.Name) <FindAndFormatVarTerm e.Expression>);

  (CallBrackets e.Expression)
     = (CallBrackets <FindAndFormatVarTerm e.Expression>);

  (ColdCallBrackets e.Expression)
     = (ColdCallBrackets <FindAndFormatVarTerm e.Expression>);

  (ClosureBrackets e.ClosureContent)
    = (ClosureBrackets <FindAndFormatVarTerm e.ClosureContent>);
}

MapGenericMatches {
  (e.GenericSpecFactMatches) (e.GenericSpecSentenceMatches)
    = <MapAccum
        {
          (
            (
              e.GenericSpecFactMatches-B (e.FactVal ':' t.SpecVar)
              e.GenericSpecFactMatches-E
            )
            (e.MappedMatches)
          )
          (e.SentenceVal ':' t.SpecVar)
            , <IsSpecStaticVar t.SpecVar>
            : True
            = (
                (
                  e.GenericSpecFactMatches-B (e.FactVal ':' t.SpecVar)
                  e.GenericSpecFactMatches-E
                )
                (e.MappedMatches (e.FactVal ':' e.SentenceVal))
              );

          ((e.GenericSpecFactMatches) (e.MappedMatches))
          (e.SentenceVal ':' t.SpecVar)
            = ((e.GenericSpecFactMatches) (e.MappedMatches));
        }
        ((e.GenericSpecFactMatches) (/* for result */))
        e.GenericSpecSentenceMatches
      >
    : ((e.GenericSpecFactMatches) (e.ResultMatches))
    = e.ResultMatches;
}

/**
  <FindReplace-Expr (e.LookAtExprList) (e.LookFor) e.ReplaceVal>

  e.LookAtExprList ::= (e.Expression)*
*/
FindReplace-ExprList {
  (e.LookAtExprList) (e.LookFor) e.ReplaceVal
    = <Map
        {
          (e.LookAt) = (<FindReplace-Expr (e.LookAt) (e.LookFor) e.ReplaceVal>);
        }
        e.LookAtExprList
      >;
}

/**
  <FindReplace-Expr (e.LookAt) (e.LookFor) e.ReplaceVal>

  e.LookAt ::= e.Expression
*/
FindReplace-Expr {
  (/* empty */) (e.LookFor) e.ReplaceVal = /* empty */;

  (e.LookAt) (/* empty */) e.ReplaceVal = e.LookAt;

  (e.LookAt) (e.LookAt) e.ReplaceVal = e.ReplaceVal;

  ((Symbol e.SymInfo)) (e.LookFor) e.ReplaceVal = (Symbol e.SymInfo);

  ((Brackets e.Expression)) (e.LookFor) e.ReplaceVal
    = (Brackets <FindReplace-Expr (e.Expression) (e.LookFor) e.ReplaceVal>);

  ((ADT-Brackets (e.Name) e.Expression)) (e.LookFor) e.ReplaceVal
    = (
        ADT-Brackets (e.Name)
        <FindReplace-Expr (e.Expression) (e.LookFor) e.ReplaceVal>
      );

  ((CallBrackets e.Expression)) (e.LookFor) e.ReplaceVal
    = (CallBrackets <FindReplace-Expr (e.Expression) (e.LookFor) e.ReplaceVal>);

  ((TkVariable e.Index)) (e.LookFor) e.ReplaceVal = (TkVariable e.Index);

  ((ClosureBrackets e.ClosureContent)) (e.LookFor) e.ReplaceVal
    = (
        ClosureBrackets
        <FindReplace-Expr (e.ClosureContent) (e.LookFor) e.ReplaceVal>
      );

  (e.LookAt-B e.LookFor e.LookAt-E) (e.LookFor) e.ReplaceVal
    = <FindReplace-Expr (e.LookAt-B) (e.LookFor) e.ReplaceVal>
      e.ReplaceVal <FindReplace-Expr (e.LookAt-E) (e.LookFor) e.ReplaceVal>;

  (e.LookAt) (e.LookFor) e.ReplaceVal
    = <MapAccum
        {
          ((e.LookFor) e.ReplaceVal) t.LookAt-Term
            = ((e.LookFor) e.ReplaceVal)
              <FindReplace-Expr (t.LookAt-Term) (e.LookFor) e.ReplaceVal>;
        }
        ((e.LookFor) e.ReplaceVal)
        e.LookAt
      >
    : ((e.LookFor) e.ReplaceVal) e.ModifyedLookAt
    = e.ModifyedLookAt;
}
