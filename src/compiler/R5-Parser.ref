*$CLASSIC;
* ^--- remove after update stable version

/**
  <R5-Parse s.Mode e.Tokens>
    == (t.Error*) t.Unit*

  s.Mode ::= Classic | Extended

  t.Error ::= (t.Pos e.Message)
  t.Unit ::= t.Function | t.Extern | t.SingleDeclaration | t.Include
    | t.NativeBlock
  t.Extern ::= (Declaration t.Pos GN-Entry e.Name)
  t.SingleDeclaration ::= (s.SingleDeclarationTag t.Pos s.ScopeClass e.Name)
  s.SingleDeclarationTag ::= Enum | Swap
  t.Include ::= (Include t.Pos e.Name)
  t.NativeBlock ::= (NativeBlock t.Pos e.Code)

  t.Function ::= (Function t.SrcPos s.ScopeClass (e.Name) e.Body)
  e.Body ::= Sentences t.Sentence* | NativeBody t.Pos e.Code
  s.ScopeClass ::= GN-Entry | GN-Local
  t.Sentence ::=
    (t.Pattern (s.Chain t.Result (e.Blocks) t.Pattern)* e.SentenceTail)
  s.Chain ::= Condition | Assign
  e.SentenceTail ::= t.Result (e.Blocks)
  e.Blocks ::= (e.Body)*
  e.Code ::= (s.Char*)*

  t.Pattern, t.Result ::= (t.Term*)
  t.Term ::=
      (TkIdentifier s.Char*)
    | (TkNumber s.Number)
    | (TkChar s.Char)
    | (TkVariable t.SrcPos s.VarType e.Index)
    | (Brackets t.Term*)
    | (CallBrackets (TkName t.SrcPos e.Function)? t.Term*)
    | (TkName t.SrcPos s.Char*)
    | (Closure Sentences t.Sentence*)
    | (TkNewVariable t.SrcPos s.VarType e.Index)
    | (ADT-Brackets t.SrcPos (e.ADT-Name) t.Term*)
  e.ADT-Name ::= s.CHAR* | UnnamedADT
  s.VarType ::= 's' | 't' | 'e'
*/
$ENTRY R5-Parse {
  s.Mode e.Tokens = <FilterErrors <Program s.Mode e.Tokens>>;
}

FilterErrors {
  e.UnitsAndErrors
    = <DoFilterErrors (/* errors */) (/* units */) e.UnitsAndErrors>;
}

DoFilterErrors {
  (e.Errors) (e.Units) e.Units-B (Error t.Pos e.Message) e.UnitsAndErrors-E
    = <DoFilterErrors
        (e.Errors (t.Pos e.Message)) (e.Units e.Units-B) e.UnitsAndErrors-E
      >;

  (e.Errors) (e.Units) t.Unit e.UnitsAndErrors
    = <DoFilterErrors (e.Errors) (e.Units t.Unit) e.UnitsAndErrors>;

  (e.Errors) (e.Units) /* пусто */ = (e.Errors) e.Units;
}

/*
  Program = Unit* EOF.

  <Program s.Mode e.Tokens> == t.ErrorUnit*

  t.ErrorUnit ::= (Error t.Pos e.Message) | t.Unit
*/
Program {
  s.Mode t.NextToken e.Tokens,
      t.NextToken: (s.Type t.Pos e.Value),
      <OneOf s.Type <UnitStartToken>>: True =
    <Program-AfterUnit s.Mode <Unit s.Mode t.NextToken e.Tokens>>;

  s.Mode (TkRefal5Mode t.Pos s.NewMode) e.Tokens
    = <Program s.NewMode e.Tokens>;

  s.Mode (TkEOF t.Pos) = /* всё */;

  s.Mode t.Unexpected e.Tokens,
      t.Unexpected: (s.Type t.Pos e.Value) =
    <UnexpectedToken
      t.Unexpected '$EXTERN, $ENTRY, function name or special comment'
    >
    <Program s.Mode e.Tokens>;
}

UnitStartToken {
  = <NameListTags> TkEntry TkName TkSemicolon TkInclude TkNativeCode;
}

NameListTags {
  = TkExtern TkEnum TkEEnum TkSwap TkESwap;
}

OneOf {
  t.Elem e.Elems-B t.Elem e.Elems-E = True;
  t.Elem e.Elems = False;
}

Program-AfterUnit {
  s.Mode (e.ErrorsUnits) e.Tokens = e.ErrorsUnits <Program s.Mode e.Tokens>;
}

/*
  Unit = SPECIAL-COMMENT | Keyword NameList | Include | Function.
  Keyword = "$EXTERN" | "$ENUM" | "$EENUM" | "$SWAP" | "$ESWAP".

  <Unit s.Mode e.Tokens> == (t.ErrorUnit*) e.Tokens
*/
Unit {
  s.Mode t.NextToken e.Tokens,
      t.NextToken:
    {
      (TkExtern t.Pos) = <NameList TkExtern e.Tokens>;

      (s.Tag t.Pos)
        , <OneOf s.Tag <NameListTags>> : True
        , <NameList s.Tag e.Tokens>
        : {
            (e.ErrorsAndUnits) e.Tokens1 /*^*/
              = (
                  <ClassicError s.Mode t.Pos <TokName s.Tag> ' is a extension'>
                  e.ErrorsAndUnits
                )
                e.Tokens1;
          };

      (TkInclude t.Pos) = <Include s.Mode t.Pos e.Tokens>;

      (TkNativeCode t.Pos e.Lines) = ((NativeBlock t.Pos e.Lines)) e.Tokens;

      (TkSemicolon t.Pos) = (/* игнорируем */) e.Tokens;

      (s.Type t.Pos e.Value)
        , <OneOf s.Type TkEntry TkName>: True
        = <Function s.Mode t.NextToken e.Tokens>;

      /* других типов быть не должно */
    }
}

/*
  NameList = NAME { "," NAME } ";".

  <NameList s.Tag e.Tokens> == (t.ErrorUnit*) e.Tokens
*/
NameList {
  s.Tag (TkName t.Pos e.Name) e.Tokens
    = <NameList-DoNames
        s.Tag
        (<Mu s.Tag t.Pos e.Name> /* externs and errors */)
        e.Tokens
      >;

  s.Tag (TkRefal5Mode t.Pos s.Mode) e.Tokens = <NameList s.Tag e.Tokens>;

  s.Tag t.NextToken e.Tokens
    , t.NextToken : (s.Type t.Pos e.Value)
    = ((Error t.Pos 'expected function name after ' <TokName s.Tag > ' keyword'))
      t.NextToken e.Tokens;
}

TkExtern {
  t.Pos e.Name = (Declaration t.Pos GN-Entry e.Name);
}

TkEnum {
  t.Pos e.Name = (Enum t.Pos GN-Local e.Name);
}

TkEEnum {
  t.Pos e.Name = (Enum t.Pos GN-Entry e.Name);
}

TkSwap {
  t.Pos e.Name = (Swap t.Pos GN-Local e.Name);
}

TkESwap {
  t.Pos e.Name = (Swap t.Pos GN-Entry e.Name);
}

NameList-DoNames {
  s.Tag (e.ExternsAndErrors)
  (TkRefal5Mode t.Pos s.Mode) e.Tokens
    = <NameList-DoNames s.Tag (e.ExternsAndErrors) e.Tokens>;

  s.Tag (e.ExternsAndErrors)
  (TkComma t.CommaPos) (TkRefal5Mode t.ModePos s.Mode) e.Tokens
    = <NameList-DoNames
        s.Tag (e.ExternsAndErrors) (TkComma t.CommaPos) e.Tokens
      >;

  s.Tag (e.ExternsAndErrors)
  (TkComma t.CommaPos) (TkName t.NamePos e.Name) e.Tokens
    = <NameList-DoNames
        s.Tag (e.ExternsAndErrors <Mu s.Tag t.NamePos e.Name>) e.Tokens
      >;

  s.Tag (e.ExternsAndErrors) (TkSemicolon t.Pos) e.Tokens =
    (e.ExternsAndErrors) e.Tokens;

  s.Tag (e.ExternsAndErrors) (TkComma t.Pos) e.Tokens
    = <NameList-DoNames
        s.Tag (e.ExternsAndErrors (Error t.Pos 'expected name after comma'))
        e.Tokens
      >;

  s.Tag (e.ExternsAndErrors)
  (TkName t.NamePos e.Name) (TkOpenBlock t.BracketPos) e.Tokens
    = (
        e.ExternsAndErrors
        (Error t.NamePos 'missed semicolon after previous $EXTERN declaration')
      )
      (TkName t.NamePos e.Name) (TkOpenBlock t.BracketPos) e.Tokens;

  s.Tag (e.ExternsAndErrors) (TkName t.Pos e.Name) e.Tokens
    = <NameList-DoNames
        s.Tag
        (e.ExternsAndErrors (Error t.Pos 'missed comma after external name'))
        e.Tokens
      >;

  s.Tag (e.ExternsAndErrors) t.NextToken e.Tokens,
      t.NextToken: (s.Type t.Pos e.Value),
      <OneOf s.Type TkExtern TkEntry TkEOF>: True =
    (
      e.ExternsAndErrors
      (Error t.Pos 'missed semicolon')
    )
    t.NextToken e.Tokens;

  s.Tag (e.ExternsAndErrors) t.NextToken e.Tokens
    = <NameList-DoNames
        s.Tag
        (e.ExternsAndErrors <UnexpectedToken t.NextToken 'comma or semicolon'>)
        e.Tokens
      >;
}

/*
  Include = "$INCLUDE" Compound ";".

  <Include s.Mode t.IncludePos e.Tokens> == (e.Errors t.IncludeUnit?) e.Tokens
*/
Include {
  s.Mode t.Pos t.Token1 t.Token2 e.Tokens
    , <ClassicError s.Mode t.Pos '$INCLUDE is extension'> : e.MaybeError
    , t.Token1 t.Token2
    : {
        (TkCompound t.FilePos e.FileName) (TkSemicolon t.SemicolonPos)
          = (e.MaybeError (Include t.FilePos e.FileName)) e.Tokens;

        (TkCompound t.FilePos e.FileName) t.Unexpected
          = (
              e.MaybeError
              <UnexpectedToken t.Unexpected '\';\''>
              (Include t.FilePos e.FileName)
            )
            t.Unexpected e.Tokens;

        t.Unexpected1 t.Unexpected2
          = (e.MaybeError <UnexpectedToken t.Unexpected1 'compound symbol'>)
            t.Unexpected1 t.Unexpected2 e.Tokens;
      };
}

/*
  Function = ["$ENTRY"] NAME Block.

  <Function s.Mode e.Tokens> == (e.Errors t.FunctionUnit) e.Tokens
*/
Function {
  s.Mode (TkEntry t.EntryPos) (TkName t.NamePos e.Name) e.Tokens =
    <Function-AfterBlock
      t.EntryPos (e.Name) GN-Entry <Block s.Mode e.Tokens>
    >;

  s.Mode (TkName t.Pos e.Name) e.Tokens =
    <Function-AfterBlock
      t.Pos (e.Name) GN-Local <Block s.Mode e.Tokens>
    >;

  s.Mode (TkEntry t.EntryPos) (TkRefal5Mode t.ModePos s.NewMode) e.Tokens
    = <Function s.NewMode (TkEntry t.EntryPos) e.Tokens>;

  s.Mode (TkEntry t.Pos) e.Tokens =
    ((Error t.Pos '$ENTRY without function name, skipped'))
    e.Tokens;
}

Function-AfterBlock {
  t.Pos (e.Name) s.Scope (e.Errors) (e.Body) e.Tokens =
    (e.Errors (Function t.Pos s.Scope (e.Name) e.Body))
    e.Tokens;
}


/*
  Block =
      "{" Sentence { ";" Sentence } [";"] "}"
    | "{" NATIVE-CODE "}".

  <Block s.Mode e.Tokens> == (e.Errors) (e.Body) e.Tokens
*/
Block {
  s.Mode (TkOpenBlock t.OpenPos) (TkCloseBlock t.ClosePos) e.Tokens
    = (<ClassicError s.Mode t.OpenPos 'Empty function block'>)
      (Sentences /* no sentences */) e.Tokens;

  s.Mode
  (TkOpenBlock t.OpenPos)
  (TkNativeCode t.NativePos e.Code)
  t.CloseBlock
  e.Tokens
    , <IsCloseBlock t.CloseBlock> : (e.Error) e.NextToken
    = (
        <ClassicError
          s.Mode t.NativePos 'Native code insertion is an extension'
        >
        e.Error
      )
      (NativeBody t.NativePos e.Code) e.NextToken e.Tokens;

  s.Mode (TkOpenBlock t.Pos) e.Tokens =
    <Block-AfterSentence
      s.Mode (/* errors */) (/* sentences */)
      <Sentence s.Mode e.Tokens>
    >;

  s.Mode (TkRefal5Mode t.Pos s.NewMode) e.Tokens
    = <Block s.NewMode e.Tokens>;

  s.Mode t.Unexpected e.Tokens =
    (<UnexpectedToken t.Unexpected '\'{\''>)
    (/* no sentences */)
    t.Unexpected e.Tokens;
}

IsCloseBlock {
  (TkCloseBlock t.Pos) = (/* no error */) /* no token */;
  t.Unexpected = (<UnexpectedToken t.Unexpected '\'}\''>) t.Unexpected;
}

Block-AfterSentence {
  s.Mode (e.Errors) (e.Sentences)
  (e.SentenceErrors) t.NextSentence
  t.Token1 t.Token2 e.Tokens,
      t.Token1 t.Token2:
    {
      (TkSemicolon t.SemicolonPos) (TkRefal5Mode t.ModePos s.NewMode)
        = <Block-AfterSentence
            s.NewMode (e.Errors) (e.Sentences)
            (e.SentenceErrors) t.NextSentence
            (TkSemicolon t.SemicolonPos) e.Tokens
          >;

      (TkRefal5Mode t.Pos s.NewMode) t.Token2_
        = <Block-AfterSentence
            s.NewMode (e.Errors) (e.Sentences)
            (e.SentenceErrors) t.NextSentence
            t.Token2_ e.Tokens
          >;

      (TkSemicolon t.Pos1) (TkCloseBlock t.Pos2)
        = (e.Errors e.SentenceErrors)
          (Sentences e.Sentences t.NextSentence)
          e.Tokens;

      (TkCloseBlock t.Pos) t.Token2
        = (e.Errors e.SentenceErrors)
          (Sentences e.Sentences t.NextSentence)
          t.Token2 e.Tokens;

      (TkSemicolon t.Pos) t.Token2 =
        <Block-AfterSentence
          s.Mode (e.Errors e.SentenceErrors)
          (e.Sentences t.NextSentence)
          <Sentence s.Mode t.Token2 e.Tokens>
        >;

      t.Token1 t.Token2 =
        <Block-AfterSentence
          s.Mode
          (
            e.Errors e.SentenceErrors
            <UnexpectedToken t.Token1 '\';\' or \'}\', skipped'>
          )
          (e.Sentences t.NextSentence)
          <Sentence s.Mode t.Token2 e.Tokens>
        >
    };

  s.Mode (e.Errors) (e.Sentences)
  (e.SentenceErrors) t.NextSentence
  (TkEOF t.Pos)
    = (
        e.Errors e.SentenceErrors
        <UnexpectedToken (TkEOF t.Pos) '\';\' or \'}\''>
      )
      (Sentences e.Sentences t.NextSentence)
      (TkEOF t.Pos);
}


/*
  Sentence = SentencePart SentenceTail.
  SentencePart = Pattern ("=" | ",") Result.
  SentenceTail = ":" SentencePart SentenceTail | empty.

  <Sentence s.Mode e.Tokens> == (e.Errors) t.Sentence e.Tokens
*/
Sentence {
  s.Mode (TkRefal5Mode t.Pos s.NewMode) e.Tokens
    = <Sentence s.NewMode e.Tokens>;

   s.Mode e.Tokens
     = <SentenceTail s.Mode <SentencePart s.Mode e.Tokens>>
}

SentenceTail {
  s.Mode (e.Errors) t.Pattern s.PartType t.Pos t.Result (e.Blocks)
  t.NextToken e.Tokens
    , t.NextToken
    : {
        (TkColon t.ColonPos)
          = <SentenceTail-AfterTail
              s.Mode (e.Errors) t.Pattern s.PartType t.Pos t.Result (e.Blocks)
              <SentenceTail s.Mode <SentencePart s.Mode e.Tokens>>
            >;

        t.Other
          , <CheckSentenceEnd s.Mode s.PartType t.Pos e.Blocks>
          : (e.EndErrors) e.Blocks1
          = (e.Errors e.EndErrors)
            (t.Pattern /* no conditions and assignments */ t.Result (e.Blocks1))
            t.Other e.Tokens;
      }
}

SentenceTail-AfterTail {
  s.Mode (e.Errors)
  t.FirstPattern s.PartType t.Pos t.FirstResult (e.FirstBlocks)
  (e.TailErrors)
  (t.NextPattern e.ConditionsAndAssignments t.LastResult (e.LastBlocks))
  e.Tokens
    , <CheckExceedBlocks s.Mode e.FirstBlocks>
    : (e.ExceedBlocksErrors) e.FirstBlocks1
    = (
        e.Errors
        <AssignmentError s.Mode s.PartType t.Pos>
        e.ExceedBlocksErrors
        e.TailErrors
      )
      (
        t.FirstPattern
        (s.PartType t.FirstResult (e.FirstBlocks1) t.NextPattern)
        e.ConditionsAndAssignments t.LastResult (e.LastBlocks)
      )
      e.Tokens;
}

CheckExceedBlocks {
  s.Mode e.ExceedBlocks = <DoCheckExceedBlocks s.Mode () () e.ExceedBlocks>;
}

DoCheckExceedBlocks {
  s.Mode (e.Errors) (e.ScannedBlocks) (t.Pos e.Body) e.RestBlocks
    = <DoCheckExceedBlocks
        s.Mode
        (e.Errors <ClassicError s.Mode t.Pos 'Exceed block in this position'>)
        (e.ScannedBlocks (e.Body))
        e.RestBlocks
      >;

  s.Mode (e.Errors) (e.ScannedBlocks) /* empty */ = (e.Errors) e.ScannedBlocks;
}

AssignmentError {
  Classic Assign t.Pos
    = (Error t.Pos 'Assignment not supported in classic mode');

  s.Mode s.Type t.Pos = /* no error */;
}

CheckSentenceEnd {
  s.Mode s.PartType t.Pos (t.BodyPos e.Body) e.ExceedBlocks
    , <CheckMistakenAssign s.Mode s.PartType t.Pos> : e.MistakenAssignError
    , <CheckExceedBlocks s.Mode e.ExceedBlocks>
    : (e.ExceedBlocksErrors) e.ExceedBlocks1
    = (e.MistakenAssignError e.ExceedBlocksErrors) (e.Body) e.ExceedBlocks1;

  s.Mode Condition t.Pos /* no blocks */
    = ((Error t.Pos 'Mistaken \',\' for \'=\'')) /* no blocks */;

  s.Mode Assign t.Pos /* no blocks */ = (/* no errors */) /* no blocks */;
}

CheckMistakenAssign {
  s.Mode Assign t.Pos
    = <ClassicError s.Mode t.Pos 'Mistaken \'=\' for \',\' in classic mode'>;

  s.Mode Condition t.Pos = /* no error */;
}

SentencePart {
  s.Mode e.Tokens
    = <SentencePart-AfterPattern s.Mode <Pattern s.Mode e.Tokens>>;
}

SentencePart-AfterPattern {
  s.Mode (e.PatternErrors) t.Pattern t.NextToken e.Tokens
    , t.NextToken
    : {
        (TkComma t.Pos)
          = <SentencePart-AfterResult
              s.Mode (e.PatternErrors) t.Pattern Condition t.Pos
              <Result s.Mode e.Tokens>
            >;

        (TkAssign t.Pos)
          = <SentencePart-AfterResult
              s.Mode (e.PatternErrors) t.Pattern Assign t.Pos
              <Result s.Mode e.Tokens>
            >;

        (s.EndOfPart t.Pos)
          , <OneOf s.EndOfPart TkColon TkSemicolon> : True
          = <SentencePart-AfterPattern
              s.Mode
              (e.PatternErrors (Error t.Pos 'Missed \',\' or \'=\''))
              t.Pattern (TkComma t.Pos) (s.EndOfPart t.Pos) e.Tokens
            >;

        (s.Unexpected t.Pos e.Info)
          = (e.PatternErrors <UnexpectedTokenInSentence t.NextToken>)
            t.Pattern Assign t.Pos (/* empty result */) (/* no blocks */)
            t.NextToken e.Tokens;
      };
}

SentencePart-AfterResult {
  s.Mode (e.PatternErrors) t.Pattern s.PartType t.Pos
  (e.ResultErrors) t.Result (e.Blocks) e.Tokens
    = (e.PatternErrors e.ResultErrors)
      t.Pattern s.PartType t.Pos t.Result (e.Blocks) e.Tokens;
}

UnexpectedTokenInSentence {
  t.Unexpected =
    <UnexpectedToken
      t.Unexpected 'valid Refal expression, \'=\', \',\', \':\' or \';\''
    >
}


/*
  Pattern = Expression.

  <Pattern s.Mode e.Tokens> == (e.Errors) t.Pattern e.Tokens
*/
Pattern {
  s.Mode e.Tokens = <Expression s.Mode Pattern e.Tokens>;
}


/*
  Result = Expression { ":" Block }.

  <Result s.Mode e.Tokens> == (e.Errors) t.Result (e.Blocks) e.Tokens
*/
Result {
  s.Mode e.Tokens
    = <Result-Blocks
        s.Mode (/* blocks */) <Expression s.Mode Result e.Tokens>
      >;
}

Result-Blocks {
  s.Mode (e.Blocks) (e.Errors) t.Result
  (TkRefal5Mode t.ModePos s.NewMode) e.Tokens
    = <Result-Blocks s.NewMode (e.Blocks) (e.Errors) t.Result e.Tokens>;

  s.Mode (e.Blocks) (e.Errors) t.Result
  (TkColon t.ColonPos) (TkRefal5Mode t.ModePos s.NewMode) e.Tokens
    = <Result-Blocks
        s.NewMode (e.Blocks) (e.Errors) t.Result
        (TkColon t.ColonPos) e.Tokens
      >;

  s.Mode (e.Blocks) (e.Errors) t.Result
  (TkColon t.ColonPos) (TkOpenBlock t.BlockPos) e.Tokens
    /* TODO: assing */
    , <Block s.Mode (TkOpenBlock t.BlockPos) e.Tokens>
    : {
        (e.BlockErrors) (e.Body) e.Tokens1 /*^*/
          = <Result-Blocks
              s.Mode (e.Blocks (t.ColonPos e.Body))
              (e.Errors e.BlockErrors) t.Result e.Tokens1
            >;
      };

  s.Mode (e.Blocks) (e.Errors) t.Result
  /* missed TkColon */ (TkOpenBlock t.BlockPos) e.Tokens
    = <Result-Blocks
        s.Mode (e.Blocks) (e.Errors (Error t.BlockPos 'Missed \':\''))
        t.Result
        (TkColon t.BlockPos) (TkOpenBlock t.BlockPos) e.Tokens
      >;

  s.Mode (e.Blocks) (e.Errors) t.Result e.Tokens
    = (e.Errors) t.Result (e.Blocks) e.Tokens;
}


/*
  Expression = (
      NAME
    | COMPOUND
    | NUMBER
    | CHAR
    | VARIABLE
    | "(" Expression ")"
    | "<Func" Expression ">" -- допустимо только в результатных выражениях
  )* !((")" | ">") Expression)*

  <Expression s.Mode s.Kind e.Tokens> == (e.Errors) t.Expression e.Tokens

  s.Kind ::= Pattern | Result
*/
Expression {
  s.Mode s.Kind e.Tokens =
    <Expression-CheckBrackets
      s.Mode s.Kind <Expression-Aux s.Mode s.Kind e.Tokens>
    >;
}

Expression-Aux {
  s.Mode s.Kind e.Tokens =
    <DoExpression s.Mode s.Kind (/* errors */) (/* collected */) e.Tokens>
}

DoExpression {
  s.Mode s.Kind (e.Errors) (e.Collected) t.NextToken e.Tokens,
      t.NextToken:
    {
      (TkName t.Pos e.Name) =
        <DoExpression
          s.Mode s.Kind (e.Errors) (e.Collected (TkIdentifier e.Name)) e.Tokens
        >;

      (TkCompound t.Pos e.Symbols) =
        <DoExpression
          s.Mode s.Kind (e.Errors)
          (e.Collected (TkIdentifier e.Symbols)) e.Tokens
        >;

      (TkMacroDigit t.Pos s.Number) =
        <DoExpression
          s.Mode s.Kind (e.Errors) (e.Collected (TkNumber s.Number)) e.Tokens
        >;

      (TkChar t.Pos s.Char) =
        <DoExpression
          s.Mode s.Kind (e.Errors) (e.Collected (TkChar s.Char)) e.Tokens
        >;

      (TkVariable t.Pos s.VarType e.Index) =
        <DoExpression
          s.Mode s.Kind (e.Errors)
          (e.Collected (TkVariable t.Pos s.VarType e.Index)) e.Tokens
        >;

      (TkOpenBracket t.Pos) =
        <DoExpression-AfterBracket
          s.Mode s.Kind (e.Errors)
          (e.Collected) <Expression-Aux s.Mode s.Kind e.Tokens>
        >;

      (TkOpenCall t.Pos /* empty */)
        = <DoExpression-AfterCall
            s.Mode s.Kind
            (
              e.Errors
              <ClassicError s.Mode t.Pos 'Identifier expected after \'<\''>
            )
            (e.Collected) t.Pos
            (/* no func name */) <Expression-Aux s.Mode s.Kind e.Tokens>
          >;

      (TkOpenCall t.Pos e.FuncName) =
        <DoExpression-AfterCall
          s.Mode s.Kind (e.Errors) (e.Collected) t.Pos
          ((TkName t.Pos e.FuncName)) <Expression-Aux s.Mode s.Kind e.Tokens>
        >;

      (TkOpenADT t.Pos e.FuncName) =
        <DoExpression-AfterADT
          s.Mode s.Kind
          (
            e.Errors
            <ClassicError s.Mode t.Pos 'Abstract data types is an extension'>
          )
          (e.Collected) t.Pos
          (e.FuncName) <Expression-Aux s.Mode s.Kind e.Tokens>
        >;

      (TkRefal5Mode t.Pos s.NewMode)
        = <DoExpression s.NewMode s.Kind (e.Errors) (e.Collected) e.Tokens>;

      (TkAmpersand t.Pos)
        , s.Mode
        : {
            Classic
              = <DoExpression
                  s.Mode s.Kind
                  (e.Errors (Error t.Pos '\'&\' is not where-with sign'))
                  (e.Collected) e.Tokens
                >;

            Extended
              = <DoExpression-AfterAmpersand
                  s.Kind (e.Errors) (e.Collected) t.Pos e.Tokens
                >;
          };

      (TkOpenBlock t.Pos)
        , s.Kind : Result
        = <DoExpression-AfterBlock
            s.Mode
            (
              e.Errors
              <ClassicError s.Mode t.Pos 'Do you forged \':\' before block?'>
            )
            (e.Collected) <Block s.Mode (TkOpenBlock t.Pos) e.Tokens>
          >;

      (TkRedefinition t.Pos)
        = <DoExpression
            s.Mode s.Kind
            <DoExpression-AddRedefinition
              s.Kind
              (
                e.Errors
                <ClassicError
                  s.Mode t.Pos
                  'Variable redefinition is available in extended mode'
                >
              )
              (e.Collected) t.Pos
            >
            e.Tokens
          >;

      (TkScopeId t.Pos)
        = <DoExpression
            s.Mode s.Kind
            (
              e.Errors
              <ClassicError
                s.Mode t.Pos '$SCOPEID is not supported in classic REFAL-5'
              >
            )
            (e.Collected (TkNumber Cookie1) (TkNumber Cookie2))
            e.Tokens
          >;

      (TkError t.Pos e.Message)
        = <DoExpression
            s.Mode s.Kind
            (e.Errors <UnexpectedToken (TkError t.Pos e.Message)>)
            (e.Collected) e.Tokens
          >;

      t.OtherToken =
        (e.Errors) (e.Collected) t.OtherToken e.Tokens;
    }
}

DoExpression-AfterBracket {
  s.Mode s.Kind (e.Errors) (e.Collected)
  (e.SubexprErrors) (e.BracketTerms) (TkCloseBracket t.Pos) e.Tokens =
    <DoExpression
      s.Mode s.Kind (e.Errors e.SubexprErrors)
      (e.Collected (Brackets e.BracketTerms)) e.Tokens
    >;

  s.Mode s.Kind (e.Errors) (e.Collected)
  (e.SubexprErrors) (e.BracketTerms) (s.Type t.Pos e.Value) e.Tokens =
    <DoExpression
      s.Mode s.Kind (e.Errors e.SubexprErrors (Error t.Pos 'Missed \')\''))
      (e.Collected (Brackets e.BracketTerms)) (s.Type t.Pos e.Value) e.Tokens
    >;
}

DoExpression-AfterCall {
  s.Mode Result (e.Errors) (e.Collected) t.CallPos (e.OptionalFuncName)
  (e.SubexprErrors) (e.BracketTerms) (TkCloseCall t.Pos) e.Tokens =
    <DoExpression
      s.Mode Result (e.Errors e.SubexprErrors)
      (e.Collected (CallBrackets e.OptionalFuncName e.BracketTerms))
      e.Tokens
    >;

  s.Mode Pattern (e.Errors) (e.Collected) t.CallPos (e.OptionalFuncName)
  (e.SubexprErrors) (e.BracketTerms) (TkCloseCall t.Pos) e.Tokens =
    <DoExpression
      s.Mode Pattern
      (
        e.Errors e.SubexprErrors
        (Error
          t.CallPos
          'unexpected \'<\' in pattern expression, maybe missed \'=\''
        )
      )
      (e.Collected (Brackets e.OptionalFuncName e.BracketTerms)) e.Tokens
    >;

  s.Mode Result (e.Errors) (e.Collected) t.CallPos (e.OptionalFuncName)
  (e.SubexprErrors) (e.BracketTerms) (s.Type t.Pos e.Value) e.Tokens =
    <DoExpression
      s.Mode Result (e.Errors e.SubexprErrors (Error t.Pos 'Missed \'>\''))
      (e.Collected (CallBrackets e.OptionalFuncName e.BracketTerms))
      (s.Type t.Pos e.Value) e.Tokens
    >;

  s.Mode Pattern (e.Errors) (e.Collected) t.CallPos (e.OptionalFuncName)
  (e.SubexprErrors) (e.BracketTerms) (s.Type t.Pos e.Value) e.Tokens =
    <DoExpression
      s.Mode Pattern
      (
        e.Errors e.SubexprErrors
        (Error
          t.CallPos
          'unexpected \'<\' in pattern expression, maybe missed \'=\''
        )
        (Error t.Pos 'Missed \')\'')
      )
      (e.Collected (Brackets e.OptionalFuncName e.BracketTerms))
      (s.Type t.Pos e.Value) e.Tokens
    >;
}

DoExpression-AfterADT {
  s.Mode s.Kind (e.Errors) (e.Collected) t.OpenPos (e.FuncName)
  (e.SubexprErrors) (e.BracketTerms) (TkCloseADT t.ClosePos) e.Tokens
    = <DoExpression
        s.Mode s.Kind (e.Errors e.SubexprErrors)
        (e.Collected (ADT-Brackets t.OpenPos (e.FuncName) e.BracketTerms))
        e.Tokens
      >;

  s.Mode s.Kind (e.Errors) (e.Collected) t.OpenPos (e.FuncName)
  (e.SubexprErrors) (e.BracketTerms) (s.Type t.Pos e.Value) e.Tokens
    = <DoExpression
        s.Mode s.Kind (e.Errors e.SubexprErrors (Error t.Pos 'Missed \']\''))
        (e.Collected (ADT-Brackets t.OpenPos (e.FuncName) e.BracketTerms))
        (s.Type t.Pos e.Value) e.Tokens
      >;
}

DoExpression-AfterAmpersand {
  s.Kind (e.Errors) (e.Collected) t.AmpersandPos
  (TkName t.Pos e.Name) e.Tokens
    = <DoExpression
        Extended s.Kind (e.Errors) (e.Collected (TkName t.Pos e.Name)) e.Tokens
      >;

  s.Kind (e.Errors) (e.Collected) t.AmpersandPos e.Tokens
    = <DoExpression
        Extended s.Kind
        (e.Errors (Error t.AmpersandPos 'Expected function name after \'&\''))
        (e.Collected) e.Tokens
      >;
}

DoExpression-AfterBlock {
  s.Mode (e.Errors) (e.Collected) (e.BlockErrors) (e.Body) e.Tokens
    = <DoExpression
        s.Mode Result (e.Errors e.BlockErrors)
        (e.Collected (Closure e.Body)) e.Tokens
      >;
}

DoExpression-AddRedefinition {
  Pattern (e.Errors) (e.Collected (TkVariable t.VarPos s.VarType e.Index)) t.Pos
    = (e.Errors) (e.Collected (TkNewVariable t.VarPos s.VarType e.Index));

  Pattern (e.Errors) (e.Collected) t.Pos
    = (e.Errors (Error t.Pos 'Redefinition sign expects variable before'))
      (e.Collected);

  Result (e.Errors) (e.Collected) t.Pos
    = (e.Errors (Error t.Pos 'Illegal redefinition sign in result expression'))
      (e.Collected);
}

Expression-CheckBrackets {
  s.Mode s.Kind (e.Errors) (e.Expression) (s.Type t.Pos) e.Tokens,
      <OneOf s.Type TkCloseBracket TkCloseCall TkCloseADT>: True =
    <Expression-CheckBrackets-AfterSubexpr
      s.Mode s.Kind
      (e.Errors (Error t.Pos 'unbalanced ' <TokName s.Type>))
      (e.Expression)
      <Expression-Aux s.Mode s.Kind e.Tokens>
    >;

  s.Mode s.Kind (e.Errors) t.Expression e.Tokens =
    (e.Errors) t.Expression e.Tokens;
}

Expression-CheckBrackets-AfterSubexpr {
  s.Mode s.Kind (e.Errors) (e.Expression)
  (e.SubexprErrors) (e.Subexpression) e.Tokens =
    <Expression-CheckBrackets
      s.Mode s.Kind (e.Errors e.SubexprErrors)
      (e.Expression e.Subexpression) e.Tokens
    >;
}


ClassicError {
  Classic t.Pos e.Message = (Error t.Pos e.Message);

  Extended t.Pos e.Message = /* it is not a error in extended mode */;
}

UnexpectedToken {
  (TkError t.Pos e.Message) e.Expected =
    (Error t.Pos e.Message);

  (s.Type t.Pos e.Value) e.Expected =
    (Error t.Pos 'unexpected ' <TokName s.Type> ', expected ' e.Expected);
}

TokName {
  TkName = 'identifier';
  TkCompound = 'compound symbol';
  TkMacroDigit = 'number';
  TkChar = 'character';
  TkVariable = 'variable';
  TkOpenBracket = '\'(\'';
  TkCloseBracket = '\')\'';
  TkOpenBlock = '\'{\'';
  TkCloseBlock = '\'}\'';
  TkOpenCall = '\'<\'';
  TkCloseCall = '\'>\'';
  TkOpenADT = '\'[\'';
  TkCloseADT = '\']\'';
  TkComma = '\',\'';
  TkColon = '\':\'';
  TkAssign = '\'=\'';
  TkSemicolon = '\';\'';
  TkExtern = '$EXTERN';
  TkEntry = '$ENTRY';
  TkEnum = '$ENUM';
  TkEEnum = '$EENUM';
  TkSwap = '$SWAP';
  TkESwap = '$ESWAP';
  TkInclude = '$INCLUDE';
  TkScopeId = '$SCOPEID';
  TkEOF = 'end of file';
  TkRefal5Mode = '*$CLASSIC or *$EXTENDED';
  TkAmpersand = '\'&\'';
  TkRedefinition = '\'^\'';
  TkNativeCode = 'native code insertion';
}
