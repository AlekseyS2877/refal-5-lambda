//FROM Version
$EXTERN PrintVersion;

//FROM LibraryEx
$EXTERN ArgList, LoadFile, Map, SaveFile, Fetch, Seq, DelAccumulator, MapReduce,
  Inc, SaveBytes, LoadBytes;

//FROM ParseCmdLine
$EXTERN ParseCommandLine;

//FROM Config
$EXTERN Config-GetTargetFileName, Config-SetTargetFileName, Config-GetErrorFile,
  Config-GetCppCompiler, Config-GetGrammarCheck, Config-GetTargetSuffix,
  Config-GetSearchFolders, Config-GetTargetMode, Config-GetPrefix,
  Config-GetChmodXCommand;

//FROM Library
$EXTERN WriteLine, StrFromInt, Exit, System, ExistFile, FOpen, FWriteBytes,
  FSeek, Mod, FTell, FClose, RemoveFile, RenameFile;

//FROM FindFile
$EXTERN FindFiles;

//FROM Driver
$EXTERN CompileFile, GrammarCheck;

//------------------------------------------------------------------------------

$ENTRY Go {
  = <PrintVersion 'Srefc'> <Main <ArgList>>;
}

Main {
  (e.ProgName) ('@' e.Config) =
    <Main-SwValidCommandLine
      (e.Config) <ParseCommandLine <LoadFile e.Config>>
    >;

  (e.ProgName) e.Arguments =
    <Main-SwValidCommandLine
      #CommandLine <ParseCommandLine e.Arguments>
    >;
}

Main-SwValidCommandLine {
  t.CommandLineSource #Success t.Config /* файлов нет */
    = <ReportErrors
        t.CommandLineSource t.Config (1 'no source files in command line')
      >;

  t.CommandLineSource #Success t.Config e.Files
    = <CalcTargetFileName
        t.Config
        (<Config-GetTargetFileName t.Config>)
        e.Files
      >
    : e.TargetFileName
    = <Config-SetTargetFileName t.Config e.TargetFileName>
    : #Success t.Config^
    = <Main-SwFoundFiles
        t.CommandLineSource t.Config
        <LookupSourceFiles t.Config e.Files>
      >;

  t.CommandLineSource #Fails e.Errors
    = <ReportErrors t.CommandLineSource #NoConfig e.Errors>;
}

ReportErrors {
  #CommandLine t.Config e.Errors =
    <Map
      {
        (s.Pos e.Message) =
          <WriteLine
            'Command line argument ' <StrFromInt s.Pos> ': Error: ' e.Message
          >;
      }
      e.Errors
    >
    <CreateErrorFileMark t.Config>
    <Exit 1>;

  (e.ConfigFile) t.Config e.Errors =
    <Map
      {
        (s.Pos e.Message) =
          <WriteLine
            e.ConfigFile ':' <StrFromInt s.Pos> ': Error: ' e.Message
          >;
      }
      e.Errors
    >
    <CreateErrorFileMark t.Config>
    <Exit 1>;
}

CreateErrorFileMark {
  // Вызывается также при ошибке в командной строке, когда t.Config
  // не удалось построить, поэтому #NoConfig
  #NoConfig = /* ничего */;

  t.Config = <CreateErrorFileMark-SwFile <Config-GetErrorFile t.Config>>;
}

CreateErrorFileMark-SwFile {
  #NoErrorFile = /* ничего */;
  #ErrorFile e.FileName = <SaveFile (e.FileName)>;
}

Main-SwFoundFiles {
  t.CommandLineSource t.Config
  e.Files-B (s.Pos #NotFound e.FileName) e.Files-E =
    <ReportErrors
      t.CommandLineSource t.Config
      <Map
        {
          (s.Pos^ #NotFound e.FileName^) =
            (s.Pos 'file ' e.FileName ' is not found');

          (s.Pos^ #Source (s.Dialect e.Source) e.Output) =
            /* пусто */;

          (s.Pos^ #Output e.Output) =
            /* пусто */;

          (s.Pos^ #OutputWithNative (e.Output) e.NativeOutput) =
            /* пусто */;
        }
        (s.Pos #NotFound e.FileName) e.Files-E
      >
    >;

  t.CommandLineSource t.Config e.Files =
    <Main-SwRenamedTargets
      t.CommandLineSource t.Config
      <RenameTargets <Config-GetTargetMode t.Config> e.Files>
    >;
}

Main-SwRenamedTargets {
  t.CommandLineSource
  t.Config
  e.Files-B (s.Pos #Collision e.Collision) e.Files-E =
    <ReportErrors
      t.CommandLineSource t.Config
      <Map
        {
          (s.Pos^ #Collision (e.FirstTarget) e.SecondTarget) =
            (
              s.Pos
              'files ' e.FirstTarget ' and ' e.SecondTarget ' have same name'
            );

          (s.Pos^ #Source (s.Dialect e.Source) e.Output) =
            /* пусто */;

          (s.Pos^ #Output e.Output) =
            /* пусто */;

          (s.Pos^ #OutputWithNative (e.Output) e.NativeOutput) =
            /* пусто */;
        }
        (s.Pos #Collision e.Collision) e.Files-E
      >
    >;

  t.CommandLineSource
  t.Config
  e.Files
    = <Config-GetGrammarCheck t.Config> : s.GrammarCheck
    = <Fetch
        s.GrammarCheck <CompileFiles t.Config s.GrammarCheck e.Files>
        {
          s.GrammarCheck^ e.Outputs-B #Fails e.Outputs-E
            = <CreateErrorFileMark t.Config>
              <Exit 1>;

          #NormalRun e.Outputs
            = <Link t.CommandLineSource t.Config e.Outputs>;

          #GrammarCheck e.Outputs
            = <WriteLine '** No syntax errors found **'>;
        }
      >;
}

//------------------------------------------------------------------------------

CalcTargetFileName {
  t.Config (#DefaultTargetFileName) (s.Pos e.FirstFile) e.OtherFiles =
    <Fetch
      e.FirstFile
      <Seq
        GetLastPartName
        {
          e.LastPartName = (<Lower e.LastPartName>) e.LastPartName;
        }
        {
          (e.LowerBaseName '.ref') e.BaseName '.' s.R s.E s.F =
            e.BaseName;

          (e.LowerBaseName '.sref') e.BaseName '.' s.S s.R s.E s.F =
            e.BaseName;

          (e.LowerBaseName '.rasl') e.BaseName '.' s.R s.A s.S s.L =
            e.BaseName;

          (e.LowerBaseName '.cpp') e.BaseName '.' s.C s.P1 s.P2 =
            e.BaseName;

          (e.LowerBaseName) e.BaseName =
            e.BaseName;
        }
      >
    >
    <Config-GetTargetSuffix t.Config <Config-GetTargetMode t.Config>>;

  t.Config (e.TargetFileName) e.InputFiles =
    e.TargetFileName;
}

LookupSourceFiles {
  t.Config e.Files =
    <Map
      {
        (s.Pos e.FileName) =
          <Fetch
            <FindFiles (<Config-GetSearchFolders t.Config>) (e.FileName)>
            {
              (s.ResultTag e.Info) = (s.Pos s.ResultTag e.Info);
            }
          >;
      }
      e.Files
    >;
}

RenameTargets {
  #EXE e.Files = <RenameTargets-WithCpp e.Files>;
  #LIB e.Files = <RenameTargets-WithCpp e.Files>;

  #R e.Files = <RenameTargets-Stub e.Files>;
  #CompileOnly e.Files = <RenameTargets-Stub e.Files>;
}

RenameTargets-Stub {
  e.Files =
    <Map
      {
        (s.Pos #Output e.FileName)
          = (s.Pos #Output e.FileName #NoNative);

        (s.Pos #OutputWithNative (e.FileName) e.NativeFileName)
          = (s.Pos #Output e.FileName (e.NativeFileName));

        (s.Pos #Source (s.Dialect e.Source) e.Output)
          = (s.Pos #Source (s.Dialect e.Source) e.Output);
      }
      e.Files
    >;
}

RenameTargets-WithCpp {
  e.Files = <ScanCollisions <Map GetFileName e.Files>>;
}

GetFileName {
  (s.Pos #Output e.FileName) =
    ((<GetBaseNameLowerCase e.FileName>) (s.Pos #Output e.FileName #NoNative));

  (s.Pos #OutputWithNative (e.FileName) e.NativeFileName) =
    (
      (<GetBaseNameLowerCase e.FileName>)
      (s.Pos #Output e.FileName (e.NativeFileName))
    );

  (s.Pos #Source (s.Dialect e.Source) e.Output) =
    (
      (<GetBaseNameLowerCase e.Output>)
      (s.Pos #Source (s.Dialect e.Source) e.Output)
    );
}

ScanCollisions {
  ((e.BaseName) e.Locations1)
  e.Files-B ((e.BaseName) e.Locations2) e.Files-E =
    <ScanCollisions
      e.Files-B ((e.BaseName) e.Locations1 e.Locations2) e.Files-E
    >;

  ((e.BaseName) e.Locations) e.Files =
    <RenameLocations e.Locations> <ScanCollisions e.Files>;

  /* пусто */ = /* всё */;
}

RenameLocations {
  e.Locations-B (s.Pos1 #Output e.FirstTarget t.FirstNative)
  e.Locations-M (s.Pos2 #Output e.SecondTarget t.SecondNative)
  e.Locations-E =
    (s.Pos2 #Collision (e.FirstTarget) e.SecondTarget);

  e.Locations-B (s.Pos #Output e.Target t.Native) e.Locations-E =
    <RenameLocations-Aux
      1 e.Locations-B (s.Pos #Output e.Target t.Native) e.Locations-E
    >;

  e.Locations = <RenameLocations-Aux 0 e.Locations>;
}

RenameLocations-Aux {
  s.InitNumber e.Locations =
    <DelAccumulator
      <MapReduce
        {
          0 (s.Pos #Source (s.Dialect e.Source) e.Output) =
            1 (s.Pos #Source (s.Dialect e.Source) e.Output);

          s.Num (s.Pos #Source (s.Dialect e.Source) e.Output '.rasl') =
            <Inc s.Num>
            (s.Pos #Source
              (s.Dialect e.Source) e.Output '@' <StrFromInt s.Num> '.rasl'
            );

          s.Num (s.Pos #Output e.Output t.Native) =
            s.Num (s.Pos #Output e.Output t.Native);
        }
        s.InitNumber e.Locations
      >
    >;
}

CompileFiles {
  t.Config #NormalRun e.Files =
    <Map
      {
        (s.Pos #Output e.OutputName #NoNative) =
          <WriteLine '+Linking ' e.OutputName>
          (#RASL e.OutputName);

        (s.Pos #Output e.OutputName (e.NativeName)) =
          <WriteLine '+Linking (+ natives) ' e.OutputName>
          (#RASL e.OutputName) (#Native e.NativeName);

        (s.Pos #Source (s.Dialect e.Source) e.OutputName) =
          <WriteLine '*Compiling ' e.Source ':'>
          <Fetch
            <CompileFile t.Config (s.Dialect e.Source) e.OutputName>
            {
              #Success e.OutputName^ #NoNative =
                (#RASL e.OutputName);

              #Success e.OutputName^ (e.NativeOutputName) =
                <WriteLine '   ... natives generated'>
                (#RASL e.OutputName) (#Native e.NativeOutputName);

              #Fails = #Fails;
            }
          >;
      }
      e.Files
    >;

  t.Config #GrammarCheck e.Files =
    <Map
      {
        (s.Pos #Output e.OutputName) =
          <WriteLine '+Skipping native file ' e.OutputName> (e.OutputName);

        (s.Pos #Source (s.Dialect e.Source) e.OutputName) =
          <WriteLine '*Grammar checking ' e.Source ':'>
          <GrammarCheck e.Source>;
      }
      e.Files
    >;
}

Link {
  t.CommandLineSource t.Config e.Files
    = <Config-GetTargetMode t.Config>
    : {
        #EXE
          = <Link-ExeLib
              t.CommandLineSource t.Config
              (<Config-GetCppCompiler t.Config #EXE>)
              (<Config-GetPrefix t.Config>)
              e.Files
            >;

        #LIB
          = <Link-ExeLib
              t.CommandLineSource t.Config
              (<Config-GetCppCompiler t.Config #LIB>)
              (<Config-GetPrefix t.Config>)
              e.Files
            >;

        #R
          = <WriteLine 'R modules is not supported yet'>;

        #CompileOnly
          = /* ничего не делаем */;
      };
}

Link-ExeLib {
  t.CommandLineSource t.Config
  (#NoCppCompiler) (/* нет префикса */) e.Files
    = <Fetch
        <Config-GetTargetMode t.Config>
        {
          #EXE = 'x' 'exe';
          #LIB = 'l' 'lib';
        }
      >
    : s.Key e.FlagSuf
    = <ReportErrors
        t.CommandLineSource t.Config
        (
          1
          'option -' s.Key ' (or --' e.FlagSuf ') require option '
          '--cpp-command-' e.FlagSuf ' with nonempty value'
        )
      >;

  t.CommandLineSource t.Config
  ((e.CommandLine) e.Flags) (/* нет префикса */) e.Files
    = <Link-CppCompile t.Config ((e.CommandLine) e.Flags) e.Files>;

  t.CommandLineSource t.Config
  (e.AnyCommandLine) (e.Prefix)
  e.Files-B (#Native e.FileName) e.Files-E
    = <ReportErrors
        t.CommandLineSource t.Config
        (
          1
          'unexpected native file ' e.FileName ' while compilation runs '
          'with prefix'
        )
      >;

  t.CommandLineSource t.Config
  (e.AnyCommandLine) (e.Prefix) e.Files
    = <FindPrefix t.Config e.Prefix>
    : {
        #Success e.PrefixFileName
          = <Link-WithPrefix (e.PrefixFileName) t.Config e.Files>;

        #Fails
          = <ReportErrors
              t.CommandLineSource t.Config
              (1 'Can''t find prefix ' e.Prefix)
            >;
      };
}

Link-WithPrefix {
  (e.PrefixFileName) t.Config e.Files
    = <Link-Aux
        {
          e.IntermediateName
            = <CopyPrefix (e.PrefixFileName) (e.IntermediateName)>
              <Chmod-X-Prefix t.Config e.IntermediateName>;
        }
        t.Config e.Files
      >;
}

Chmod-X-Prefix {
  t.Config e.IntermediateName
    = <Config-GetChmodXCommand t.Config>
    : {
        /* пусто */ = /* ничего не делаем */;

        e.ChmodXCommand
          = <System e.ChmodXCommand ' "' e.IntermediateName '"'>
            /* TODO: уточнить после обновления System в стабильной версии */
          : e.RetCode
          = /* пусто */;
      };
}

Link-CppCompile {
  t.Config ((e.CommandLine) e.Flags) e.Files
    = <Link-Aux
        {
          e.IntermediateName
            = <System
                e.CommandLine
                e.IntermediateName
                e.Flags
                <Map
                  {
                    (#RASL e.FileName) = /* пусто */;
                    (#Native e.FileName) = ' "' e.FileName '"';
                  }
                  e.Files
                >
              >
              /* TODO: уточнить после обновления System в стабильной версии */
            : e.RetCode
            = <CheckCppCompilationSuccessed t.Config e.IntermediateName>
              <EnsureAligned4096 e.IntermediateName>;
        }
        t.Config e.Files
      >;
}

Link-Aux {
  s.FnCreatePrefix t.Config e.Files
    = <Config-GetTargetFileName t.Config> : e.TargetFileName
    = e.TargetFileName '.partial' : e.IntermediateName
    = <PreLinkCleanupTemporary t.Config e.IntermediateName>
      <s.FnCreatePrefix e.IntermediateName>
      <AppendRASLToBinary (e.IntermediateName) e.Files>
      <PostLinkRename
        t.Config (e.IntermediateName) (e.TargetFileName)
      >;
}

PreLinkCleanupTemporary {
  t.Config e.Temporary =
    <Fetch
      <ExistFile e.Temporary>
      {
        #False = /* ничего не делаем */;

        #True
          = <RemoveFile e.Temporary>
          : {
              /* TODO: уточнить после обновления RemoveFile в стабильной версии */
              #True e.TrueTail /* () */
                = <WriteLine 'Lost temporary file ' e.Temporary ' is removed'>;

              #False e.FalseTail /* (e.ErrorMessage) */
                = <LinkError t.Config 'Can''t remove file ' e.Temporary>;
            };
      }
    >;
}

CheckCppCompilationSuccessed {
  t.Config e.TemporaryName
    = <ExistFile e.TemporaryName>
    : {
        #False =
          <LinkError t.Config 'C++ compilation is failed'>;

        #True =
          /* ничего не делаем */;
      };
}

EnsureAligned4096 {
  e.BinaryName
    = <FOpen ('ab') e.BinaryName> : s.FileHandle
    = <AlignToPage s.FileHandle>
      <FClose s.FileHandle>;
}

AppendRASLToBinary {
  (e.BinaryName) e.Files
    = <FOpen ('ab') e.BinaryName> : s.FileHandle
    = <Map
        {
          (#RASL e.OutputName) =
            <FWriteBytes s.FileHandle <LoadBytes e.OutputName>>;

          (#Native e.NativeName) =
            /* ничего не делаем */;
        }
        e.Files
      >
      <FClose s.FileHandle>;
}

AlignToPage {
  s.FileHandle =
    <FSeek s.FileHandle #END '-' 0>
    <Fetch
      <Mod <FTell s.FileHandle> 4096>
      {
        0 = /* ничего не делаем */;

        s.Other =
          <FWriteBytes s.FileHandle '@'>
          <AlignToPage s.FileHandle>;
      }
    >;
}

PostLinkRename {
  t.Config (e.TemporaryName) (e.TargetFileName) =
    <Fetch
      <ExistFile e.TargetFileName>
      {
        #True
          = <RemoveFile e.TargetFileName>
          : {
              /* TODO: уточнить после обновления RemoveFile в стабильной версии */
              #True e.TrueTail /* () */
                = /* ничего не делаем */;

              #False e.FalseTail /* (e.ErrorMessage) */
                = <LinkError t.Config 'Can''t remove file ' e.TargetFileName>;
             };

        #False = /* ничего не делаем */;
      }
    >
    <Fetch
      <RenameFile (e.TemporaryName) (e.TargetFileName)>
      {
        #True =
          <WriteLine '** Compilation successed **'>;

        #False =
          <LinkError
            t.Config
            'Can''t rename from ' e.TemporaryName ' to ' e.TargetFileName
          >;
      }
    >;
}

FindPrefix {
  t.Config e.Prefix
    = <Fetch
        <Config-GetTargetMode t.Config>
        {
          #EXE = '.exe-prefix';
          #LIB = '.lib-prefix';
        }
      >
    : e.PrefixExt
    = <DoFindPrefix
        (e.Prefix e.PrefixExt) (#Current) <Config-GetSearchFolders t.Config>
      >;
}

DoFindPrefix {
  (e.PrefixName) (e.NextFolder) e.Folders
    = <GlueNames (e.NextFolder) (e.PrefixName)> : e.PrefixFileName
    = <Fetch
        <ExistFile e.PrefixFileName>
        {
          #True = #Success e.PrefixFileName;
          #False = <DoFindPrefix (e.PrefixName) e.Folders>;
        }
      >;

  (e.PrefixName) /* кончились папки */
    = #Fails;
}

GlueNames {
  (#Current) (e.FileName) = e.FileName;
  (e.Folder) (e.FileName) = e.Folder '/' e.FileName;
}

CopyPrefix {
  (e.OriginalPrefixName) (e.NewExeName)
    = <SaveBytes (e.NewExeName) <LoadBytes e.OriginalPrefixName>>;
}

LinkError {
  t.Config e.Message =
    <WriteLine 'LINK ERROR: ' e.Message>
    <CreateErrorFileMark t.Config>
    <Exit 1>;
}

GetBaseNameLowerCase {
  e.FileName '.rasl' = <Lower <GetLastPartName e.FileName>>;
}

GetLastPartName {
  e.FileName = <DoGetFileName e.FileName>;
}

DoGetFileName {
  e.FileName '/' = ;
  e.FileName '\\' = ;
  e.FileName s.Last = <DoGetFileName e.FileName> s.Last;
  = ;
}

Lower {
  e.String = <Map LowerChar e.String>;
}

LowerChar {
  s.Char =
    // Сначала мы проверяем, что символ является большой буквой
    <Fetch
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      {
        e.Uppers-B s.Char e.Uppers-E =
          // Символ является большой буквой, находим соответствующую маленькую
          <Fetch
            'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
            {
              e.UpLo-B s.Char s.Lower e.UpLo-E = s.Lower;
            }
          >;

        e.Uppers = s.Char;
      }
    >;
}
