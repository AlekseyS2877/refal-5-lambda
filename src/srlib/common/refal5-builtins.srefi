//==============================================================================
// Предобъявления и определения встроенных функций Рефала-5λ
//==============================================================================


/********************************* REFACTORED *********************************/

// 3. Arg

//FROM Library
$EXTERN Arg;


// 12. Explode

//FROM Library
$EXTERN Explode;


// 25. Prout

//FROM Library
$EXTERN Prout, Proud, Trout;


// 33. Type

//FROM Library
$EXTERN Type;


// 51. GetEnv

//FROM Library
$EXTERN GetEnv;


// 55. ExistFile

//FROM Library
$EXTERN ExistFile;


// 59. Explode_Ext

//FROM Library
$EXTERN Explode_Ext;


/******************************* NOT REFACTORED *******************************/

//FROM Library
$EXTERN Add, Sub, Mul, Div, Mod, Chr, Ord,
  FOpen, FClose, FReadLine, FWriteLine, IntFromStr, StrFromInt,
  SymbCompare, Implode;

$SWAP __file_handles;

Open {
  s.Mode s.Number e.FileName
    = <__Open-SwOpened
        (s.Mode s.Number e.FileName)
        <__read __file_handles>
      >;
}

__read {
  s.Swap
    = <s.Swap> : e.Content
    = <s.Swap e.Content> e.Content;
}

__write {
  s.Swap e.Content
    = <s.Swap e.Content> : e.OldContent
    = /* пусто */;
}

__Open-SwOpened {
  (s.Mode s.Number e.FileName) e.Handles-B (s.Number s.Handle) e.Handles-E
    = <FClose s.Handle>
      <Open s.Mode s.Number e.FileName>;

  (s.Mode s.Number) e.Handles
    = <Open s.Mode s.Number 'REFAL' <Symb s.Number> '.DAT'>;

  (s.Mode s.Number e.FileName) e.Handles
    = <FOpen s.Mode e.FileName> : s.Handle
    = <__write __file_handles (s.Number s.Handle) e.Handles>;
}

__handle_for_num {
  s.Mode s.Number
    = <__handle_for_num_opened s.Mode s.Number <__read __file_handles>>;
}

__handle_for_num_opened {
  s.Mode s.Number e.Handles-B (s.Number s.Handle) e.Handles-E = s.Handle;
  s.Mode s.Number e.Handles
    = <Open s.Mode s.Number> <__handle_for_num s.Mode s.Number>;
}

Close {
  s.Number = <__Close-SwOpened s.Number <__read __file_handles>>;
}

__Close-SwOpened {
  s.Number e.Handles-B (s.Number s.Handle) e.Handles-E
    = <FClose s.Handle>
      <__write __file_handles e.Handles-B e.Handles-E>;
}

Get {
  s.Number
    = <FReadLine <__handle_for_num 'r' s.Number>> : s.Handle e.Line
    = e.Line;
}

Putout {
  s.Number e.Line
    = <FWriteLine <__handle_for_num 'w' s.Number> e.Line> : s.Handle
    = /* пусто */;
}

Symb {
  s.Number = <StrFromInt s.Number>;
}

Numb {
  // Пока пускай фейлится
  e.String = <IntFromStr e.String> : #Success s.Number = s.Number;
}

First {
  s.N e.Expr = <__DoFirst s.N () e.Expr>;
}

__DoFirst {
  0 (e.Scanned) e.Expr = (e.Scanned) e.Expr;
  s.N (e.Scanned) /* пусто */ = (e.Scanned) /* пусто */;

  s.N (e.Scanned) t.Next e.Expr
    = <__DoFirst <Sub s.N 1> (e.Scanned t.Next) e.Expr>;
}

// Функция слишком длинная для одного предложения
ListOfBuiltin {
  = <__ListOfBuiltin_1> <__ListOfBuiltin_2>;
}

__ListOfBuiltin_1 {
  = (1 #Mu #special)
    (2 #Add #regular)
    (3 #Arg #regular)
    (4 #Br #regular)
    (5 #Card #regular)
    (6 #Chr #regular)
    (7 #Cp #regular)
    (8 #Dg #regular)
    (9 #Dgall #regular)
    (10 #Div #regular)
    (11 #Divmod #regular)
    (12 #Explode #regular)
    (13 #First #regular)
    (14 #Get #regular)
    (15 #Implode #regular)
    (16 #Last #regular)
    (17 #Lenw #regular)
    (18 #Lower #regular)
    (19 #Mod #regular)
    (20 #Mul #regular)
    (21 #Numb #regular)
    (22 #Open #regular)
    (23 #Ord #regular)
    (24 #Print #regular)
    (25 #Prout #regular)
    (26 #Put #regular)
    (27 #Putout #regular)
    (28 #Rp #regular)
    (29 #Step #regular)
    (30 #Sub #regular)
    (31 #Symb #regular)
    (32 #Time #regular)
    (33 #Type #regular)
    (34 #Upper #regular)
    (35 #Sysfun #regular);
}

__ListOfBuiltin_2 {
  = (42 "Imp$$" #regular)
    (43 "Stop$$" #regular)
    (44 "" #regular)
    (45 #Freeze #regular)
    (46 #Freezer #regular)
    (47 #Dn #regular)
    (48 #Up #special)
    (49 #Ev-met #special)
    (50 #Residue #special)
    (51 #GetEnv #regular)
    (52 #System #regular)
    (53 #Exit #regular)
    (54 #Close #regular)
    (55 #ExistFile #regular)
    (56 #GetCurrentDirectory #regular)
    (57 #RemoveFile #regular)
    (58 #Implode_Ext #regular)
    (59 #Explode_Ext #regular)
    (60 #TimeElapsed #regular)
    (61 #Compare #regular)
    (62 #DeSysfun #regular)
    (63 #XMLParse #regular)
    (64 #Random #regular)
    (65 #RandomDigit #regular)
    (66 #Write #regular)
    (67 #ListOfBuiltin #regular)
    (68 #SizeOf #regular)
    (69 #GetPID #regular)
    (70 #int4fab_1 #regular)
    (71 #GetPPID #regular);
}

Compare {
  s.Num1 s.Num2
    = <{ '<' = '-'; '=' = '0'; '>' = '+'; } <SymbCompare s.Num1 s.Num2>>;
}

$SWAP __store;

Br {
  e.Key '=' e.Value = <__store ((e.Key) e.Value) <__store>>;
}

Dg {
  e.Key = <__Dg-SwExist (e.Key) <__store>>;
}

__Dg-SwExist {
  (e.Key) e.Store-B ((e.Key) e.Value) e.Store-E
    = e.Value <__store e.Store-B e.Store-E>;

  (e.Key) e.Store = /* пусто */ <__store e.Store>;
}

Implode_Ext {
  e.String = <Implode e.String>;
}

// Не реализованные пока функции
$ENUM Card;
$ENUM Cp;
$ENUM Dgall;
$ENUM Divmod;
$ENUM Implode;
$ENUM Last;
$ENUM Lenw;
$ENUM Lower;
$ENUM Print;
$ENUM Put;
$ENUM Rp;
$ENUM Step;
$ENUM Time;
$ENUM Upper;
$ENUM Sysfun;
$ENUM Freeze;
$ENUM Freezer;
$ENUM Dn;
$ENUM Up;
$ENUM Ev-met;
$ENUM Residue;
$ENUM System;
$ENUM Exit;
$ENUM GetCurrentDirectory;
$ENUM RemoveFile;
$ENUM TimeElapsed;
$ENUM DeSysfun;
$ENUM XMLParse;
$ENUM Random;
$ENUM RandomDigit;
$ENUM Write;
$ENUM SizeOf;
$ENUM GetPID;
$ENUM int4fab_1;
$ENUM GetPPID;
