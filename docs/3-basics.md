# Основы программирования на Рефале, Базисный Рефал

Этот раздел представляет собой неформальное введение в Рефал-5λ, учебник,
доступный для новичка, даже для новичка в программировании. Более строго
и формально язык будет рассмотрен в следующем разделе (справочник).

# Синтаксис Базисного Рефала

Термином _Базисный Рефал_ принято называть семантическое подмножество
Рефала, в котором предложения функций состоят только из двух частей,
переменные могут иметь тип s-, t- или e- (нет, например, спецификаторов
РЕФАЛа-2 \[7]) и типы символов (symbol) включают в себя только литеральные
символы (characters), числа и слова.

Подмножество Базисного Рефала семантическое. Это значит, что конкретная
синтаксическая форма рассмотренных конструкций может сильно отличаться
в разных диалектах и реализациях (например, синтаксис РЕФАЛа-2 \[7]
совсем не похож на синтаксис Рефала-5λ), но перечисленные выразительные
средства в языке существуют.

## Программа Hello, World!

В [предыдущей части](2-intro.md) нам удалось откомпилировать и запустить
программу [`hello.ref`](hello.ref), которая распечатала строчку «Hello, World!».
Давайте теперь научимся читать и понимать её исходный код.

    $ENTRY Go {                                 /* 1 */
      /* empty */ = <Prout 'Hello, World!'>;    /* 2 */
    }                                           /* 3 */

Внимательные читатели заметили отличия от программы в предыдущей главе:
добавились строчки, начинающиеся на `/*` и заканчивающиеся на `*/`.
Это комментарии — любой текст между `/*` и `*/` компилятором игнорируется
и используется для пояснения смысла программы читающему её программисту.

В эту программу были добавлены комментарии, просто нумерующие строки
(для удобства ссылки на них из текста руководства) и слово `/* empty */`,
обращающее внимание читателя на то, что в этом месте программы ничего нет.
Да, звучит на первый взгляд странно, но вскоре всё станет понятнее.

Комментарии, ограниченные знаками `/*` и `*/`, являются многострочными,
т.е. `*/` не обязана находиться в той же строке, что и предшествующая ей `/*`.
Помимо многострочных комментариев также допустимы однострочные — любая
строка, начинающаяся со знака (в первой колонке) `*`, игнорируется
компилятором.

Например, следующая программа полностью идентична предыдущей, только
замусорена большим количеством бесполезных комментариев.

    /*
      Ньютонометр безусловно не зависит от скорости вращения внутреннего
      кольца подвеса, что не кажется странным, если вспомнить о том,
      что мы не исключили из рассмотрения периодический кожух.
    */
    $ENTRY Go {                                 /* 1 */
    * Проекция на подвижные оси, несмотря на некоторую погрешность,
    * относительно не зависит от скорости вращения внутреннего кольца
    * подвеса, что не кажется странным, если вспомнить о том, что мы
    * не исключили из рассмотрения штопор. 
      /* empty */ = <Prout 'Hello, World!'>;    /* 2 */
    }                                           /* 3 */
    * Источник текста комментариев:
    /* https://yandex.ru/referats/?t=gyroscope&s=34928 */

Но вернёмся к нашей функции.

    $ENTRY Go {                                 /* 1 */
      /* empty */ = <Prout 'Hello, World!'>;    /* 2 */
    }                                           /* 3 */

Любая программа на Рефале-5λ представляет собой набор функций (язык ведь
функционального программирования всё-таки). И эта программа не исключение.
Здесь определена функция `Go`. Определение функции записывается как имя
функции, за которым следует _блок_ — тело функции, ограниченное фигурными
скобками (в строках 1 и 3 соответственно). Имя `Go` неслучайно: любая
программа на Рефале должна содержать единственное определение функции с именем
`Go` либо `GO` — процесс выполнения программы есть вычисление функции `Go`
(или `GO`) с пустым аргументом.

Непонятное `$ENTRY` перед именем функции будет прояснено в следующих разделах,
сейчас нам достаточно знать, что ключевое слово `$ENTRY` обязано предварять
точку входа (entry point) `Go` или `GO` в программу.

В строке 2 находится единственное _предложение_ функции `Go`. Предложение —
это правило, определяющее, как построить значение функции на некотором
подмножестве её аргументов. Функция в общем случае может состоять из нескольких
предложений, каждое из которых завершается знаком `;` (точкой с запятой). Точка
с запятой в конце последнего предложения может не ставиться.

Любое предложение состоит из двух частей — _левой части, образца,_ описывающей
подмножество значений аргумента функции, на котором это предложение применимо,
и _правой части, результата,_ описывающей значение функции на этом подмножестве.
Левая и правая части разделяются знаком `=` (равенства).

Примечание. _В дальнейшем будет рассматриваться расширенный синтаксис Рефала,
в котором синтаксис предложения будет уже сложнее._

В программе `hello.ref` единственное предложение говорит о том, что оно
применимо только для пустого аргумента функции (перед равенством ничего
не записано), комментарий `/* empty */` подчёркивает этот факт. Правая часть
описывает значение функции `Go` с пустым аргументом как результат вычисления
функции `Prout`, которому в качестве аргумента передаётся последовательность
знаков `Hello, World!`. Вызовы функций на Рефале, в отличие от математической
нотации, оформляются при помощи угловых скобок `<` и `>` (знаков «меньше»
и «больше»), при этом имя функции пишется не перед открывающей скобкой, а после
неё.

Функция `Prout` при любом своём аргументе вычисляет «пустоту», однако её
выполнение имеет побочный эффект — она распечатывает свой аргумент на экране.
Очевидно, ради этого побочного эффекта её и вызывают.

На самом деле, практически все программы на Рефале пишутся ради побочных
эффектов. После завершения вычисления функции `Go` (или `GO`), её результат
отбрасывается и программа завершается. Пользователю достаётся лишь то, что
было выведено на экран функциями типа `Prout`, записано в файлы, либо передано
«наружу» из процесса вычислений иным путём.

Примечание. _Есть исключения из этого правила. Во-первых, это автоматизированные
тесты (автотесты) — программы, которые запускают тестируемую функцию, проверяют
её результат и завершаются. При успешной проверке программа молча завершается,
при неуспешной — аварийно вылетает с ошибкой. Среда запуска тестов умеет
различать эти два случая и сообщает пользователю о подобных неуспешных запусках.
Другой пример — исследования в области автоматического преобразования
и верификации программ, например, при помощи суперкомпиляции. В этом случае
пишется какая-нибудь математически интересная функция на Рефале, скармливается
инструментальному средству, например, суперкомпилятору РЕФАЛа-5 SCP4 (\[1],
\[2], \[3]), после чего изучается результат преобразования или анализа этой
функции. Собственно, исследования в области разработки подобных инструментальных
средств — это одно из основных применений Рефала на сегодня.

Функция `Prout` — это одна из функций, входящих в стандартную библиотеку языка,
и по умолчанию неявно доступна к использованию в любой программе. В классическом
РЕФАЛе-5 она является встроенной, т.е. определённой неявно всегда в любой
программе. Рефал-5λ, однако, позволяет писать программы, в которых
не используется стандартная библиотека.

### Промежуточные выводы — что мы увидели в `hello.ref`

Давайте подытожим, что мы к этому моменту узнали.

* В программах можно писать комментарии, которые никак не влияют на выполнение
  программы и служат лишь для пояснения.
* Комментарии бывают двух видов: однострочные и многострочные.
* Однострочный комментарий представляет собой строку, первым символом которой
  является знак `*`, а остальные могут быть любыми.
* Многострочный комментарий может располагаться в любом месте программы, где
  допустим незначащий пробельный символ. Комментарий начинается знаками `/*`
  и заканчивается знаками `*/`.
* Программа на Рефале есть набор функций.
* Выполнение программы начинается с вызова «стартовой» функции `Go` или `GO`
  с пустым аргументом.
* Перед именем стартовой функции должно располагаться ключевое слово `$ENTRY`.
* Функция на Рефале записывается как имя функции, за которым в фигурных скобках
  следует одно или несколько предложений.
* Предложение состоит из двух частей: левой части — «образца» и правой части —
  «результата».
* Левая часть определяет подмножество значений аргумента, на котором применимо
  данное предложение.
* Правая часть определяет, каким способом будет строиться результат вычисления
  функции на этом подмножестве аргумента.
* «Пустое значение» записывается пустым местом, обычно в этом месте ставят
  комментарий `/* empty */` или `/* пусто */`.
* Последовательность печатных знаков (characters) записывается в одинарных
  кавычках: `'Hello, World!'`.
* Вызов функции `F` с некоторым аргументом `arg` записывается как `<F arg>`.

Выполнение программы является вычислением функции `Go` с пустым аргументом,
вызов функции оформляется при помощи угловых скобок, пустое значение
записывается пустым местом. Значит, правомерно будет записать, что выполнение
программмы на Рефале эквивалено вызову функции `<Go>` или `<Go /*empty*/>`.
В первом случае мы между именем функции `Go` и закрывающей скобкой `>` мы
не написали ничего (приписали вплотную одно к другому). Во втором случае
для наглядности воткнули комментарий. Обычно вызов функции с пустым аргументом
пишут без комментария внутри.

## Другие примеры программ

### Программы из нескольких предложений

Прежде чем перейти к рассмотрению других примеров, нужно дать пояснения
по синтаксису, не отражённые в листинге `hello.ref`.

Во-первых, Рефал — язык со свободным синтаксисом. В нём переход на новую
строку — точно такой же пробельный символ, как и пробел или табуляция. Пара
исключений — открывающая и закрывающая кавычки должны располагаться в одной
строке (разрыв строки не может располагаться внутри последовательности
символов) и символ перевода строки завершает однострочный комментарий
по определению.

Во-вторых, каждый из знаков внутри одинарных кавычек является самостоятельным,
следующие записи эквивалентны: `'Hello`, `'Hel' 'lo'`, `'H' 'e' 'l' 'l' 'o'`.

В-третьих, именем функции может быть любая последовательность букв, цифр,
знаков `_` («прочерк») и `-` («дефис»), начинающаяся с прочерка или буквы.
Например, `Go`, `Hello`, `A-plus-B`, `_remove_file`, `ANSWER_42`. Строчные
и прописные буквы различаются, т.е. имена `hello`, `Hello` и `HELLO` различные.

Примечание. _Классическая реализация РЕФАЛа-5 не поддерживает имена, которые
начинаются на прочерк._

**Пример 1.** Напишем функцию, которая складывает две двоичные цифры.

    BinAdd {
      '0' '0' = '0';
      '0' '1' = '1';
      '1' '0' = <BinAdd '0' '1'>;
      '1' '1' = '10';
    }

Левые части предложений можно было записать и слитно, например `'00'`,
на работу программы это бы никак не повлияло — они написаны раздельно для
удобочитаемости.

Нетрудно понять, что первое предложение применимо, когда аргумент функции —
`'00'`, т.е. результатом вызова `<BinAdd '00'>` будет `'0'`, со вторым
и четвёртым предложением тоже всё понятно.

Третье предложение говорит о том, что результат вызова функции
`<BinAdd '10'>` точно такой же, как и `<BinAdd '01'>`, от перемены мест
слагаемых сумма не меняется. Можно было написать в правой части сразу `'1'`,
вызов функции был добавлен в правую часть ради демонстрации самого вызова.

Областью определения этой функции будут пары символов `'00'`, `'01'`, `'10'`,
`'11'`. При попытке вызвать эту функцию с аргументом вне области определения
программа аварийно завершится (т.н. ошибка невозможности отождествления,
«recognition impossible»).

**Пример 2.** Напишем функцию, которая вычитает две двоичные цифры.

    BinSub {
      '0' '0' = '0';
      '1' '1' = '0';
      '1' '0' = '1';
      '0' '1' = '-' <BinSub '1' '0'>;
    }

Здесь всё аналогично, кроме последнего предложения. В правой части четвёртого
предложения записан символ минуса, вслед за которым находится вызов функции
`BinSub`. Что это значит? Это значит, что результатом вызова функции
`<BinSub '0' '1'>` будет знак `'-'`, за которым следует результат вычисления
`<BinSub '1' '0'>` — `'1'`. Т.е. результат `<BinSub '0' '1'>` будет равен
`'-' '1'` или `'-1'`.

**Пример 3.** Напишем функцию, которая проверяет равенство двух двоичных
чисел, не больших 2 (т.е. 10 в двоичной записи) и не меньших -1. Будем считать,
что оба числа в аргументе функции разделяются знаком `'='`.

    IsEqual {
      '-1=-1' = 'True'; '-1=0' = 'False'; '-1=1' = 'False'; '-1=10' = 'False';

      '0=-1' = 'False'; '0=0' = 'True'; '0=1' = 'False'; '0=10' = 'True';

      '1=-1' = 'False'; '1=0' = 'False'; '1=1' = 'True'; '1=10' = 'False';

      '10=-1' = 'False'; '10=0' = 'False'; '10=1' = 'True'; '10=10' = 'True';
    }

Да, скучно. Да, длинно. Позже мы увидим, как можно сократить эту запись.

**Пример 4.** Напишем функцию `Go`, демонстрирующую коммутативность сложения
и некоммутативность вычитания.

    $ENTRY Go {
      = <Prout '1+0=0+1? ' <IsEqual <BinAdd '1' '0'> '=' <BinAdd '0' '1'>>>
        <Prout '1-0=0-1? ' <IsEqual <BinSub '1' '0'> '=' <BinSub '0' '1'>>>;
    }

Функции `BinAdd`, `BinSub`, `IsEqual` и `Go` можно положить в один файл
(назовём его [`binmath-1.ref`](binmath-1.ref)) и откомпилировать следующей
командой:

    srefc binmath-1.ref

то получится исполнимый файл `binmath-1.exe` (или `binmath-1` на unix-like),
который при запуске напечатает

    1+0=0+1? True
    1-0=0-1? False

В этом разделе мы рассмотрели функции, у которых в левых частях предложений
записаны различные, но _фиксированные_ значения. И очевидно, областями
областями определения таких функций являются все явно перечисленные значения
образцов. Понятно, что для написания нетривиальных программ этого чертовски
мало: можно задать только функции с конечной областью определения и для каждого
из значений аргумента придётся написать предложение. Это привело к тому,
что даже такая простая функция, как `IsEqual` потребовала целых 16 предложений.

О том, как писать функции с бесконечной областью определения, мы узнаем
в следующем параграфе.

У внимательного читателя наверняка возник вопрос: а что будет, если несколько
предложений будут иметь одинаковые левые части? Не будет ли это синтаксической
ошибкой? Ответ: не будет. Если аргумент функции таков, что становятся
применимыми несколько предложений, то приоритет имеет то, которое написано выше.
Например, результатом вызова `<F 'A'>` будет `'1'`, а не `'3'`:

    F {
      'A' = '1';
      'B' = '2';
      'A' = '3';
    }

Первое предложение имеет приоритет над третьим.

## Переменные

Выше было сказано, что левая часть определяет подмножество значений аргумента,
при котором применимо это предложение. Но пока мы рассмотрели только случаи
подмножеств, состоящих из одного единственного элемента.

Рефал позволяет записывать в левых частях выражения (точное определение
понятия «выражение» будет дано позже), которые, помимо явно заданных символов,
содержат неизвестные произвольные фрагменты — _переменные_.

Множества значений, которые могут принимать переменные, определяются _типом_
переменной. В Рефале есть три типа переменных: s-, t- и e-переменные.
t-переменные мы рассмотрим позже, когда будем изучать структурные скобки.

Значением _s-переменной_ или _переменной символа_ может быть любой одиночный
символ (symbol). Значением _e-переменной_ или _переменной выражения_ может быть
любой фрагмент аргумента функции, в том числе пустой (не совсем любой, на самом
деле, но об этом позже).

Переменная записывается как признак типа (`s`, `t`, `e`), за которой следует
знак `.` («точка») и имя переменной — некоторая последовательность букв и цифр.
Имя переменной часто называют индексом переменной.

Если в выражении переменная встречается несколько раз, то она называется
_повторной,_ все её вхождения должны иметь одинаковое значение.

Рассмотрим некоторые выражения с переменными:

* `s.1 s.2 s.3` — три любых символа, например `'ABC'`, `'999'`, `'@#$'`.
* `s.A s.A s.A` — три любых _одинаковых,_ символа, например `'666'`, `'www'`.
* `s.Edge s.Middle s.Edge` — три любых символа, причём первый и последний
  должны совпадать. Например: `'@$@'`, `'kek'`, `'^_^'`.
* `s.first e.middle s.last` — любое выражение, содержащее как минимум два
  символа. Например: `'Hello'`, `'10'`, `'0_o'`.
* `s.EDGE e.CENTER s.EDGE` — любое выражение как минимум из двух символов,
  начинающееся и заканчивающееся на одинаковый символ. Например: `'++'`,
  `'LOOOL'`, `'revolver'`.
* `'(' e.Inner ')'` — выражение, начинающееся и заканчивающееся на скобку.
  Примеры: `'()'`, `'()()'`, `'(ok)'`.
* `e.Key '=' e.Value` — выражение, содержащее хотя бы один знак равенства.
  Например: `'='`, `'x=1'`, `'-1=10'`, `'A=B==C=D'`.
* `e.Eq e.Eq` — выражение чётной длины, которое можно разбить на две
  одинаковые половинки: `'ABCABC'`, `'8888'`, пустое выражение (да, его
  тоже можно разбить на два пустых).

Переменные могут встречаться как в левой части предложения, так и в правой.
При этом в правой части предложения могут использоваться только те переменные,
которые есть в левой.

Теперь мы должны уточнить процесс выполнения функции на Рефале.

1. Выбирается предложение, из левой части которого можно получить аргумент
   функции путём замены переменных в ней на некоторые значения. Если таких
   предложений несколько, выбирается с наименьшим номером. Если такого
   предложения не нашлось, то программа завершается с ошибкой отождествления
   (recognition impossible).
2. Фиксируются значения переменных, при подстановке которых в левую часть
   выбранного предложения, та обращается в аргумент функции. Если таких
   наборов значений переменных (подстановок) несколько, то фиксируется
   та из них, при которой самая левая e-переменная принимает кратчайшее
   значение, если это не разрешает неоднозначности, то рассматривается
   следующая e-переменная и т.д. (в следующем разделе мы рассмотрим этот
   процесс подробнее).
3. В правой части выбранного предложения заменяются переменные на их
   значения. После чего вычисляются функции в правой части.

В следующем разделе этот процесс будет рассмотрен более детально и формально.


**Пример 5.** Теперь, вооружённые новым знанием, мы можем упростить функцию
`IsEqual`:

    IsEqual {
      e.Equal '=' e.Equal = 'True';
      e.Left '=' e.Right = 'False';
    }

Видно, что, во-первых, функция сократилась с 16 предложений до двух, во-вторых,
её область определения существенно расширилась — она принимает не только
пары двоичных чисел, но и вообще любые выражения, содержащие знак `'='`.

Первое предложение функции применимо к любым выражениям, которые содержат
хотя бы один знак равенства, и при этом их можно разбить так, что часть,
предшествующая знаку `'='`, будет совпадать со следующей за ней.

Второе предложение применимо к любому аргументу, содержащему знак равенства.

Очевидно, что для аргументов вида `'ab=ab'` применимы оба предложения, первое,
поскольку до и после знака `'='` находится одинаковые выражения, второе,
потому что просто содержит знак равенства. Но как выше было сказано,
предшествующие предложения имеют приоритет над последующими, поэтому первое
предложение будет обрабатывать только случаи равных «половинок», а второму
будут доставаться все остальные (неравные).

Если оба предложения поменять местами, то результатом функции (на своей области
определения) всегда будет `'False'`.

**Пример 6.** Функция `IsPalindrom`, проверяющая, является ли аргумент функции
палиндромом.

    IsPalindrom {
      s.OneSymbol = 'True';
      /* empty */ = 'True';
      s.Equal e.Middle s.Equal = <IsPalindrom e.Middle>;
      e.Other = 'False';
    }

Определение этой функции можно прочитать так. Строка из одного символа является
палиндромом. Пустая строка тоже является палиндромом. Строка, которая начинается
и заканчивается на один и тот же символ, является палиндромом, если «средняя»
часть строки тоже является палиндромом. Любая другая строка палиндромом
не является.

Вообще, определения функций на ФЯ часто могут читаться как математические
определения.

**Пример 7.** Напишем функцию сложения двух двоичных чисел произвольной длины.
Функции на Рефале принимают один аргумент, а здесь мы хотим передать два.
В первом варианте функции сложения мы избежали этого затруднения, передавая
в функцию два _символа._ Теперь нам надо передать два выражения произвольной
длины. Каждый из аргументов может состоять только из знаков `'0'` и `'1'`,
поэтому можно между ними поместить любой символ, кроме ноля и единицы — по нему
можно будет понять, где кончается один аргумент и начинается другой. Будем
использовать символ `'+'` для наглядности.

Примечание. _Позже мы узнаем гораздо более простой, эффективный и универсальный
способ разделения аргументов._

    BinAdd {
      e.Num1 '0' '+' e.Num2 '0' = <BinAdd e.Num1 '+' e.Num2> '0';
      e.Num1 '0' '+' e.Num2 '1' = <BinAdd e.Num1 '+' e.Num2> '1';
      e.Num1 '1' '+' e.Num2 '0' = <BinAdd e.Num1 '+' e.Num2> '1';
      e.Num1 '1' '+' e.Num2 '1'
        = <BinAdd <BinAdd e.Num1 '+' '1'> '+' e.Num2> '0';
      /* empty */ '+' e.Num2 = e.Num2;
      e.Num1 '+' /* empty */ = e.Num1;
    }

Нетрудно заметить, что функция реализует сложение двух двоичных чисел в столбик.
Если последние цифры обоих чисел — `'1'` и `'1'`, то происходит перенос
в следующий разряд — эта дополнительная единица прибавляется к первому
аргументу.

### Промежуточные выводы

Давайте подытожим:

* В левых и правых частях предложения могут находиться переменные — фрагменты
  выражений, которые могут заменяться на произвольные значения в соответствии
  с их типом.
* S-переменные могут заменяться на любой символ.
* E-переменные могут заменяться на произвольное выражение.
* Синтаксис имён переменных: `s.varname`, `e.ab123`, `s.123ab`.
* Выполняется то предложение в функции, для левой части которого можно
  подобрать такую подстановку значений переменных, которая преобразует левую
  часть в аргумент функции.
* Та же подстановка производится и в правую часть предложения.

## Структурные скобки

Чисто математически изученного подмножества Рефала достаточно для записи любого
сколь угодно сложного алгоритма (см. \[4, лекция № 6]). Но на практике этого
мало: изученные средства позволяют работать только с «плоскими» строками
символов, тогда как многие нетривиальные алгоритмы требуют уже иерархически
организованных данных.

Что такое иерархия данных? Это возможность работать с некоторым фрагментом
данных, как с одним объектом, абстрагируясь от его внутренней сложной структуры.
Например, мы можем работать с текстовым документом как с файлом: перемещать
его из папки в папку, копировать, стирать, и при этом не заботиться о том,
что внутри него может находиться текст, таблицы, картинки и т.д. На определённом
уровне иерархии нас это не интересует.

Для того, чтобы в Рефале с выражением работать как с единым объектом, его
заключают в круглые скобки, которые называют _структурными скобками._ Такой
объект, его называют _скобочный терм,_ сам может быть частью другого выражения,
которое, в свою очередь тоже может быть заключено в круглые скобки. Так в Рефале
строятся иерархические вложенные данные. Символы (symbols), которые мы
рассматривали до этого, тоже являются термами. Таким образом, выражение
на Рефале состоит из термов, каждый из которых может быть либо символом, либо
скобочным термом, который внутри содержит другое выражение на Рефале.

В отличие от круглых, _структурных_ скобок, угловые скобки вызова функции
в правых частях предложений называются _скобками конкретизации,_ _скобками
активации_ или _скобками вызова функции_ (все эти словосочетания — синонимы).

**Пример 8.** Выражение

    ('abc') 'def' (('ghi') 'j' ('klm') ()) 'nop' ((('rst')))

состоит из 9 термов. Первый терм — скобочный, содержит в себе выражение из трёх
термов-символов, следующие три — печатные знаки `'def'`, следующий — опять
скобочный, состоящий из трёх скобочных термов и одного символа, при этом
его последний скобочный терм содержит пустое выражение.

В выражении на Рефале скобки должны обязательно образовывать правильную
скобочную структуру как в левой, так и в правой части предложений. При этом
в правой части предложений круглые и угловые скобки не могут накладываться
(overlap) друг на друга.

Уточним наше понимание переменных в свете нового знания.

* E-переменные могут принимать произвольную последовательность _термов,_
  т.е. значением e-переменной может быть только выражение с правильной
  скобочной структурой.
* Значением _t-переменных_ (записываются как `t.varname`) может быть любой
  одиночный терм — как символ (symbol), так и выражение в скобках.

**Пример 9.** Изобразим родословную Пушкина в виде выражения на Рефале
Каждого персонажа родословной мы будем изображать в виде скобочного терма,
который содержит имя персонажа и два терма: отец и мать. Причём, если
предкок известен, он изображается в виде такого же персонажа, если нет —
на его месте будет располагаться символ `'?'`. Таким образом, каждый
из персонажей может быть сопоставлен с образцом вида

    (e.Name t.Father t.Mother)

Собственно, родословная \[5, 6]:

    (
      'Александр Сергеевич Пушкин'
      (
        'Сергей Львович Пушкин'
        (
          'Лев Александрович Пушкин'
          '?'   /* не известен отец */
          (
            'Евдокия Ивановна Головина'
            '?' /* не известен отец */
            '?' /* не известна мать */
          )
        )
        (
          'Ольга Васильевна Чичерина'
          ('Василий Иванович Чичерин??')
          '?'   /* не известна мать */
        )
      )
      (
        'Надежда Осиповна Пушкина (Ганнибал)'
        (
          'Осип Абрамович Ганнибал'
          ('Абрам Петрович Ганнибал (арап Петра Великого)??')
          ('Христина-Регина фон-Шеберг??')
        )
        ('Мария Алексеевна Пушкина??')
      )
    )

Примечание. _На самом деле родословная А. С. Пушкина известна гораздо глубже,
здесь просто для наглядности были пропущены некоторые предки на разных уровнях
иерархии._

**Пример 10.** Давайте напишем функцию, которая принимает генеалогическое
древо и ветвь предка в виде цепочки знаков вида `'MFFM…'` — где `'M'`
означает мать, `'F'` — отец и находит соответствующего предка.

Например, `'F'` — отец, `'FF'` — дед по отцу, `'MM'` — бабка по матери,
`'FM'` — бабка по отцу, `'FMM'` — прабабка по бабке по отцу, пустое выражение —
сам персонаж.

    FindAncestor {
      /* продвигаемся по отцу */
      (e.Name t.Father t.Mother) 'F' e.Branch
        = <FindAncestor t.Father e.Branch>;

      /* продвигаемся по матери */
      (e.Name t.Father t.Mother) 'M' e.Branch
        = <FindAncestor t.Mother e.Branch>;

      /* у неизвестного персонажа неизвестны и предки */
      '?' e.Branch = '?';

      /* Ветвь закончилась — искомый человек текущий */
      (e.Name t.Father t.Mother) /* empty branch */ = e.Name;
    }

Иначе говоря, чтобы по родословной найти какого-то предка по отцу (ветвь
начинается с `'F…'`), нужно взять родословную отца (поле `t.Father`)
и поискать предка в ней (отбросив от начала ветви `'F'`) — именно это
делает первое предложение. Второе предложение аналогично.

Если родословная на некотором этапе неизвестна, то и любой предок будет
неизвестен — этот случай обрабатывает третье предложение. Если ветвь
пустая (явно указана пустая ветвь или опустошилась за несколько итераций),
то корень текущей родословной и есть искомый человек — последнее четвёртое
предложение.

**Пример 11.** Давайте напишем программу, которая распечатывает некоторых
предков Пушкина ([`pushkin.ref`](pushkin.ref)).

    $ENTRY Go {
      = <Prout <FindAncestor <Pushkin> 'FF'>>
        <Prout <FindAncestor <Pushkin> 'FFF'>>
        <Prout <FindAncestor <Pushkin> 'MFF'>>
        <Prout <FindAncestor <Pushkin> 'MFM'>>
        <Prout <FindAncestor <Pushkin> 'F'>>
        <Prout <FindAncestor <Pushkin> 'FM'>>
        <Prout <FindAncestor <Pushkin> 'FMF'>>
        <Prout <FindAncestor <Pushkin> 'FMFM'>>
    }

    FindAncestor {
      …см. выше…
    }

    Pushkin {
      = (
          'Alexander Sergeevich Pushkin'
          (
            'Sergey Lvovich Pushkin'
            (
              'Lev Alexandrovich Pushkin'
              '?'   /* unknown father */
              (
                'Evdokiya Ivanovna Golovina'
                '?' /* unknown father */
                '?' /* unknown mother */
              )
            )
            (
              'Olga Vasilyevna Chicherina'
              ('Vasiliy Ivanovich Chicherin??')
              '?'   /* unknown mother */
            )
          )
          (
            'Nadezhda Osipovna Pushkina (Gannibal)'
            (
              'Osip Abramovich Gannibal'
              ('Abram Petrovich Gannibal (arap of Peter the Great)??')
              ('Christina Regina fon Sioberg??')
            )
            ('Mariya Alexeevna Pushkina??')
          )
        )
    }

Функция `Pushkin` состоит из одного предложения — при любом аргументе возвращает
константу. Т.е. фактически она и является определением константы. Остальное всё
должно быть понятно.

Примечание. _Имена предков записаны транслитом — на некоторых операционных
системах вывод кириллицы на экран не работает или работает криво. В будущих
версиях это будет исправлено._

Для компиляции и запуска программы под Windows введите:

    srefc pushkin.ref
    pushkin.exe

Под Linux:

    srefc pushkin.ref
    ./pushkin

Программа должна распечатать следующее:

    Lev Alexandrovich Pushkin
    ?
    Abram Petrovich Gannibal (arap of Peter the Great)
    Christina Regina fon Sioberg
    Sergey Lvovich Pushkin
    Olga Vasilyevna Chicherina
    Vasiliy Ivanovich Chicherin
    ?

Выше мы, когда хотели вызвать функцию с несколькими аргументами, передавали их,
разделяя каким-нибудь знаком, который не может встречаться внутри самих
аргументов (например, `'='` в функции `IsEqual` или `'+'` в функции `BinAdd`).
Более грамотной практикой при передаче нескольких аргументов является их
«заворачивание» в скобочные термы. Например, если функция принимает 3 аргумента
произвольной длины — обозначим их как `e.1`, `e.2`, `e.3`, — то их можно
передать как `(e.1) e.2 (e.3)`, `e.1 (e.2) (e.3)`, `(e.1) (e.2) e.3`
и `(e.1) (e.2) (e.3)`. Последний вариант, помещение каждого аргумента
в скобочный терм, избыточен, но иногда делает программы более понятными. Вообще,
если передаётся в функцию N аргументов, то достаточто завернуть в скобки
только N−1 аргументов.

В следующем разделе мы увидим, что заворачивание аргументов в скобки вместо
символов разделителей не только проще (не нужно придумывать символ-разделитель),
но и эффективнее с точки зрения времени выполнения программы.

Функции `IsEqual` и `BinAdd` мы можем теперь переписать так:

    IsEqual {
      (e.X) (e.X) = 'True';
      (e.X) (e.Y) = 'False';
    }

    BinAdd {
      (e.Num1 '0') e.Num2 '0' = <BinAdd (e.Num1) e.Num2> '0';
      (e.Num1 '0') e.Num2 '1' = <BinAdd (e.Num1) e.Num2> '1';
      (e.Num1 '1') e.Num2 '0' = <BinAdd (e.Num1) e.Num2> '1';
      (e.Num1 '1') e.Num2 '1' = <BinAdd (<BinAdd (e.Num1) '1'>) e.Num2> '0';
      (/* empty */) e.Num2 = e.Num2;
      (e.Num1) /* empty */ = e.Num1;
    }

## Другие типы символов: числа

Выше по тексту мы использовали понятия символы (symbols) и печатные знаки
(characters) как синонимы. Но это не так. Помимо печатных знаков (characters),
которые далее по тексту мы будем называть _символами-литерами_ (characters),
Рефал поддерживает и другие виды символов.

Вообще в Рефале _символ_ (symbol) — это объект, который невозможно разложить
при помощи образца на более мелкие фрагменты. Помимо символов-литер, в Рефале
есть ещё символы-числа и символы-слова. Символы-слова мы рассмотрим в следующем
параграфе.

_Символ-число_ или _макроцифра_ (macrodigit) — это число в диапазоне от 0
до 2³²−1, записанное в десятичном виде. Примеры: `1`, `10`, `65536`,
`4294967295` (самая большая макроцифра).

Для работы с макроцифрами в Рефале есть встроенные арифметические функции:

* `Add` — сложение,
* `Sub` — вычитание,
* `Mul` — умножение,
* `Div` — деление (вычисление частного),
* `Mod` — вычисление остатка от деления,
* `Divmod` — возвращает и частное, и остаток,
* `Compare` — сравнивает два числа,
* `Numb` — преобразует цепочку литер в число (в десятичной записи),
* `Symb` — преобразует число в цепочку литер (тоже в десятичной записи).

Читателя должно заинтересовать такое странное слово как «макроцифра». Объясняем:
арифметические функции реализуют арифметику произвольной точности (длинную
арифметику, arbitrary-precision arithmetic) — работу с числами произвольной
длины. И для представления таких чисел используются цепочки макроцифр.

Точно также, как в обычной десятичной записи число 1864 означает

    1864 = 1×10³ + 8×10² + 6×10 + 4

в Рефале длинное число, например, 10000000000000000000000 представляется как
`542 434162106 2990538752`, что обозначает

    10000000000000000000000 = 542×(2³²)² + 434162106×2³² + 2990538752

т.е. основанием системы счисления является не 10, а 2³². Для записи
отрицательных чисел в начале цепочки макроцифр следует поставить литеру `'-'`,
в начало положительных чисел можно записывать необязательный знак `'+'`.

Т.е. числа в общем случае являются цепочками термов произвольной длины
(e-переменными), в виде одного символа представляются только небольшие
положительные числа (влезающие в одну макроцифру).

Функции `Add`, `Sub`, `Mul`, `Div`, `Mod`, `Divmod` и `Compare` принимают
два числа. Если первое число — небольшое положительное (макроцифра), то оно
макроцифрой и записывается. Иначе первый аргумент записывается в виде скобочного
терма. Второй аргумент пишется вслед за первым.

Функция `Divmod` возвращает частное в скобках и остаток. Функция `Compare`
возвращает знак разности первого и второго числа, соответственно `'+'`, `'0'`
или `'-'`, когда первое больше, равно или меньше второго.

Функция `Numb` принимает строку. Если строка начинается с необязательного
знака и десятичных цифр, то функция возвращает число, представимое этими
цифрами. Иначе (если аргумент не начинается с десятичной записи числа) функция
возвращает `0`.

Функция `Symb` обратна функции `Numb` — преобразует число в десятичную запись

**Пример 12.** Некоторые вызовы функций и их результаты рядом:

    <Add 1 2>                          3
    <Sub 1 2>                          '-' 1
    <Add 1 2 3>                        2 4
    <Add (1) 2 3>                      2 4
    <Add (2 3) 1>                      2 4
    <Add ('-' 7) 17>                   10
    <Mul (1 1) 1 1>                    1 2 1
    <Div (1 2 3) 1 1>                  1 1
    <Mod (1 2 3) 1 1                   2
    <Divmod (1 2 3) 1 1>               (1 1) 2
    <Compare 10 13>                    '-'
    <Compare (0 0 100) 0 100>          '0'
    <Compare (1 2) 1 0 0>              '-'
    <Numb '10abcdef'>                  10
    <Numb '-11113'>                    '-' 11113
    <Numb 'not a number>               0
    <Numb '10000000000000000000000'>   542 434162106 2990538752
    <Symb 123456>                      '123456'
    <Symb '-' 1 1>                     '-4294967297'
    <Symb 542 434162106 2990538752>    '10000000000000000000000'

**Пример 13.** Функция вычисления факториала. Напомним, что факториал числа N
(обозначается N!, читается «эн факториал») — это произведение всех чисел от 0
до N включительно. Т.е. N! = 1×2×…×(N−1)×N. Считается, что 0! = 1.

Можно заметить, что N! = 1×2×…×(N−1)×N = (1×2×…×(N−1))×N = (N−1)!×N. При этом,
1! = (1−1)!×1 = 0!×1 = 1×1 = 1. Воспользуемся этим, чтобы написать функцию.

    Fact {
      0 = 1;
      s.N = <Mul (<Fact <Sub s.N 1>>) s.N>;
    }

    $ENTRY Go {
      = <Prout '1!   = ' <Symb <Fact 1>>>
        <Prout '10!  = ' <Symb <Fact 10>>>
        <Prout '100! = ' <Symb <Fact 100>>>
    }

Заметим, что первый аргумент функции `Mul` мы завернули в скобки, а первый
аргумент `Sub` — нет. Почему? Потому что уже

    13! = 6227020800 > 4294967296 = 2³².

Т.е. для аргументов, больших 12, факториал уже перестанет влезать в одну
макроцифру. У функции `Sub` первый аргумент всегда влезает в макроцифру,
поскольку он изначально задаётся макроцифрой и на каждом шаге рекурсии он
только уменьшается. Приведённая выше программа [`fact.ref`](fact.ref)
напечатает на экране следующее (последняя строка слишком длинная, для
удобства чтения разбита на части)

    1!   = 1
    10!  = 3628800
    100! = 9332621544394415268169923885626670049071596826438162146859↓
    29638952175999932299156089414639761565182862536979208272237582511↓
    85210916864000000000000000000000000

## Другие типы символов: слова

При программировании на Рефале часто возникает потребность промаркировать
различные виды объектов или состояний: функция может завершиться успешно
или неуспешно, конечный автомат может иметь одно из нескольких состояний,
программа может оперировать объектами разных типов (представление токенов
в лексическом анализе, узлов синтаксического дерева в синтаксическом
анализе и т.д.).

Например, мы хотим написать функцию, которая читает конфигурационный файл
и вызывается таким вот образом:

    <ReadConfig e.FileName>

Эта функция может либо успешно прочитать конфигурационный файл и вернуть
данные конфигурации (мы не будем рассматривать, как они устроены). Функция
может обнаружить, что файл конфигурации не существует (в этом случае программа,
к примеру, будет использовать некоторую конфигурацию по умолчанию). А может
случиться и так, что файл имеет неверный формат, и прочитать его не удалось —
программа должна будет выдать понятное сообщение об ошибке и завершиться.

Следовательно, функция нам должна вернуть три разных результата, которые
мы должны уметь различить. В первом случае — данные конфигурации. Во втором —
признак того, что файла нет. В третьем — сообщение о синтаксической ошибке
в файле.

Можно эти случаи просто пронумеровать. В первом случае функция вернёт
макроцифру `1` и данные, во втором — только макроцифру `2` и в третьем —
число `3` и сообщение об ошибке. Да, результаты функции можно будет различить,
но главный недостаток такого решения — числа сами за себя не говорят.
Программист будет вынужден помнить, что, например, для этой функции цифра
`3` означает синтаксическую ошибку, а `2` — отсутствие файла, и не наоборот.
А если таких разных функций много? Придётся учить, что каждое число значит
применительно к каждой функции.

Можно возвращать последовательность литер. Например, в первом случае
выводить `'Success' (e.Configuration)`, во втором — `'File not found'`,
в третьем — `'Syntax error' (e.ErrorMessage)`. Текстовые строки уже говорят
сами за себя, понимать программу становится легко. Но у этого решения тоже
есть свой недостаток — текстовые строки — выражения произвольной длины,
и когда функция возвращает другие данные произвольной длины, например,
конфигурацию или сообщение об ошибке, их приходится отделять круглыми скобками.
Более того, избыточно передавать пару десятков символов (symbols), когда
для различия достаточно одного.

Для различия достаточно одного. Может нам сократить по первой букве? Тогда
вместо `'Success' (e.Configuration)` мы запишем `'S' e.Configuration`,
вместо `'File not found'` запишем `'F'`, вместо `'Syntax error (e.ErrorMessage)`
запишем `'S' e.ErrorMessage`. Стоп, стоп, стоп. Чем у нас тогда будет
отличаться первый и последний случай? Они оба начинаются на знак `'S'`,
после которого может следовать выражение произвольной длины. Сократить
по первой букве не получилось — придётся выбирать какие-то другие буквы.
Но тогда всплывёт та же проблема, что и с числами — одиночные буквы плохо
сами за себя говорят.

Вот для решения этой проблемы в Рефале существуют _символы-слова
(символы-идентификаторы, составные символы)._ Это символы (symbols),
сопоставляются с обычной s-переменной, но имеют вид слова без кавычек.
Внешний вид идентификатора точно такой же, как у имени функции: он состоит
из букв, цифр, прочерков и дефисов, но при этом обязан начинаться с буквы
или прочерка. Примеры идентификаторов: `Success`, `FILE_NOT_FOUND`,
`syntax-error`, `True`, `False`, `Error-404-Not-found`, `o_0` и т.д.

Теперь уже очевидно, что для нашей функции `ReadConfig` в возвращаемом значении
нужно использовать идентификаторы. Например, `Success e.Config`, `FileNotFound`
и `SyntaxError e.Message`.

Рефал-5λ, как и классический РЕФАЛ-5, допускает использование произвольных
строк символов в качестве идентификаторов. Для этого строку нужно заключить
в _двойные_ кавычки: `"This is one symbol:-)"`. На практике они используются
довольно редко, но могут быть полезны, когда хочется использовать в качестве
признака-идентификатора комбинацию знаков, которую без кавычек записать нельзя.
Например, `"*="`, `"C++"`, `"=0?"` и т.д. Можно записывать в кавычках слова,
которые пишутся и без кавычек тоже — `"Success"`, `"SyntaxError"` — они будут
идентичны этим же словам без кавычек.

# Ссылки
1. А. П. Немытых, Суперкомпилятор SCP4: общая структура, ISBN 978-5-382-00365-8,
   Издательство УРСС, Москва, 2007.
2. А. П. Немытых, В. Ф. Турчин, Суперкомпилятор SCP4: исходные тексты,
   on-line демонстрация, ([online]: <http://www.botik.ru/pub/local/scp/refal5/>),
   2000.
3. А. П. Немытых, В. Ф. Турчин, Суперкомпилятор SCP4: on-line демонстрация,
   ([online]: <http://refal.botik.ru/scp_demo/>), 2000. 
4. А. П. Немытых, Лекции по языку программирования Рефал.
   Сборник трудов по функциональному языку программирования Рефал, том I
   // Под редакцией А. П. Немытых. — Переславль-Залесский: Издательство
   «СБОРНИК», 2014, 194 с. — ISBN 978-5-9905410-1-6 — стр. 120.
   Доступно в Интернете: <http://refal.botik.ru/library/refal2014_issue-I.pdf>
5. Родословная Пушкина. Предки великого поэта :: SYL.ru,
   режим доступа:
   <https://www.syl.ru/article/183012/new_rodoslovnaya-pushkina-predki-velikogo-poeta>
   (дата обращения: 07.01.2018).
6. Пушкин, Александр Сергеевич // Википедия. [2003—2018]. Дата обновления: 05.01.2018.
   URL: <http://ru.wikipedia.org/?oldid=90075965> (дата обращения: 07.01.2018).
8. А. Ю. Алешин, А. Г. Красовский, С. А. Романенко, В. Ю. Шерстнев, Система
   программирования РЕФАЛ-2 для IBM PC, PDP-11 и VAX-11. Руководство пользователя,
   Москва, 1991, URL: <http://refal.net/~belous/download/refal2/refal2-doc.zip>,
   (дата обращения: 08.01.2018)
