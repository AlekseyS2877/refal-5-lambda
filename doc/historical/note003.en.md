> This is translation of historical paper [note003.txt](note003.txt) from Russian.

The purpose of this lab is to add to Simple Refal higher-order functions.
It is assumed for lambda functions to use the syntax, similar to the Refal 7
syntax, with the constraints that (a) sentences always have the form pattern =
result, (b) nameless functions.

# Terminology agreement.
Under the _lambda-function,_ hereinafter we shall mean a functional block,
declared in the result expression. The concept of a function is static, that
exists only at the time of writing the code and compiling the program.

As a _global function_ we will understand the usual function of the Simple Refal
in a way, in which it was presented in previous versions of the language.

The _closure_ will mean an instance of the function (both lambda and global
functions) that exists during the execution of the program and is present in
the view field of the abstract Refal machine. The closure can be performed
(activated) if it is after the opening angle bracket. Closure is a
generalization of the concept of “pointer to a function” of previous versions
of the Simple Refal.

The relationship between a function (global or local) and closure is the same
as the relationship between the class and the object in OOP.

Because (in this version) there is no pattern that could break up the closure
into smaller elements (smaller than the function name in the case of a global
function instance), the closure is an atom and can be mapped to an s-variable.

Initially, for lambda functions, I was going to use the term “local function”,
because The same term was used by Skorobogatov in the article “Refal language
with higher-order functions”, but there is already existing (in the internal
documentation for the Simple and Modular Refal) terminology, according to which
global functions are divided into entry functions (accessible from outside the
module) and local functions ( not accessible from the outside of the module).
In order not to cause terminological confusion, I decided to use the term
“lambda function”.

One way to implement closures that will be implemented in this lab is the
closure representation as a pair (pointer function, context), where the pointer
to a function is a pointer to some global function with a unique name that
accepts the closure argument + context as an argument, the context is a list of
free variables of the lambda function in the terminology of the lambda
calculus, so let us assume that the following function generates a closure:

    CreateClosure {
      s.1 e.2 = {e.3 = e.2 s.1 e.3; };
    }

The closure generated by the `<CreateClosure 'Hello'>` call will be represented
by a pair `(CreateClosure#1, 'H' 'ello')` where the CreateClusure#1 function
is automatically generated and looks like this:

> Misstype in Russian original: must be `(CreateClosure#1, 'H' ('ello'))`,
> (Mazdaywik)

    CreateClosure#1 {
      s.1 (e.2) e.3 = e.2 s.1 e.3;
    }

The closure call `(s.Function e.Context)` with some argument `e.Arg` comes down
to the call to `s.Function` with the argument `e.Context e.Arg`, for the
following example:

    <<CreateClosure 'Hello'> ' World'>

is equivalent of

    <CreateClosure#1 'H' ('ello') ' World'>

the result of which will be `'elloH World'`.

Since in the case of higher-order functions, functions are full-fledged data
objects, closures need to provide the ability to copy. Copy the entire context
when copying an object expression (if the result expression includes more
variables with a given name than in the pattern one), it is undesirable. this is
not only a decrease in the effectiveness of the program, but also a surprise
for the programmer: the copying of atoms must be performed for a constant time
in the list implementation.

Since there are no cyclic connections for this method of specifying lambda
functions (the context of this closure is created before the closure itself is
created and then it cannot be changed ? direct circular references are
excluded, if the context contains other closures, then they must be created
before creating the current one closures and then by induction ? indirect
circular references are forbidden), you can apply the scheme of reference
counting. When you copy an object expression, the context reference count is
incremented by 1, and when you delete the list of free blocks, the reference
counters do not change. The reference count decreases by 1 only when the node
containing the closure is reused to create a new node. When the reference
counter is reduced to zero, the content of the context is reset to the free
block list.

When a closure that contains a context is activated, the context is copied into
the view field and a pointer to the function is invoked. However, if the
context is used only by this closure instance, then the context can be moved
rather than copied into the view field.

The following implementation method is assumed. Since in the Simple Refal the
parsing is done rather irregularly (at first the automaton highlights the
top-level declarations, as well as the samples and the results of each
sentence, without taking into account the pairing of the brackets and the
correctness of the declaration of the variables, then the brackets pairings are
checked separately for each sentence action, then the correctness of the use of
the variables is checked; only after this is generated the result code in C
++), then we have two ways:

1. Implement a regular syntactical analyzer (similar to Modular Refal), i.e.
   write a syntactical analyzer using recursive descent with a parallel
   analysis of the correctness of the use of variables (which is fundamentally
   important for working with context). A part of such a regular analyzer is
   written: it is an automaton processing declarations and roughing functions.
   It will only be necessary to rewrite the processing of sentences and change
   the order of generation of the final code in C ++.
2. Irregularly add support for lambda functions. One way is to add one more
   pass in the lexical convolution with checking the balancing of the curly
   brackets, while the curly brackets are wrapped in a pseudo lexeme. In this
   case, the machine for analyzing the upper-level constructions and the rough
   analysis of the body of the function will not practically change. In this
   case, the work can be divided into two stages, the first simple, the second
   more difficult:
   1. If a lambda lexeme is found in the resulting expression, create a unique
      name for the global function; in place of the lambda lexeme, put the
      operation of binding the global function with this unique name to the
      context (which at this stage will contain ALL variables from the sample
      sentence); The unique name, the contents of the lambda-token (the
      contents of the braces) and the context to be stored (in the form of
      transferring the next term from the function to the function); then, upon
      completion of the generation of a specific function, proceed to the
      processing of the lambda function, treating it as an ordinary function,
      all the samples of which begin with arguments corresponding to the
      context.
   2. At the heart of the idea is about the same, only in the context should be
      sent really used in lambda functions variables.
      
      The advantage of dividing the process into two stages is that in the
      second stage will be ready (though a curve) to support higher-order
      functions, which will dramatically increase the expressiveness of the
      Simple Refal and realize the second stage will be easier. How to
      implement the second stage ? I have not thought through to the end, but I
      suspect that with any implementation of the second stage, we cannot
      immediately send the generator individual proposals, but we need to store
      the entire function in memory (at the first stage, the stored lambda
      functions are still not parsed stream of lexemes inside braces).  It is
      possible to implement the second stage as the writing of a regular
      analyzer (see point 1).

# Results

## [1] Changes made to the compiler

Simple Refal replenished with lambda functions in accordance with the goal of
the lab. In addition, an error has been fixed that is related to the
compilation problems of the g ++ compiler in interpretation mode. The error was
that pointers to a function and pointers to string literals cannot
automatically be converted to `(void *)` (the former cannot in principle, the
latter can only be cast to `(const void *)`). An explicit cast of types in the
C-style was added. In addition, the array of commands became a static constant,
instead of the `alloc_ptr1` / `alloc_ptr2` pointers, an allox array
`[2 * sizeof (raa) / sizeof (raa [0])]` was introduced. The size of the array
is allocated with a margin (because for each command, no more than two
distributions are required, and some do not need distributions at all). Because
the array is automatic and not initialized, there is no additional expenditure
of performance for the reserve, the memory costs are negligible compared to the
memory costs on the view field. This allowed us to compare the size of the
executable file generated in both modes using the g++ compiler. The
compilation was performed with the default optimization parameters (no
additional command line switches were used). The size of the file generated in
both modes exceeds the size of the executable file generated using BCC 5.5 in
the same mode.

## [2] Ideas for using lambda functions

It can be assumed that adding lambda functions to the Refal dialect, the
control structures of which largely coincide with the subset of the Basic Refal
(the current version of the Modular Refal ? 0.1.959, Simple Refal of previous
versions), will lead to a sharp increase in the expressiveness of the language
and the development of new idioms.

One of the main problems of the subset of the Basic Refal is that you have to
write a whole lot of intermediate functions (the second problem is the absence
of rollbacks). Intermediate functions are used to analyze the result of a
function call and, depending on this, perform certain actions (I write such
functions with the prefix `Sw`); to convert the result of calling one function
in one format to another format with the purpose of returning or passing to
another function (I write such functions with the suffix `-Aux`); execution of
the tail recursive cycle (I write such functions with the prefix `Do`). If
a function has both a sense prefix and a suffix `-Aux`, then priority is
defined as a rule in meaning.

In addition, the use of higher-order library functions used to hide the loop
(`Map`, `Reduce`, `MapReduce`) requires specifying a function that needs to be
declared global.

In all these cases, lambda functions can help.

## 1. Branching, depending on the result of the function.

instead

    Func {
      argument = <SwFunc (some context) <OtherFunc some argument >>;
    }

    SwFunc {
      (context) result-1 = action-1;
      (context) result-2 = action-2;
      ....
    }

write

    Func {
      argument =
        <
          {
            result-1 = action-1;
            result-2 = action-2;
            ....
          }
          <OtherFunc some argument>
        >;
    }

The context of the function block contains the argument of the function `Func`,
so its explicit transfer is not required.

In many dialects of Refal for this purpose there exists such a construction as
an action-block (with-clause Refal 5, model block in Refal 6 and Refal Plus
(relative to the latter is not sure of terminology), operation “arrow” (fetch)
in Refal 7. The syntax of such a construction in Refal 7 would look like

    Func {
      argument =
        <OtherFunc some argument> => {
          result-1 = action-1;
          result-2 = action-2;
          ....
        };};
    }

In Refal 5, 6 and Plus, instead of the arrow, you should use a colon (in
Refal 6 you can use quadratic).

Such a syntax can be simulated as follows ? enter the function `Fetch`,
defined (in some module of the library) as:

    Fetch {
      e.Argument s.Function = <s.Function e.Argument>;
    }

Using this function, the last example will look like

    Func {
      argument =
        <Fetch
          <OtherFunc some argument>
          {
            result-1 = action-1;
            result-2 = action-2;
          }
        >;
    }

## 2. Function Format Conversion

Consider only the transformation of the function's format in order to call
the second function having a different format. The transformation of the
return value is treated similarly.

Instead

    Func {
      argument =
        <Func-Aux
          (some context) <OtherFunc some argument>;
        >;
    }

    Func-Aux {
      (context) data in the format 1 =
        <OtherFunc2 context parts and data in format 2>;
    }

Write

    Func {
      argument =
        <
          {
            data in the format 1 =
              <OtherFunc2 context parts and data in format 2>;
          }
          <OtherFunc some argument>
        >;
    }

In developed dialects of Refal (the same Refal 5, 6, 7, Plus) for this
purpose also there is a special syntax (using the where-clause in Refal 5
for rebuilding (its main purpose is checking the conditions), the actual
rebuilding in Refal Plus, the double-colon or the colon in Refal 6 and 7
(in Refal 7 it is necessary to handle the double-colon more cautiously ? it
prohibits failures in all the end of the sentence, following it, in contrast
to Refal 6, where it prohibits failure only in the following exemplary
action, but is transparent for the remaining part of the sentence)). Example
on Refal Plus:

    Func
      argument,
        <OtherFunc some argument> :: format 1 =
        <OtherFunc2 context parts and data in format 2>;

It intentionally says “`format 1`”, and not “`data in format 1`”, because after
a double-colon can only be a so-called. “hard expression”, i.e. expression
without literals, repeated variables, and open e-variables. Those. actually
format.

This syntax can be emulated using the same Fetch function:


    Func {
      argument =
        <Fetch
          <OtherFunc some argument> {
            data in the format 1 =
              <OtherFunc2 context parts and data in format 2>
          }
        >;
    }

## 3. Perform tail recursive cycles.

Here we will consider both an abstract and a real example. Let look at an
abstract example:

    Func {
      argument = <DoFunc (context) initial loop invariant>;
    }

    DoFunc {
      (context) variety of the invariant 1 =
        <DoFunc (context) change of the invariant 1>;

      (context) variety of the invariant 2 =
        return value 2;

      ....
    }

Here, the function `DoFunc` is tail recursive, the function `Func` prepares a
format for it (for example, initialization of accumulators) and prepares data
that will be rotated in a cycle (including by calling other functions). The
first sentence, with one of the varieties of the invariant, continues the
cycle, invoking itself with the modified invariant (including and with the help
of calls to other functions); The second sentence completes the loop, replacing
with the result that does not contain a recursive call. Let's illustrate this
with a real example.

    Factorial {
      0 = 1;
      s.N = <DoFact s.N 1 1>; // context, battery, cycle counter
    }

    DoFact {
      s.N. s.Prod s.N = <Mul s.Prod s.N>;
      s.N s.Prod s.K =
        <DoFact s.N <Mul s.Prod s.K> <Inc s.K >>;
    }

> *Translation to English of this hunk of historical paper is prepared by*
> **Appolonov Ilia <appolon4iks@gmail.com>** _at 2018-01-18_
